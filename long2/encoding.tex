% !TEX root = main.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ENCODING DEFINITION AND PROPERTIESs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Typed Encodings}\label{s:expr}

We define the formal notion of \emph{encoding} that we
shall use in the following section.
Known definitions of encodings are given for untyped calculi,
and are thus inappropriate for our purposes.
To this end, 
here we introduce abstract notions of calculi and encodings which are suited to our typed setting: they
essentially extend known criteria for calculi comparison, with 
additional information provided by types.


%In general, we may define:

\begin{definition}[Typed Calculus]\label{d:tcalculus}\rm
	A \emph{typed calculus} $\tyl{L}$ is a tuple:
%
	\[
		\calc{L}{T}{\hby{\ell}}{\wb}{\proves}
	\]
%
	where $L$ and $T$ are sets of processes and types, respectively.
	Also, $\hby{\ell}$, $\wb$, and $\proves$ 
	denote a transition semantics, a process equivalence, 
	and a type system for $L$ processes, respectively. 
\end{definition}

The typed calculi we considered here
derive from the definition of \HOp.
Subcalculi of 
\HOp share the same
type system (as in \S\,\ref{s:types}),
transition semantics (cf.~Def.~\ref{d:tlts}) 
with labels $\ell$ (as in  \S\,\ref{ss:lts}).
We use Higher-Order Bisimulation
(cf.~Def.~\ref{def:HO_bisim}) except in the case
of the sub-calculus  \sessp, which uses the
First-Order Bisimulation (cf.~Def.~\ref{def:FO_bisim})

In the following, when writing $\tyl{L}_i$ we tacitly
assume the existence of appropriate 
calculus $L_i$, type syntax $T_i$ and behavioral relation $\wb$,
keeping all other elements unchanged.
We now define the notion of encoding over typed calculi.

\begin{definition}[Typed Encoding]\rm
	Let  $\tyl{L}_1$ and $\tyl{L}_2$ 
	be typed calculi.
	Given mappings $\map{\cdot}: L_1 \to L_2$, 
	$\mapt{\cdot}: T_1 \to T_2$, and 
	$\mapa{\cdot}: \ell \to \ell$, 
	we write 
	$\enco{\map{\cdot}, \mapt{\cdot}, \mapa{\cdot}} : \tyl{L}_1 \to \tyl{L}_2$
	to denote the \emph{typed encoding} of $\tyl{L}_1$ into $\tyl{L}_2$.
\end{definition}

Our notion of encoding considers a mapping on processes, 
a mapping on types, 
and a mapping
from transition labels 
into labels.
We will often assume that  $\mapt{\cdot}$ extends to typing
environments as expected. This way, e.g., $\mapt{\Delta \cat u:S} = \mapt{\Delta} \cat u:\mapt{S}$.
As we will define several typed encodings,  
in the following we use number decorations on these 
mappings to distinguish them.

We require that a typed encoding should be 
{\em good}, which formally means adherence to
syntactic criteria, but
also preservation of typing and operational semantics.
The following definition gives syntactic criteria for (typed) encodings.
We require some extra notation.
Let $\sigma$ denote a substitution of names for names (a renaming, in the usual sense). Given environments $\Delta$ and $\Gamma$,
we write $\sigma(\Delta)$ and $\sigma(\Gamma)$ to denote the effect of applying $\sigma$ on the 
domains of $\Delta$ and $\Gamma$.
(Clearly, $\sigma(\Gamma)$ concerns only shared names in $\Gamma$: process and recursion variables in $\Gamma$ are not affected by $\sigma$.)
% \\ \jp{Still need to define what renaming policies makes sense for our typed setting!}

\begin{definition}[Syntax Preserving Encoding]\rm
	\label{def:sep}
	We say that 
	the typed encoding 
	$\enco{\map{\cdot}, \mapt{\cdot}, \mapa{\cdot}}: \tyl{L}_1 \to \tyl{L}_2$ is \emph{syntax preserving}
	if it is:
	
	\begin{enumerate}[1.]
		\item	\emph{Homomorphic wrt parallel},   if 
		$\mapt{\Gamma}; \emptyset; \mapt{\Delta_1 \cat \Delta_2} \proves \map{P_1 \Par P_2} \hastype \Proc$
		then \\
		$\mapt{\Gamma}; \emptyset; \mapt{\Delta_1} \cat \mapt{\Delta_2} \proves \map{P_1} \Par \map{P_2} \hastype \Proc$.

		\item	\emph{Compositional wrt restriction},  if 
		$\mapt{\Gamma}; \emptyset; \mapt{\Delta} \proves \map{\news{n}P} \hastype \Proc$
		then \\
		$\mapt{\Gamma}; \emptyset; \mapt{\Delta} \proves \news{n}\map{P} \hastype \Proc$.
		
		\item \emph{Name invariant},   if
		$\mapt{\sigma(\Gamma)}; \emptyset; \mapt{\sigma(\Delta)} \proves \map{\sigma(P)} \hastype \Proc$
		then \\
		$\sigma(\mapt{\Gamma}); \emptyset; \sigma(\mapt{\Delta}) \proves \sigma(\map{P}) \hastype \Proc$, 
		for any injective renaming  of names $\sigma$.

		
	\end{enumerate}
\end{definition}

We now state semantic criteria:

\begin{definition}[Semantic Preserving Encoding]\rm
	\label{def:ep}
	We say that 
	the typed encoding 
	$\enco{\map{\cdot}, \mapt{\cdot}, \mapa{\cdot}}: \tyl{L}_1 \to \tyl{L}_2$ is \emph{semantic preserving}
	if it satisfies the following properties:
	
	\begin{enumerate}[1.]
		\item	\emph{Type preservation}:
			For all $P \in L_1$,
			$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ implies
			$\mapt{\Gamma}; \emptyset; \mapt{\Delta} \proves \map{P} \hastype \Proc$.

		\item \emph{Operational Correspondence}: If $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then
		\begin{enumerate}[a)]
			\item	Completeness: 
				If  $\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$
				then \\ $\exists \ell_2$ s.t. 
				$\wtytra{\mapt{\Gamma}}{\ell_2}{\mapt{\Delta}}{\map{P}}{\mapt{\Delta'}}{\map{P'}}$
				and $\ell_2 = \mapa{\ell_1}$.

%			\item	Soundness:   
%				If  $\horel{\mapt{\Gamma}}{\mapt{\Delta_1}}{\map{P}}{\hby{\ell_1}}{\Delta''_1}{Q'}$
%				then $\exists \ell, P'$ s.t.  \\
%				(i)~$\stytra{\Gamma}{\ell}{\Delta_1}{P}{\Delta'_1}{P'}$,
%				(ii)~$\horel{\mapt{\Gamma}}{\Delta''_1}{Q'}{\Hby{\ell_2}}{\mapt{\Delta'_1}}{Q}$,
%				(iii)~$\Hby{\mapa{\ell}} = \hby{\ell_1} \Hby{\ell_2}$, and
%%				(iv)~$\ell_2 = \mapa{\ell_1}$, and
%				(iv)~$\horel{\mapt{\Gamma}}{\mapt{\Delta'_1}}{\map{P'}}{\wb_2}{\mapt{\Delta'_1}}{Q}$.
			    				
			\item	Soundness:   
				If  $\wtytra{\mapt{\Gamma}}{\ell_2}{\mapt{\Delta}}{\map{P}}{\mapt{\Delta'}}{Q}$
				then $\exists \ell_1, P'$ s.t.  \\
				(i)~$\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$,
				(ii)~$\ell_2 = \mapa{\ell_1}$, and
				(iii)~$\horel{\mapt{\Gamma}}{\mapt{\Delta'}}{\map{P'}}{\wb_2}{\mapt{\Delta'}}{Q}$.
		\end{enumerate}
		
		\item	\emph{Full Abstraction:} \\
			$\horel{\Gamma}{\Delta_1}{P}{\wb_1}{\Delta_2}{Q}$
			if and only if
			$\horel{\mapt{\Gamma}}{\mapt{\Delta_1}}{\map{P}}{\wb_2}{\mapt{\Delta_2}}{\map{Q}}$.
	\end{enumerate}
\end{definition}

The conditions are natural. Type preservation enables us to focus on encodings which retain the communication structures denoted by (session) types.
Our definition of typed operational correspondence builds upon analogous definitions in the untyped setting (cf. Gorla's).
We used labeled transitions, and so correspondences involve the mapping $\mapa{\cdot}$.
Soundness ensures that typed behaviors in the source process are mimicked 
by its associated encoding. Completeness concerns the opposite direction.
We present generic definitions for soundness and completeness: in the encodability results presented below
we will be able to give stronger statements for these criteria, tailored to the specifics of each encoding.
Finally, we consider full abstraction as a criteria for typed encodings. This is sensible in our setting, as we are interested in transferring tractable reasoning techniques between different typed calculi.

\begin{definition}[Typed Encodings: Good and Basic]\label{def:goodenc}
We say that 
	the typed encoding 
	$\enco{\map{\cdot}, \mapt{\cdot}, \mapa{\cdot}}: \tyl{L}_1 \to \tyl{L}_2$ is 
	\begin{enumerate}[$-$]
	\item \emph{good}, if it is syntax preserving and semantic preserving (cf. Definitions \ref{def:sep} and  \ref{def:ep}).
	\item \emph{basic}, if it is syntax preserving 
	(cf. Definition \ref{def:sep}),
	barb preserving, and enjoys operational completeness (cf. Definition \ref{def:ep}-2(a)).
	\end{enumerate}
\end{definition}

Good encodings offer more detailed criteria and so they are tailored to encodability (positive) results (\S\,\ref{s:positive}).
In contrast, basic encodings contains only some of the criteria of good encodings: 
we shall use this minimal notion for the negative result in \S\,\ref{s:negative}.
	

%\begin{remark}\label{r:multilabels}
%	We  assume that if 
%	$P \hby{\ell} P'$ and $\mapa{\ell} = \{\ell_1, \ell_2,  \cdots, \ell_m\}$ then
%	$\map{P} \Hby{\mapa{\ell}} \map{P'}$
%	should be understood as
%	$\map{P} \Hby{\ell_1} P_1 \Hby{\ell_2} P_2 \cdots \Hby{\ell_m} P_m =  \map{P'}$,
%	for some
%	$P_1, P_2, \ldots, P_m$.
%	This is useful for the encoding of polyadic into monadic communication.
%\end{remark}

We show that the composition of encodings is closed on the above properties.

\begin{proposition}[Composability of Semantic Preserving Encodings]\rm
	Let encodings 
	$\enco{\map{\cdot}^{1}, \mapt{\cdot}^{1}, \mapa{\cdot}^{1}}: \tyl{L}_1 \to \tyl{L}_2$
	and 
	$\enco{\map{\cdot}^{2}, \mapt{\cdot}^{2}, \mapa{\cdot}^{2}}: \tyl{L}_2 \to \tyl{L}_3$
	be two semantic preserving encodings.
	Then their composition, denoted 
	$\enco{\map{\cdot}^{1} \circ \map{\cdot}^{2}, \mapt{\cdot}^{1} \circ \mapt{\cdot}^{2}, \mapa{\cdot}^{1}\circ \mapa{\cdot}^{2}}: \tyl{L}_1 \to \tyl{L}_3$
	is also a semantic preserving encoding.
\end{proposition}

\begin{proof}
	Straightforward application of the definition of each property.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  HOp --> HO AND HOp --> p
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Positive Expressiveness Results}\label{s:positive}
In this section we present a study of the expressiveness of $\HOp$ and its subcalculi. 
We present two encodings:
%
\begin{enumerate}[1.]
%	\item Polyadic into Monadic Communication (\S\,\ref{ss:polmon})
%	\item Finite First-Order Communication into Higher-Order Communication (\S\,\ref{ss:ffotoho})
	\item Higher-Order $\pi$-calculus into Higher-Order  (\S~\ref{subsec:HOp_to_HO})
	\item Higher-Order $\pi$-calculus into First-Order Communication (\S~\ref{subsec:HOp_to_FO})
\end{enumerate}
%
In each case, encoding correctness is supported by type preservation and operational correspondence statements.
Full abstraction results are conjectured, for the moment.

\begin{remark}[Polyadic \HOp]
	We can assume a semantic preserving encoding from the polyadic
	\HOp to the monadic \HOp. Polyadic \HOp assumes a polyadic
	extension of the \HOp semantics that defines values as
	$V \bnfis \tilde{u} \bnfbar \abs{\tilde{x}}{P}$
	and input prefix as $\binp{n}{\tilde{x}} P$.
\end{remark}

\begin{comment}
\subsection*{Preliminaries}

The following result may be related to Lemma~\ref{l:invariant}: \jp{TO BE ADJUSTED with new typed LTS!}

\begin{lemma}[Inversion for (Untyped) Transitions]
\begin{enumerate}[1.]
% output
\item If $\Gamma;\, \emptyset;\, \Delta_1 \cat \Delta_2 \cat k:\btout{U}S \proves \bout{k}{V}P' \hastype \Proc$
and $\Gamma;\, \emptyset;\, \Delta_2 \cat k:S \proves V \hastype U$ then \\
$\bout{k}{V}P' \by{\bactout{k}{V}} P'$
and $\Gamma;\, \emptyset;\, \Delta_1 \proves P' \hastype \Proc$.

\item If $\Gamma;\, \emptyset;\, \Delta_1 \cat \Delta_2 \cat k:\btout{U}S \proves \bout{k}{V}P' \hastype \Proc$
and $\Gamma;\, \emptyset;\, \Delta_2 \proves V \hastype U$ (with $k:S \not\in \Delta_2$) then \\
$\bout{k}{V}P' \by{\bactout{k}{V}} P'$
and $\Gamma;\, \emptyset;\, \Delta_1 \cat k:S \proves P' \hastype \Proc$.

% input
\item If $\Gamma;\, \emptyset;\, \Delta \cat k:\btinp{\mytilde{C}}S \proves \binp{k}{\mytilde{x}}P' \hastype \Proc$
 then \\
$\binp{k}{\mytilde{x}}P' \by{\bactinp{k}{\mytilde{m}}} P'\subst{\mytilde{m}}{\mytilde{x}}$
and $\Gamma;\, \emptyset;\, \Delta \cat k:S \cat \mytilde{m}:\mytilde{C} \proves P'\subst{\mytilde{m}}{\mytilde{x}} \hastype \Proc$


\item If $\Gamma;\, \emptyset;\, \Delta_1 \setminus \Delta_2 \cat k:\btinp{L}S \proves \binp{k}{X}P' \hastype \Proc$
and
$\Gamma;\, \emptyset;\, \Delta_2   \proves X \hastype L$
 then \\
$\binp{k}{X}P' \by{\bactinp{k}{V}} P'\subst{V}{X}$
and $\Gamma;\, \emptyset;\, \Delta_1 \cat k:S \proves P'\subst{V}{X} \hastype \Proc$

% branch
\item If $\Gamma;\, \emptyset;\, \Delta \cat k:\btbra{l_i:S_i}_{i \in I} \proves \bbra{k}{l_i : P_i}_{i \in I}  \hastype \Proc$
 then, for any $j \in I$, we have \\
$\bbra{k}{l_i : P_i}_{i \in I} \by{\bactbra{k}{l_j}} P_j $
and $\Gamma;\, \emptyset;\, \Delta \cat k:S_j   \proves P_j \hastype \Proc$

% selecy
\item If $\Gamma;\, \emptyset;\, \Delta \cat k:\btsel{l_i:S_i}_{i \in I} \proves \bsel{k}{l_j} P_j  \hastype \Proc$
 then \\
$\bsel{k}{l_j} P_j \by{\bactsel{k}{l_j}} P_j $
and $\Gamma;\, \emptyset;\, \Delta \cat k:S_j   \proves P_j \hastype \Proc$

% bound output
\item Suppose (i)~$\Gamma;\, \emptyset;\, (\Delta_1 \cat \Delta_2) \setminus \{k:S_0, s:T\} \cat k:\btout{U}S_0 
\proves \news{s}\bout{k}{V}P' \hastype \Proc$, \\
(ii)~$\Gamma;\, \emptyset;\, \Delta_2 \cat \dual{s}:S \proves V \hastype U$ (with $S \dualof T$),
and (iii)~$\{k:S_0, s:T\} \in \Delta_1 \cat \Delta_2$. \\
Then 
$\news{s}\bout{k}{V}P' \by{\news{s}\bactout{k}{V}} P'$
and $\Gamma;\, \emptyset;\, \Delta^* \proves P' \hastype \Proc$, with \\
$(\Delta^* = \Delta_1 \cat k:S_0 \cat s:T) \lor (\Delta^* = \Delta_1 \cat k:S_0) \lor
(\Delta^* = \Delta_1 \cat  s:T) \lor (\Delta^* = \Delta_1)$.


% bound output
\item Suppose (i)~$\Gamma;\, \emptyset;\, \Delta \cat k:\btout{U}S_0 
\proves \news{s}\bout{k}{V}P' \hastype \Proc$
(with $\{k:S_0, s:T\} \not\subseteq \Delta$), 
(ii)~$\Gamma;\, \emptyset;\, \Delta_2 \cat \dual{s}:S \proves V \hastype U$ (with $S \dualof T$),
and (iii)~$\Delta_2 \subseteq \Delta$. 
Then $\news{s}\bout{k}{V}P' \by{\news{s}\bactout{k}{V}} P'$ and \\
$\Gamma;\, \emptyset;\, \Delta^* \proves P' \hastype \Proc$, with \\
$(\Delta^* = \Delta \setminus \Delta_2 \cat k:S_0 \cat s:T) \lor (\Delta^* = \Delta \setminus \Delta_2 \cat k:S_0) \lor
(\Delta^* = \Delta \setminus \Delta_2 \cat  s:T) \lor (\Delta^* = \Delta \setminus \Delta_2)$.


\end{enumerate}
\end{lemma}



\subsection{Encoding Polyadic Semantics (\HOp) to Monadic Semantics ($\HOp^{-\mathsf{p}}$)}\label{ss:polmon}


In the untyped $\pi$-calculus, polyadic communication
can be encoded into monadic name passing by first generating a fresh channel and then 
performing $n$ monadic synchronizations on that channel. 
In session-typed $\pi$-calculi this encoding is even more direct, 
thanks to the linearity and non-interference  of session endpoints~\cite{VascoFun}.
Below we  define an encoding of polyadic semantics to monadic semantics.
Using this encoding, %Because of the polyadic to monadic encoding %, denoted  $\auxmap{\cdot}{\mathsf{p}}$,
we may focus on monadic session processes,
and rely on polyadic constructs simply as convenient syntactic sugar.
In fact, we shall rely on polyadicity to encode recursive behaviors.
%
\begin{definition}[Polyadic Into Monadic]\rm
	\label{d:enc:poltomon}
	Let 
	$\enco{\map{\cdot}^{\mathsf{p}}, \mapt{\cdot}^{\mathsf{p}}, \mapa{\cdot}^{\mathsf{p}}}: \HOp \to \HOp^{-\mathsf{p}}$
	be a typed encoding where
	%$\auxmap{\cdot}{\mathsf{p}}:\pHOp \to \HOp$ as
\begin{figure}[t]
\[
	\begin{array}{rcl}
		\map{\bout{k}{k_1, \cdots, k_m} P}^{\mathsf{p}}
		&\defeq&
		\bout{k}{k_1} \cdots ;  \bout{k}{k_m} \map{P}^{\mathsf{p}}
		\\
			\map{\binp{k}{x_1, \cdots, x_m} P}^{\mathsf{p}}
		&\defeq&
		\binp{k}{x_1} \cdots ; \binp{k}{x_m}  \map{P}^{\mathsf{p}}
		\\
		\map{\bbout{k}{\abs{x_1, \cdots, x_m} Q} P}^{\mathsf{p}}
		&\defeq&
		\bbout{k}{\abs{z}\binp{z}{x_1} \cdots ; \binp{z}{x_m} \map{Q}^{\mathsf{p}}} \map{P}^{\mathsf{p}}
		\\ 
		\map{\appl{X}{k_1, \cdots, k_m}}^{\mathsf{p}}
		&\defeq&
		\newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{k_1} \cdots ; \bout{\dual{s}}{k_m} \inact} 
        \\ % typed mapping starts here
		\tmap{\btout{S_1, \cdots, S_m}S}{\mathsf{p}}
		&\defeq&
		\btout{\tmap{S_1}{\mathsf{p}}} \cdots ; \btout{\tmap{S_m}{\mathsf{p}}}\tmap{S}{\mathsf{p}}
		\\
		\tmap{\btinp{S_1, \cdots, S_m}S}{\mathsf{p}}
		&\defeq&
		\btinp{\tmap{S_1}{\mathsf{p}}} \cdots ; \btinp{\tmap{S_m}{\mathsf{p}}}\tmap{S}{\mathsf{p}}
		\\
		\tmap{\bbtout{L} S}{\mathsf{p}}
		&\defeq&
		\bbtout{\mapt{L}^{\mathsf{p}}}\mapt{S}^{\mathsf{p}}
		\\
		\tmap{\bbtinp{L} S}{\mathsf{p}}
		&\defeq&
		\bbtinp{\mapt{L}^{\mathsf{p}}}\mapt{S}^{\mathsf{p}}
		\\
%		\tmap{\bbtout{\shot{(C_1, \cdots, C_m)}} S}{\mathsf{p}}
%		&\defeq&
%		\bbtout{
%		\shot{\big(\btinp{\tmap{C_1}{\mathsf{p}}} \cdots; \btinp{\tmap{C_m}{\mathsf{p}}}\tinact\big)}}\mapt{S}^{\mathsf{p}}
%		\\
%		\tmap{\bbtinp{\shot{(C_1, \cdots, C_m)}} S}{\mathsf{p}}
%		&\defeq&
%		\bbtinp{
%		\shot{\big(\btinp{\tmap{C_1}{\mathsf{p}}} \cdots; \btinp{\tmap{C_m}{\mathsf{p}}}\tinact\big)}}\mapt{S}^{\mathsf{p}}
%		\\
		\tmap{\shot{(C_1, \cdots, C_m)}}{\mathsf{p}}
		&\defeq&
		\shot{\big(\btinp{\tmap{C_1}{\mathsf{p}}} \cdots; \btinp{\tmap{C_m}{\mathsf{p}}}\tinact\big)}
		\\
		\tmap{\lhot{(C_1, \cdots, C_m)}}{\mathsf{p}}
		&\defeq&
		\lhot{\big(\btinp{\tmap{C_1}{\mathsf{p}}} \cdots; \btinp{\tmap{C_m}{\mathsf{p}}}\tinact\big)}
		\\
%		\tmap{\lhot{(C_1, \cdots, C_m)}}{\mathsf{p}}
%		&\defeq&
%		\lhot{\big(\btinp{\tmap{C_1}{\mathsf{p}}} \cdots \btinp{\tmap{C_m}{\mathsf{p}}}\tinact\big)}
%		\\
%		\tmap{\shot{(C_1, \cdots, C_m)}}{\mathsf{p}}
%		&\defeq&
%		\shot{\big(\btinp{\tmap{C_1}{\mathsf{p}}} \cdots \btinp{\tmap{C_m}{\mathsf{p}}}\tinact\big)}
%		\\ % action mapping starts here
		\mapa{\bactout{k}{k_1, \ldots, k_m}}^\mathsf{p} &\defeq&   \big\{\bactout{k}{k_1}, \cdots, \bactout{k}{k_m}\big\} \\
		\mapa{\bactinp{k}{k_1, \ldots, k_m}}^\mathsf{p} &\defeq&   \big\{\bactinp{k}{k_1}, \cdots, \bactinp{k}{k_m} \big\}\\
		\mapa{\bactout{k}{\abs{x_1, \ldots, x_m}{P}} }^\mathsf{p} &\defeq&  \bactout{k}{\abs{z}\binp{z}{x_1} \cdots ; \binp{z}{x_m} \map{P}^{\mathsf{p}}} \\
		\mapa{\bactinp{k}{\abs{x_1, \ldots, x_m}{P}} }^\mathsf{p} &\defeq&  \bactinp{k}{\abs{z}\binp{z}{x_1} \cdots ; \binp{z}{x_m} \map{P}^{\mathsf{p}}} 
	\end{array}
\]
\caption{\label{f:enc:poltomon}
Typed encoding of polyadic into monadic communication (cf.~Defintion \ref{d:enc:poltomon}). 
Mappings 
$\map{\cdot}^\mathsf{p}$,
$\mapt{\cdot}^\mathsf{p}$, 
and 
$\mapa{\cdot}^\mathsf{p}$
are homomorphisms for the other processes/types/labels. 
}
\end{figure}
mappings $\map{\cdot}^{\mathsf{p}}$, $\mapt{\cdot}^{\mathsf{p}}$, $\mapa{\cdot}^{\mathsf{p}}$
are 
as in Fig.~\ref{f:enc:poltomon}.
	%\jp{I prefer to be explicit in the encoding of polyadic abstraction/applications. Previous version is commented.}
\end{definition}
%
The encoding is simple:
passing an $m$-tuple of names over a session channel $k$ is represented by 
a $m$ exchanges along channel $k$.
The output of an abstraction with $m$ bound variables $x_1, \ldots, x_m$ is represented by
outputting an abstraction with a single bound variable $z$,
which is used as the subject for receiving $x_1, \ldots, x_m$ individually. 
Accordingly, 
%When we are dealing with an abstraction over a list of bound variables,
%then we create a new abstraction name and we use it to receive in a polyadic
%way the list of names on the abstraction. Similarly 
the encoding of a polyadic application  instantiates
the abstraction subject with a freshly generated session name $s$, which will be used  
to the names 
$k_1, \ldots, k_m$
that are going to be applied on the abstraction.
Observe how $\mapa{\cdot}^{\mathsf{p}}$ maps polyadic labels for input and output into (ordered) sets of
monadic labels. Also, note that we do not allow polyadic mapping on shared names.
The polyadic mapping, as presented here, is sound only on session names.
%The semantics might break if we apply this mapping on shared names.

%\begin{proposition}
%	$\Gamma; \emptyset; \Sigma \proves \map{P}^{p} \hastype \Proc$
%\end{proposition}

\begin{proposition}[Type Preservation, Polyadic to Monadic]\label{prop:typepresp}
Let $P$ be an  $\HOp$ process.
If			$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then 
			$\mapt{\Gamma}^{\mathsf{p}}; \emptyset; \mapt{\Delta}^{\mathsf{p}} \proves \map{P}^{\mathsf{p}} \hastype \Proc$. 
\end{proposition}

\begin{proof}
By induction on the inference $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$.
Details in \S\,\ref{app:polmon}.
	\qed
\end{proof}

\begin{proposition}\label{p:poltomo}
Let $P$ be a well-typed process.
\begin{enumerate}[$-$]
\item If $\map{P\subst{k_1,\cdots, k_m}{x_1, \cdots, x_m}}^{\mathsf{p}} = \map{P}^{\mathsf{p}}\subst{k_1}{x_1}\cdots\subst{k_m}{x_m}$.


\item If $\map{P\subst{\abs{x_1, \cdots, x_m} Q}{X}}^{\mathsf{p}} = \map{P}^{\mathsf{p}}\subst{\abs{z}\binp{z}{x_1} \cdots ; \binp{z}{x_m} \map{Q}^{\mathsf{p}}}{X}$.

\end{enumerate}
\end{proposition}
\begin{proof}
Immediate from the definition of $\map{\cdot}^{\mathsf{p}}$ (cf. Def.~\ref{d:enc:poltomon}).
	\qed
\end{proof}


\begin{proposition}[Operational Correspondence, Polyadic to Monadic]\label{p:ocpotomo}
Let $P$ be an  $\HOp$ process.
If $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then
		\begin{enumerate}[1.]
			\item	 
			   If  $\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$
			   then either
			   \begin{enumerate}[a)]
					\item $\exists \ell'$ s.t. 
					$\mapa{\ell_1} = \ell'$ and 
			    $\wtytra{\mapt{\Gamma}^{\mathsf{p}}}{\ell'}{\mapt{\Delta}^{\mathsf{p}}}{\map{P}}{\mapt{\Delta'}^{\mathsf{p}}}{\map{P'}}$.
			    
			    	\item $\exists \ell'_1, \cdots, \ell'_n, R_1, \cdots, R_n$ s.t.
				    $\map{P} \Hby{\ell'_1} R_1, R_1 \Hby{\ell'_2} R_2, \ldots, R_{n-1} \Hby{\ell'_n} R_n = \map{P'}^{\mathsf{p}}$.
				    %and \\ $\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\mapt{\Delta'}^{\mathsf{p}}}{\map{P'}^{\mathsf{p}}}{\mapt{\Delta'}^{\mathsf{p}}}{R_n}$.
					\end{enumerate}
			   
			   
			    
			\item   
			If  $\stytra{\mapt{\Gamma}^{\mathsf{p}}}{\ell'_1}{\mapt{\Delta}^{\mathsf{p}}}{\map{P}}{\mapt{\Delta'}^{\mathsf{p}}}{R}$
			   then 
			   $\exists \ell_1, P'$ s.t.  
			   $\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$
			   and 
			   either
			   		\begin{enumerate}[a)]
					\item   
			      $\ell'_1 = \mapa{\ell_1}^{\mathsf{p}}$ ~~and~~ 
			    $\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\mapt{\Delta'}^{\mathsf{p}}}{\map{P'}^{\mathsf{p}}}{\mapt{\Delta'}^{\mathsf{p}}}{R}$.
			   		
					\item $\exists \ell'_2, \ldots, \ell'_n, R_2, \ldots, R_n$ s.t. 
					(i) $R \hby{\ell'_2} R_2   \cdots  R_{n-1} \hby{\ell'_n} R_n$,  
					(ii)~$\{\ell'_1, \ell'_2, \cdots, \ell'_n\} = \mapa{\ell_1}^{\mathsf{p}}$, \\ and 
					(iii)~$\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\mapt{\Delta'}^{\mathsf{p}}}{\map{P'}^{\mathsf{p}}}{\mapt{\Delta'}^{\mathsf{p}}}{R_n}$.
					\end{enumerate}


%			\item   
%			If  $\wtytra{\mapt{\Gamma}^{\mathsf{p}}}{\ell_2}{\mapt{\Delta_1}^{\mathsf{p}}}{\map{P}}{\mapt{\Delta'_1}^{\mathsf{p}}}{Q}$
%			   then $\exists \ell_1, P$ s.t.  
%			    (i)~$\stytra{\Gamma}{\ell_1}{\Delta_1}{P}{\Delta'_1}{P'}$, \\
%			    (ii)~$\ell_2 = \mapa{\ell_1}^{\mathsf{p}}$, 
%			    (iii)~$\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\mapt{\Delta'_1}^{\mathsf{p}}}{\map{P'}^{\mathsf{p}}}{\mapt{\Delta'_1}^{\mathsf{p}}}{Q}$.


			    \end{enumerate}
\end{proposition}

\begin{proof}
By transition induction.
%, considering Remark~\ref{r:multilabels} for weak transitions. All cases are easy;
%we only remark that the additional $\tau$-transitions induced by the encoding 
%are directly associated to the polyadicity involved. This is particularly relevant
%when $\ell_1 = \bactinp{n}{\abs{\tilde{x}}{P}}$, for the encoding of a polyadic application involves
%as many $\tau$-transitions (i.e., synchronizations on the restricted name $s$) 
%as polyadic parameters are involved.	\\
We consider parts (1) and (2) separately: \\
\noi \textbf{Part (1)}. We consider two non-trivial cases, using biadic communication:
\begin{enumerate}[1.]

%% Biadic Output 
\item Case  $P =\bout{k}{k_1, k_2} P'$ and $\ell_1 = \bactout{k}{k_1, k_2}$. 
We show that this case falls under part (b) of the thesis.
By assumption, $P$ is well-typed. 
As one particular possibility, we may have:
			\[
				\tree{
					\Gamma; \emptyset; \Delta_0 \cat k:S  \proves  P' \hastype \Proc \quad 
					\Gamma ; \emptyset ; k_1{:} S_1 \cat k_2{:}S_2 \proves  k_1,k_2 \hastype S_1,S_2}{
					\Gamma; \emptyset; \Delta_0 \cat k_1{:}S_1 \cat k_2{:}S_2 \cat k:\btout{S_1,S_2}S \proves  
					\bout{k}{k_1,k_2} P' \hastype \Proc}
			\]
for some $\Gamma, S, S_1, S_2, \Delta_0$, 
such that $\Delta = \Delta_0 \cat k_1{:}S_1 \cat k_2{:}S_2 \cat k:\btout{S_1,S_2}S$.
We may then have the following typed transition
$$
\stytra{\Gamma}{\ell_1}{\Delta_0 \cat k_1{:}S_1 \cat k_2{:}S_2 \cat k:\btout{S_1,S_2}S}{\bout{k}{k_1, k_2} P'}{\Delta_0 \cat k{:}S}{P'}
$$
The encoding of the source judgment for $P$ is as follows:
$$
\mapt{\Gamma}^{\mathsf{p}}; \emptyset; \mapt{\Delta_0 \cat k_1{:}S_1 \cat k_2{:}S_2 \cat k:\btout{S_1,S_2}S}^{\mathsf{p}} \proves \map{\bout{k}{k_1, k_2} P'}^{\mathsf{p}} \hastype \Proc
$$
which, using Def.~\ref{d:enc:poltomon}, can be expressed as 
$$
\mapt{\Gamma}^{\mathsf{p}}; \emptyset; \mapt{\Delta_0} 
\cat k_1{:}\mapt{S_1}^{\mathsf{p}} \cat k_2{:}\mapt{S_2}^{\mathsf{p}} 
\cat k:\btout{\mapt{S_1}^{\mathsf{p}}}\btout{\mapt{S_2}^{\mathsf{p}}}\mapt{S}^{\mathsf{p}}
\proves 
\bout{k}{k_1}\bout{k}{k_2} \map{P'}^{\mathsf{p}} 
\hastype \Proc
$$
Now, $\mapa{\ell_1}^{\mathsf{p}} = \{ \bactout{k}{k_1 }, \bactout{k}{ k_2}\}$. 
It is immediate to infer the following typed transitions for $\map{P}^{\mathsf{p}}  = \bout{k}{k_1}\bout{k}{k_2} \map{P'}^{\mathsf{p}} $:
\begin{eqnarray*}
& & \mapt{\Gamma}^{\mathsf{p}}; 
\mapt{\Delta_0} \cat  k_1{:}\mapt{S_1}^{\mathsf{p}} \cat k_2{:}\mapt{S_2}^{\mathsf{p}} \cat
k:\btout{\mapt{S_1}^{\mathsf{p}}}\btout{\mapt{S_2}^{\mathsf{p}}}\mapt{S}^{\mathsf{p}}
\proves 
\bout{k}{k_1}\bout{k}{k_2} \map{P'}^{\mathsf{p}}  \\
& \hby{\bactout{k}{k_1}} & 
\mapt{\Gamma}^{\mathsf{p}}; \mapt{\Delta_0} \cat  k_2{:}\mapt{S_2}^{\mathsf{p}} \cat
k:\btout{\mapt{S_2}^{\mathsf{p}}}\mapt{S}^{\mathsf{p}}
\proves 
\bout{k}{k_2} \map{P'}^{\mathsf{p}} \\
& \hby{\bactout{k}{k_2}} & 
\mapt{\Gamma}^{\mathsf{p}}; \mapt{\Delta_0}  \cat k{:}\mapt{S}^{\mathsf{p}}
\proves 
 \map{P'}^{\mathsf{p}} \\
 & = & 
 \mapt{\Gamma}^{\mathsf{p}}; \mapt{\Delta_0 \cat
k:S }^{\mathsf{p}}
\proves 
 \map{P'}^{\mathsf{p}}
\end{eqnarray*}
which concludes the proof for this case.

%% Biadic Abstraction Output 
\item Case  $P = \bbout{k}{\abs{x_1, x_2} Q} P' $ and $\ell_1 = \bactout{k}{\abs{x_1, x_2}{Q}}$. 
We show that this case falls under part (a) of the thesis.
By assumption, $P$ is well-typed. 
We may have:
			\[
				\tree{
					\Gamma; \emptyset; \Delta_0 \cat k:S  \proves  P' \hastype \Proc \quad 
					\Gamma ; \emptyset ; \Delta_1 \proves  \abs{x_1,x_2}Q \hastype \lhot{(C_1,C_2)}}{
					\Gamma; \emptyset; \Delta_0 \cat \Delta_1 \cat k:\btout{\lhot{(C_1,C_2)}}S \proves  
					\bout{k}{\abs{x_1,x_2}Q} P' \hastype \Proc}
			\]
for some $\Gamma, S, C_1, C_2, \Delta_0, \Delta_1$, 
such that $\Delta = \Delta_0 \cat \Delta_1 \cat  k:\btout{\lhot{(C_1,C_2)}}S$.
(For simplicity, we consider only the case of a linear function.)
We may have the following typed transition:
$$
\stytra{\Gamma}{\ell_1}{\Delta_0 \cat \Delta_1 \cat k:\bbtout{\lhot{(C_1, C_2)}}S}{\bbout{k}{\abs{x_1, x_2} Q} P' }{\Delta_0 \cat k{:}S}{P'}
$$
The encoding of the source judgment is
$$
\mapt{\Gamma}^{\mathsf{p}}; \emptyset; \mapt{\Delta_0 \cat \Delta_1 \cat k:\bbtout{\lhot{(C_1, C_2)}}S}^{\mathsf{p}} \proves \map{\bbout{k}{\abs{x_1, x_2} Q} P' }^{\mathsf{p}} \hastype \Proc
$$
which, using Def.~\ref{d:enc:poltomon}, can be equivalently expressed as 
$$
\mapt{\Gamma}^{\mathsf{p}}; \emptyset; \mapt{\Delta_0 \cat \Delta_1} \cat
%k:\btout{\mapt{S_1}^{\mathsf{p}}}\btout{\mapt{S_2}^{\mathsf{p}}}\mapt{S}^{\mathsf{p}}
k:\bbtout{
		\lhot{\big(\btinp{\tmap{C_1}{\mathsf{p}}}\btinp{\tmap{C_2}{\mathsf{p}}}\tinact\big)}}\mapt{S}^{\mathsf{p}}
\proves 
\bbout{k}{\abs{z}\binp{z}{x_1} \binp{z}{x_2} \map{Q}^{\mathsf{p}}} \map{P'}^{\mathsf{p}}
\hastype \Proc
$$

Now, $\mapa{\ell_1}^{\mathsf{p}} = \bactout{k}{\abs{z}\binp{z}{x_1}\binp{z}{x_2} \map{Q}^{\mathsf{p}}}$. 
It is immediate to infer the following typed transition for $\map{P}^{\mathsf{p}}  = \bbout{k}{\abs{z}\binp{z}{x_1} \binp{z}{x_2} \map{Q}^{\mathsf{p}}} \map{P'}^{\mathsf{p}}$:
\begin{eqnarray*}
& & \mapt{\Gamma}^{\mathsf{p}}; \mapt{\Delta_0 \cat \Delta_1} \cat
%k:\btout{\mapt{S_1}^{\mathsf{p}}}\btout{\mapt{S_2}^{\mathsf{p}}}\mapt{S}^{\mathsf{p}}
k:\bbtout{
		\lhot{\big(\btinp{\tmap{C_1}{\mathsf{p}}}\btinp{\tmap{C_2}{\mathsf{p}}}\tinact\big)}}\mapt{S}^{\mathsf{p}}
\proves 
\bbout{k}{\abs{z}\binp{z}{x_1} \binp{z}{x_2} \map{Q}^{\mathsf{p}}} \map{P'}^{\mathsf{p}} \\
& \hby{\mapa{\ell_1}^{\mathsf{p}}} & 
\mapt{\Gamma}^{\mathsf{p}}; \mapt{\Delta_0} \cat
k:\mapt{S}^{\mathsf{p}}, \,
\proves 
\map{P'}^{\mathsf{p}} \\
 & = & 
 \mapt{\Gamma}^{\mathsf{p}}; 
 \mapt{\Delta_0 \cat k:S}^{\mathsf{p}}
\proves 
 \map{P'}^{\mathsf{p}}
\end{eqnarray*}
which concludes the proof for this case.
\end{enumerate}

\noi \textbf{Part (2)}. We consider some non-trivial cases, using biadic communication:
\begin{enumerate}[1.]

%% Biadic Input 
\item Case $P =  \binp{k}{x_1, x_2} P' $, 
$\map{P}^{\mathsf{p}} = 
		\binp{k}{x_1}  \binp{k}{x_2}  \map{P'}^{\mathsf{p}}$.
		We show that this case falls under part~(b) of the thesis (cf. Prop.~\ref{p:ocpotomo}). 		
%		and $\ell_2 = \bactinp{k}{k_1}, \bactinp{k}{k_2}$. Then w
		We have  the following typed transitions for $\map{P}^{\mathsf{p}}$, for some $S$, $S_1$, $S_2$, and $\Delta$:
\begin{eqnarray*}
& & \mapt{\Gamma}^{\mathsf{p}}; 
\mapt{\Delta}^{\mathsf{p}} \cat 
k:\btinp{\tmap{S_1}{\mathsf{p}}}\btinp{\tmap{S_2}{\mathsf{p}}}\tmap{S}{\mathsf{p}} \cat
\proves 
\binp{k}{x_1} \binp{k}{x_2}\map{P'}^{\mathsf{p}} \\
& \hby{\bactinp{k}{k_1}} & 
\mapt{\Gamma}^{\mathsf{p}}; 
\mapt{\Delta}^{\mathsf{p}} \cat 
k:\btinp{\tmap{S_2}{\mathsf{p}}}\tmap{S}{\mathsf{p}} \cat
k_1:\mapt{S_1}^{\mathsf{p}}
\proves 
\binp{k}{x_2}\map{P'}^{\mathsf{p}} \subst{k_1}{x_1} \\
& \hby{\bactinp{k}{k_2}} & 
\mapt{\Gamma}^{\mathsf{p}}; 
\mapt{\Delta}^{\mathsf{p}} \cat k:\tmap{S}{\mathsf{p}} \cat
k_1:  \mapt{S_1}^{\mathsf{p}} \cat
k_2: \mapt{S_2}^{\mathsf{p}}
\proves 
\map{P'}^{\mathsf{p}} \subst{k_1}{x_1}\subst{k_2}{x_2} = Q
\end{eqnarray*}
Observe that the substitution lemma (Lemma~\ref{lem:subst}(1)) has been used twice.
%Considering Remark~\ref{r:multilabels} 
It is then immediate to infer the label for the source transition:
$\ell_1 = \bactinp{k}{k_1,k_2}$. Indeed, $\mapa{\ell_1}^{\mathsf{p}} = \{\bactinp{k}{k_1}, \bactinp{k}{k_2}\}$.
Now, in the source term $P$ we can infer the following transition:
$$
\stytra{\Gamma}{\ell_1}{\Delta \cat k:\btinp{S_1, S_2}S}{\binp{k}{x_1, x_2} P' }{\Delta\cat k{:}S \cat k_1:S_1 \cat k_2:S_2}{P'\subst{k_1,k_2}{x_1, x_2}}
$$
We now observe that, by
letting
 $\Delta^* = \mapt{\Delta}^{\mathsf{p}}\cat k:\tmap{S}{\mathsf{p}}, \,
k_1:  \mapt{S_1}^{\mathsf{p}} \cat
k_2: \mapt{S_2}^{\mathsf{p}}$, we have the desired conclusion:
$$\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\Delta^*}{\map{P'\subst{k_1,k_2}{x_1, x_2}}^{\mathsf{p}}}{\Delta^*}{Q}$$

%% Biadic Abstraction Output 
\item Case $P =  \bbout{k}{\abs{x_1,x_2} Q} P' $, 
$\map{P}^{\mathsf{p}} = 
		\bbout{k}{\abs{z}\binp{z}{x_1}\binp{z}{x_2} \map{Q}^{\mathsf{p}}} \map{P'}^{\mathsf{p}}$.
		We show that this case falls under part~(a) of the thesis (cf. Prop.~\ref{p:ocpotomo}). 
		We have the following  typed transition, for some $S$, $C_1$, $C_2$, and $\Delta$:
\begin{eqnarray*}
& & \mapt{\Gamma}^{\mathsf{p}}; 
\mapt{\Delta}^{\mathsf{p}}\cat k:\tmap{\bbtout{\lhot{(C_1,  C_2)}} S}{\mathsf{p}}
\proves 
\bbout{k}{\abs{z}\binp{z}{x_1}\binp{z}{x_2} \map{Q}^{\mathsf{p}}} \map{P'}^{\mathsf{p}} \\
& \hby{\ell'_1} & 
\mapt{\Gamma}^{\mathsf{p}}; 
\mapt{\Delta}^{\mathsf{p}}\cat k:\tmap{ S}{\mathsf{p}} 
\proves 
\map{P'}^{\mathsf{p}} = Q
\end{eqnarray*}
where
$\ell'_1 = \bactout{k}{\abs{z}\binp{z}{x_1} \binp{z}{x_2} \map{Q}^{\mathsf{p}}}$.
For simplicity, we consider only the case of linear functions.
It is then immediate to infer the label for the source transition:
$\ell_1 = \bactout{k}{\abs{x_1,  x_2}{Q}} $. 
Now, in the source term $P$ we can infer the following transition:
$$
\stytra{\Gamma}{\ell_1}{\Delta\cat k:\bbtout{\lhot{(C_1,  C_2)}} S}{ \bbout{k}{\abs{x_1,x_2} Q} P'}{\Delta\cat k{:}S}{P'}
$$
Then we have the desired conclusion:
$$\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\mapt{\Delta\cat k:S}^{\mathsf{p}}}{\map{P'}^{\mathsf{p}}}{\mapt{\Delta\cat k:S}^{\mathsf{p}}}{Q}$$


%% Biadic Abstraction Input 
\item Case $P =  \binp{k}{X} P' $, 
$\map{P}^{\mathsf{p}} = 
		\binp{k}{X} \map{P'}^{\mathsf{p}}$.
		We show that this case also falls under part~(a) of the thesis (cf. Prop.~\ref{p:ocpotomo}). 
We have  the following typed transition, for some $S$, $C_1$, $C_2$, and $\Delta$:
\begin{eqnarray*}
& & \mapt{\Gamma}^{\mathsf{p}}; 
\mapt{\Delta}^{\mathsf{p}}\cat k:\tmap{\bbtinp{\shot{(C_1,  C_2)}} S}{\mathsf{p}}
\proves 
\binp{k}{X} \map{P'}^{\mathsf{p}} \\
& \hby{\ell'_1} & 
\mapt{\Gamma}^{\mathsf{p}}; 
\mapt{\Delta}^{\mathsf{p}}\cat k:\tmap{ S}{\mathsf{p}} 
\proves 
\map{P'}^{\mathsf{p}}\subst{\abs{z}\binp{z}{x_1} \binp{z}{x_2} \map{Q}^{\mathsf{p}}}{X} = Q
\end{eqnarray*}
where 
 $\ell'_1 = \bactinp{k}{\abs{z}\binp{z}{x_1} \binp{z}{x_2} \map{Q}^{\mathsf{p}}} $. 
For simplicity, we consider only the case of shared functions.
It is then immediate to infer the label for the source transition:
$\ell_1 = \bactinp{k}{\abs{x_1,  x_2}{Q}} $. 
Now, in the source term $P$ we can infer the following transition:
$$
\stytra{\Gamma}{\ell_1}{\Delta\cat k:\bbtinp{\shot{(C_1, C_2)}} S}{ \binp{k}{X} P'}{\Delta\cat k{:}S}{P'\subst{\abs{x_1,  x_2}{Q}}{X}}
$$
Then we have the desired conclusion:
$$\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\mapt{\Delta\cat k:S}^{\mathsf{p}}}{\map{P'\subst{\abs{x_1,  x_2}{Q}}{X}}^{\mathsf{p}}}{\mapt{\Delta\cat k:S}^{\mathsf{p}}}{Q}$$
We omit the (easy) conductive argument supporting the last claim,
which uses Prop.~\ref{p:poltomo}.
We content ourselves with noticing that the key difference between 
${\map{P'\subst{\abs{x_1,  x_2}{Q}}{X}}^{\mathsf{p}}}$
and $Q$ consists in the $\tau$-transitions present in $Q$  and absent in ${\map{P'\subst{\abs{x_1,  x_2}{Q}}{X}}^{\mathsf{p}}}$, which are induced   by the monadic representation of polyadic communication.
\end{enumerate}
\qed
\end{proof}

\begin{conjecture}[Full Abstraction: Polyadic / Monadic Communication]
\begin{enumerate}[a)]
\item
If
$\wbb{ \Gamma}{\ell}{\Delta_1}{ P }{ \Delta_2}{Q}$
then
$\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\mapt{\Delta_1}^{\mathsf{p}}}{\map{P}^{\mathsf{p}}}{\mapt{\Delta_2}^{\mathsf{p}}}
{\map{Q}^{\mathsf{p}}}$.
\item  
If 
$\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\mapt{\Delta_1}^{\mathsf{p}}}{\map{P}^{\mathsf{p}}}{\mapt{\Delta_2}^{\mathsf{p}}}
{\map{Q}^{\mathsf{p}}}$
then 
$\wbb{ \Gamma}{\ell}{\Delta_1}{ P }{ \Delta_2}{Q}$.
\end{enumerate}
While (a) is  completeness (non trivial), (b) is soundness  (easy in principle).
\end{conjecture}

In the light of the tight operational correspondence for the polyadic/monadic encoding,
in the following we restrict to consider monadic communications.

\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HOp ---> HO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Encoding \HOp into \HO}
\label{subsec:HOp_to_HO}

%\subsection{Encoding $\sessp^{-\mu}$  into \HO}\label{ss:ffotoho}

We show that the subcalculus $\HO$ is expressive enough to
represent the the full \HOp calculus.

The name passing semantics of \HOp have a rather straightforward
encoding from to $\HO$.
On the other hand the encoding of the primitive recursion semantics
of \HOp are more complex because they are based on the principle
of process copying.

To achieve process copying we use abstraction passing semantics, where
we copy a process upon reception. The case of linear abstraction passing
presents a limitation due to the fact that we cannot copy a linear abstraction.
To overcome this problem we define a preliminary tool which is a mapping from
processes to processes with no free names (but with free variables).
We first require an auxiliary definition.
%
\begin{definition}\rm 
	Let $\vmap{\cdot}: 2^{\mathcal{N}} \longrightarrow \mathcal{V}^\omega$
	be a map of sequences names to sequences of variables, defined
	inductively as follows:
%
\[
	\vmap{n} = x_n \qquad \qquad \qquad \vmap{n \cat \tilde{m}} = x_n \cat \vmap{\tilde{m}}
\]
\end{definition}

Given a process $P$, we write $\ofn{P}$ to denote the
\emph{sequence} of free names of $P$, lexicographically ordered.
Roughly, the following mapping transforms processes
with free names into abstractions:
%
\begin{definition}%\label{d:trabs}
	\label{def:auxmap}
	Let $\sigma$ be a set of session names.
	Define $\auxmap{\cdot}{\sigma}: \HOp \to \HOp$  as in Fig.~\ref{fig:auxmap}.
%
\begin{figure}[t]
\[
	\begin{array}{rcl}
		\auxmap{\news{n} P}{\sigma} &\bnfis& \news{n} \auxmap{P}{{\sigma \cat n}}
		\vspace{1mm} \\

		\auxmap{\bout{n}{\abs{x}{Q}} P}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\bout{x_n}{\abs{x}{\auxmap{Q}{\sigma}}} \auxmap{P}{\sigma} & n \notin \sigma\\
			\bout{n}{\abs{x}{\auxmap{Q}{\sigma}}} \auxmap{P}{\sigma} & n \in \sigma
		\end{array}
		\right.
		\vspace{1mm}	\\ 

		\auxmap{\binp{n}{X} P}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\binp{x_n}{X} \auxmap{P}{\sigma} & n \notin \sigma\\
			\binp{n}{X} \auxmap{P}{\sigma} & n \in \sigma
		\end{array}
		\right.

		\vspace{1mm}	\\ 
		\auxmap{\bsel{n}{l} P}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\bsel{x_n}{l} \auxmap{P}{\sigma} & n \notin \sigma\\
			\bsel{n}{l} \auxmap{P}{\sigma} & n \in \sigma
		\end{array}
		\right.
		\vspace{1mm} \\
		\auxmap{\bbra{n}{l_i:P_i}_{i \in I}}{\sigma} &\bnfis&

		\left\{
		\begin{array}{rl}
			\bbra{x_n}{l_i:\auxmap{P_i}{\sigma}}_{i \in I}  & n \notin \sigma\\
			\bbra{n}{l_i:\auxmap{P_i}{\sigma}}_{i \in I}  & n \in \sigma
		\end{array}
		\right.
		\vspace{1mm} \\
		\auxmap{\appl{x}{n}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\appl{x}{x_n} & n \notin \sigma\\
			\appl{x}{n} & n \in \sigma\\
		\end{array}
		\right.
		\vspace{1mm} \\

		\auxmap{\inact}{\sigma} &\bnfis& \inact
		\vspace{1mm} \\

		\auxmap{P \Par Q}{\sigma} &\bnfis& \auxmap{P}{\sigma} \Par \auxmap{Q}{\sigma}
	\end{array}
\]
\caption{\label{fig:auxmap} The auxiliary map (cf. Def.~\ref{def:auxmap}) 
used in the encoding of the recursive primitives of \HOp into \HO (Def.~\ref{def:enc:HOp_to_HO}).}
\end{figure}
\end{definition}

Given a process $P$ with $\fn{P} = m_1, \cdots, m_n$,
we are interested in its associated (polyadic) abstraction,
which is defined as $\abs{x_1, \cdots, x_n}{\auxmap{P}{\es} }$,
where $\vmap{m_j} = x_j$, for all $j \in \{1, \ldots, n\}$.
This transformation from processes into abstractions can be reverted by
using abstraction and application with an appropriate sequence of session names:
%
\begin{proposition}\rm
	Let $P$ be a \HOp process with $\tilde{n} = \ofn{P}$.
	Also, suppose $\tilde{x} = \vmap{\tilde{n}}$.
	Then $P \scong \appl{x}{\tilde{n}}\subst{\abs{\tilde{x}}\auxmap{P}{\emptyset}}{x}$.
\end{proposition}

\begin{proof}
	\noi The proof is an easy induction on the map $\auxmap{P}{\es}$.
	We show a case since other cases are similar.

	\noi - Case: $\auxmap{\bout{n}{m} P}{\es} = \bout{x_n}{x_m} \auxmap{P}{\es}$

	\noi We rewrite substitution as:
	$\appl{x}{\tilde{n}} \subst{\abs{\tilde{x}}{\bout{x_n}{y_m} \auxmap{P}{\es}}}{x} \scong (\bout{x_n}{y_m} P) \subst{\tilde{x}}{\tilde{n}}$

	\noi If consider that $x_n, y_m \in \vmap{\tilde{n}}$ then from the definition of $\vmap{\cdot}$ we
	get that $n, m \in \tilde{n}$. Furthermore by the fact that $\tilde{n}$ and $\vmap{\tilde{n}}$ are
	ordered, substitution becomes:
	$\bout{n}{m} \auxmap{P}{\es} \subst{\tilde{x}}{\tilde{n}}$.

	\noi The rest of the cases are similar.
	\qed
\end{proof}


We are now ready to define the encoding of \HOp
into strict process-passing. Note that we assume polyadicity 
in abstraction and application.
%For the sake of completeness, we give again the encodings for 
%finite processes and types, as
%formalized 
%in \S\,\ref{ss:ffotoho}.
%by $\encod{\cdot}{\cdot}{1}: \sessp^{-\mu} \to \HO$.
Given a session environment
$\Delta = \{n_1:S_1, \ldots, n_m:S_m\}$, 
in the following definition
we write
$\tilde{S}_{\Delta}$ to stand for $S_1, \ldots, S_m$.
\begin{definition}[\HOp into \HO]\rm
	\label{def:enc:HOp_to_HO}
	Let $f$ be a function from recursion variables to sequences of name variables.
	Define the typed encoding $\enco{\map{\cdot}^{1}_f, \mapt{\cdot}^{1}, \mapa{\cdot}^{1}}: \HOp \to \HO$,
	where mappings $\map{\cdot}^{1}$, $\mapt{\cdot}^{1}$, $\mapa{\cdot}^{1}$
	are as in Fig.~\ref{fig:enc:HOp_to_HO}.
    We assume that the mapping $\mapt{\cdot}^{1}$ on types is extended to 
    session environments $\Delta$
  and
    shared environments $\Gamma$ 
      as follows:
\[
	\begin{array}{rcll}
	    \mapt{\Delta \cat s: S}^{1} & =  & \mapt{\Delta}^{1} \cat s:\mapt{S}^{1} & \\
		\mapt{\Gamma \cat u: \chtype{S}}^{1} & =  & \mapt{\Gamma}^{1} \cat u:\chtype{\mapt{S}^{1}} & \\
		\mapt{\Gamma \cat u: \chtype{L}}^{1} & = &  \mapt{\Gamma}^{1} \cat u:\chtype{\dk{\mapt{L}^{1}}} & \\
		\tmap{\Gamma \cat \varp{X}:\Delta}{1} & = & \tmap{\Gamma}{1} \cat x:\shot{(\tilde{S}_{\Delta}\,,\,S^*)} & 
		\quad\text{(where $ 
%		S^* = \trec{t}{\big((\tilde{S}_{\Delta}\,,\, \btinp{\vart{t}}\tinact)\big)}
		S^* = \trec{t}{\btinp{\shot{(\tilde{S}_{\Delta}\,,\,\vart{t})}} \tinact}$)}
	\end{array}
\]
%\end{remark}

\end{definition}

\begin{figure}[h!]
\[
	\begin{array}{rcll}
			\pmapp{\bout{u}{v} P}{1}{f}	&\defeq&	\bout{u}{ \abs{z}{\,\binp{z}{x} \appl{x}{v}} } \pmapp{P}{1}{f}
		\\
		\pmapp{\binp{u}{x: C} Q}{1}{f}	&\defeq&	\binp{u}{x} \newsp{s}{\appl{x}{s} \Par \bout{\dual{s}}{\abs{x}{\pmapp{Q}{1}{f}}} \inact}
		\\
				\pmapp{\bout{u}{\abs{x}{Q}} P}{1}{f} &\defeq& \bout{u}{\abs{x}{\pmapp{Q}{1}{f}}} \pmapp{P}{1}{f}
		\\
		\pmapp{\binp{u}{x: L} P}{1}{f}	&\defeq&	\binp{u}{x: L} \pmapp{P}{1}{f}
		\\
		\pmapp{\recp{X}{P}}{1}{f} &\defeq&
		\newsp{s}{\binp{s}{x} \pmapp{P}{1}{{f,\{\varp{X}\to \tilde{n}\}}} \Par
		\bout{\dual{s}}{\abs{\vmap{\tilde{n}}, z } \,{\binp{z}{x} \auxmap{\pmapp{P}{1}{{f,\{\varp{X}\to \tilde{n}\}}}}{\es}}} \inact} &
		\quad \tilde{n} = \ofn{P}
		\\
		\pmapp{\varp{X}}{1}{f} &\defeq& \newsp{s}{\appl{x}{\tilde{n}, s} \Par \bbout{\dual{s}}{ \abs{\vmap{\tilde{n}},z}\,\,{\appl{x}{ \vmap{\tilde{n}}, z}}} \inact} &
		\quad \tilde{n} = f(\varp{X})
		\\
		\pmapp{\bsel{s}{l} P}{1}{f}	&\defeq&	\bsel{s}{l} \pmapp{P}{1}{f}
		\\
		\pmapp{\bbra{s}{l_i: P_i}_{i \in I}}{1}{f} &\defeq& \bbra{s}{l_i: \pmapp{P_i}{1}{f}}_{i \in I}
		\\
		\pmapp{\appl{x}{u}}{1}{f}	&\defeq&	\appl{x}{u}
		\\
		\pmapp{P \Par Q}{1}{f}		&\defeq&	\pmapp{P}{1}{f} \Par \pmapp{Q}{1}{f}
		\\
		\pmapp{\news{n} P}{1}{f}	&\defeq&	\news{n} \pmapp{P}{1}{f}
		\\
		\pmapp{\inact}{1}{f}		&\defeq&	\inact
	\end{array}
\]
%
\[
	\begin{array}{c}
		\begin{array}{rcl}
			\tmap{\btout{S_1} S}{1}	&\defeq&	\bbtout{\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}} \tmap{S}{1}
			\\
			\tmap{\btinp{S_1} S}{1}	&\defeq&	\bbtinp{\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}} \tmap{S}{1}
			\\
			\tmap{\bbtout{\chtype{S_1}} S}{1}	&\defeq&	\bbtout{\shot{\btinp{\shot{\chtype{\tmap{S_1}{1}}}}\tinact}} \tmap{S}{1}
			\\
			\tmap{\bbtinp{\chtype{S_1}} S}{1}	&\defeq&	\bbtinp{\shot{\btinp{\shot{\chtype{\tmap{S_1}{1}}}}\tinact}} \tmap{S}{1}
			\\

			\tmap{\bbtout{\chtype{L}} S}{1}		&\defeq&	\bbtout{\shot{\btinp{\shot{\chtype{\dk{\tmap{L}{1}}}}}\tinact}} \tmap{S}{1}
			\\
			\tmap{\bbtinp{\chtype{L}} S}{1}		&\defeq&	\bbtinp{\shot{\btinp{\shot{\chtype{\dk{\tmap{L}{1}}}}}\tinact}} \tmap{S}{1}
			\\

			\tmap{\btout{L} S}{1} &\defeq& \btout{L} \tmap{S}{1}
			\\
			\tmap{\btinp{L} S}{1} &\defeq& \btinp{L} \tmap{S}{1}
			\\
			\tmap{\btsel{l_i: S_i}_{i \in I}}{1} &\defeq& \btsel{l_i: \tmap{S_i}{1}}_{i \in I}
			\\
			\tmap{\btbra{l_i: S_i}_{i \in I}}{1} &\defeq& \btbra{l_i: \tmap{S_i}{1}}_{i \in I}
			\\

			\tmap{\vart{t}}{1} &\defeq& {t}
			\\
			\tmap{\trec{t}{S}}{1} &\defeq& \trec{t}{\tmap{S}{1}}
			\\
			\tmap{\tinact}{1} &\defeq& \tinact
		\end{array}
		\qquad
		\begin{array}{rcl}
			\mapa{\bactout{n}{m}}^{1} &\defeq&   \bactout{n}{\abs{z}{\,\binp{z}{x} \appl{x}{m}} }
			\\
			\mapa{\bactinp{n}{m}}^{1} &\defeq&   \bactinp{n}{\abs{z}{\,\binp{z}{x} \appl{x}{m}} }
			\\

			\mapa{\bactout{n}{\abs{x}{P}}}^{1} &\defeq& \bactout{n}{\abs{x}{\pmapp{P}{1}{\es}}}
			\\
			\mapa{\bactinp{n}{\abs{x}{P}}}^{1} &\defeq& \bactinp{n}{\abs{x}{\pmapp{P}{1}{\es}}}
			\\
			\mapa{\tau}^{1} &\defeq& \tau
			\\
			\mapa{\bactsel{s}{l} }^{1} &\defeq& \bactsel{n}{l} 
			\\
			\mapa{\bactbra{s}{l} }^{1} &\defeq& \bactbra{n}{l} 
		\end{array}
	\end{array}
\]
	\caption{
		\label{fig:enc:HOp_to_HO}
		Typed encoding of \HOp into \HO (cf.~Defintion~\ref{def:enc:HOp_to_HO}).
%		Mappings 
%		$\map{\cdot}^2$,
%		$\mapt{\cdot}^2$, 
%		and 
%		$\mapa{\cdot}^2$
%		are homomorphisms for the other processes/types/labels. 
	}
\end{figure}



In the higher-order setting, a name $v$ is being passed as an input
guarded abstraction. The input prefix receives an abstraction and
continues with the application of $v$ over the received abstraction.
On the receiver side $\binp{u}{x} P$ 
the encoding realizes a mechanism that (i) receives
the input guarded abstraction, then (ii) applies it on a fresh session endpoint $s$, 
and (iii) uses
the dual endpoint $\dual{s}$ to send the continuation $P$ as the abstraction
$\abs{x}{P}$. 
As a result, name substitution is achieved via name application.


\begin{proposition}[Type Preservation, \HOp into \HO]
	\label{prop:typepres_HOp_to_HO}
	Let $P$ be a \HOp process.
	If $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then 
	$\mapt{\Gamma}^{1}; \emptyset; \mapt{\Delta}^{1} \proves \pmapp{P}{1}{f} \hastype \Proc$. 
\end{proposition}

\begin{proof}
	By induction on the inference $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$.
	Details in \S\,\ref{app:enc_HOp_to_HO} (Page~\pageref{app:enc_HOp_to_HO}).
	\qed
%	By induction on the inference $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$. 
%	Details in Appendix~\ref{app:enc_HOp_to_HO}.
%	\qed
\end{proof}

%\begin{proposition}[Type Preservation, Full First-Order into Higher-Order]\label{prop:typepres2}
%Let $P$ be a  $\sessp$ process.
%If			$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then 
%			$\mapt{\Gamma}^{2}; \emptyset; \mapt{\Delta}^{2} \proves \map{P}_f^{2} \hastype \Proc$. 
%\end{proposition}

%\begin{proof}
%By induction on the inference $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$. 
%Details in Appendix~\ref{app:enc_sesp_to_HO}.
%	\qed
%\end{proof}

The following proposition formalizes our strategy  for encoding
recursive definitions as passing of polyadic abstractions:
%
\begin{proposition}[Operational Correspondence for Recursive Processes]\rm
	\label{prop:op_corr_HOprec_to_HO}
	Let $P$ and $P_1$ be \HOp processes s.t. 
	$P =\recp{X}{P'}$ and
	$P_1 = P'\subst{\recp{X}{P'}}{\varp{X}} \scong P$.

	\noi If %$P_1 \hby{\ell} P_2$ 
	$\stytra{\Gamma}{\ell}{\Delta}{P}{\Delta'}{P'}$
	then,  there exist
	processes $R_1$, $R_2$,  $R_3$, action $\ell'$,
	and mappings $f, f_1$, such that: 
	\begin{enumerate}[(i)]
	\item 
	%$\pmapp{P}{1}{f} \hby{\tau} \map{P'}^{1}_{f_{1}} \subst{R_3}{X} = R_1$;
	$\stytra{\mapt{\Gamma}^{1}}{\tau}{\mapt{\Delta}^{1}}{P}{\mapt{\Delta}^{1}}{\map{P'}^{1}\subst{R_3}{X}} = R_1$;
	\item 
	%$R_1 \Hby{\ell'} R_2$, with $\ell' = \mapa{\ell}^{1}$;
	$\wtytra{\mapt{\Gamma}^{1}}{\ell'}{\mapt{\Delta}^{1}}{R_1}{\mapt{\Delta}^{1}}{R_2} $,  with $\ell' = \mapa{\ell}^{1}$;
	
	\item $R_3 = \abs{\tilde{m}}\binp{z}{X}\auxmap{\map{P'}^{1}_{f_{1}}}{\sigma}$, with $\tilde{m} = \ofn{P'},z$)
	and
	$f_1 = f, \{\rvar{X} \to \ofn{P'}\}$.
	\end{enumerate}
\end{proposition}

\begin{proof}[Sketch]
	Part~(1) follow directly from the definition of typed encoding for processes $\pmapp{\cdot}{1}{f}$ (Definition~\ref{def:enc:HOp_to_HO}),
	observing that the reduction occurs along a restricted name, and so the session environment remains unchanged.
	Part~(2) relies on  Prop.~\ref{prop:op_corr_HOp_to_HO}.
	Part~(3) is immediate from Definition~\ref{def:enc:HOp_to_HO}.
	\qed
\end{proof}

%\begin{proposition}[Operational Correspondence, Full First-Order into Higher-Order]
%\label{p:auxfullfho}
%Let $P$ be a  $\sessp$ process.
%If $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then
%		\begin{enumerate}[a)]
%			\item	 
%			   If  $\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$
%			   then  $\exists \ell_2$ s.t. \\
%			    $\wtytra{\mapt{\Gamma}^{2}}{\ell_2}{\mapt{\Delta}^{2}}{\map{P}_f^{2}}{\mapt{\Delta'}^{2}}{\map{P'}_f^{2}}$
%			    and $\ell_2 = \mapa{\ell_1}^{2}$.
%			\item   
%			If  $\wtytra{\mapt{\Gamma}^{2}}{\ell_2}{\mapt{\Delta}^{2}}{\map{P}^{2}_f}{\mapt{\Delta'}^{2}}{Q}$
%			   then $\exists \ell_1, P'$ s.t.  \\
%			    (i)~$\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$,
%			    (ii)~$\ell_2 = \mapa{\ell_1}^{2}$, 
%			    (iii)~$\wbb{\mapt{\Gamma}^{2}}{\ell}{\mapt{\Delta'}^{2}}{\map{P'}_f^{2}}{\mapt{\Delta'}^{2}}{Q}$.
%			    \end{enumerate}
%\end{proposition}

The following proposition formalizes completeness and soundness results for the encoding of 
\HOp into \HO.
We write $\by{\tau}_k$ to denote a sequence of $k$ $\tau$-transitions.

\begin{proposition}[Operational Correspondence, \HOp into \HO]\rm
	\label{prop:op_corr_HOp_to_HO}
	Let $P$ be a \HOp process.
	If $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then
	\begin{enumerate}[1.]
		\item
			Suppose $\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$. Then we have:
			\begin{enumerate}[a)]
		    \item 
			If $\ell_1 \in \{\bactout{n}{m}, \,\bactout{n}{\abs{x}Q}, \,\bactsel{s}{l}, \,\bactbra{s}{l}   \}$
			then $\exists \ell_2$ s.t. \\
			$\stytra{\mapt{\Gamma}^{1}}{\ell_2}{\mapt{\Delta}^{1}}{\pmapp{P}{1}{f}}{\mapt{\Delta'}^{1}}{\pmapp{P'}{1}{f}}$
			and $\ell_2 = \mapa{\ell_1}^{1}$.
			
			\item If $\ell_1 = \bactinp{n}{\abs{y}Q}$ and
			$P' = P_0\subst{\abs{y}Q}{x}$ and			
			then $\exists \ell_2$ s.t. \\
			$\stytra{\mapt{\Gamma}^{1}}{\ell_2}{\mapt{\Delta}^{1}}{\pmapp{P}{1}{f}}{\mapt{\Delta'}^{1}}{\pmapp{P_0}{1}{f}\subst{\abs{y}\pmapp{Q}{1}{\emptyset}}{x}}$
			and $\ell_2 = \mapa{\ell_1}^{1}$.
			
			\item If $\ell_1 = \bactinp{n}{m}$
			and 
			$P' = P_0\subst{m}{x}$
			then $\exists \ell_2$, $R$ s.t. \\
			$\stytra{\mapt{\Gamma}^{1}}{\ell_2}{\mapt{\Delta}^{1}}{\pmapp{P}{1}{f}}{\mapt{\Delta'}^{1}}{R}$,
			with $\ell_2 = \mapa{\ell_1}^{1}$, \\
			and
			%$\wtytra{\mapt{\Gamma}^{1}}{}{\mapt{\Delta'}^{1}}{R}{\mapt{\Delta'}^{1}}{\pmapp{P_0}{1}{f}\subst{m}{x}}$. \\	
			$\mapt{\Gamma}^{1}; \mapt{\Delta'}^{1} \proves R \hby{\tau}_3
				\mapt{\Gamma}^{1}; \mapt{\Delta'}^{1} \proves \pmapp{P_0}{1}{f}\subst{m}{x}$.
						
			\item If $\ell_1 = \tau$
			and $P' \scong P_1 \Par P_2\subst{m}{x}$
			then $\exists R$ s.t. \\
			$\stytra{\mapt{\Gamma}^{1}}{\tau}{\mapt{\Delta}^{1}}{\pmapp{P}{1}{f}}{\mapt{\Delta}^{1}}{\pmapp{P_1}{1}{f}
			\Par R
			}$, where $R \by{\tau}_3  \pmapp{P_2}{1}{f}\subst{m}{x}$.

			
			
			
			\item If $\ell_1 = \tau$
			and $P' \scong P_1 \Par P_2\subst{\abs{y}Q}{x}$
			then \\
			$\stytra{\mapt{\Gamma}^{1}}{\tau}{\mapt{\Delta}^{1}}{\pmapp{P}{1}{f}}{\mapt{\Delta_1}^{1}}{\pmapp{P_1}{1}{f}
			\Par \pmapp{P_2}{1}{f}\subst{\abs{y}\pmapp{Q}{1}{\emptyset}}{x}
			}$.
			
			\item If $\ell_1 = \tau$
			and $P' \not\scong P_1 \Par P_2\subst{m}{x} \land P' \not\scong P_1 \Par P_2\subst{\abs{y}Q}{x}$
			then \\
			$\stytra{\mapt{\Gamma}^{1}}{\tau}{\mapt{\Delta}^{1}}{\pmapp{P}{1}{f}}{\mapt{\Delta'_1}^{1}}{ \pmapp{P'}{1}{f}
			}$.
			\end{enumerate}
			
		\item Suppose $\stytra{\mapt{\Gamma}^{1}}{\ell_2}{\mapt{\Delta}^{1}}{\pmapp{P}{1}{f}}{\mapt{\Delta'}^{1}}{Q}$.
		Then we have:
			\begin{enumerate}[a)]
		    \item 
		    If $\ell_2 \in \{\bactout{n}{\abs{z}{\,\binp{z}{x} \appl{x}{m}}}, \,\bactout{n}{\abs{x}R}, \,\bactsel{s}{l}, \,\bactbra{s}{l}   \}$
			then $\exists \ell_1, P'$ s.t. \\
			$\stytra{ \Gamma }{\ell_1}{ \Delta }{ P}{ \Delta' }{ P'}$, 
			$\ell_1 = \mapa{\ell_2}^{1}$, 
			and
			$\map{P'}^{1}_f = Q$.
			
			\item 
		    If $\ell_2 = \bactinp{n}{\abs{y}R}$ (with $R \neq \binp{y}{x} \appl{x}{m}$)
			then $\exists \ell_1, x, P', P''$ s.t. \\
			$\stytra{ \Gamma }{\ell_1}{ \Delta }{ P}{ \Delta' }{ P'\subst{\abs{y}P''}{x}}$, 
			$\ell_1 = \mapa{\ell_2}^{1}$, 
						$\map{P''}^{1}_\es = R$, and 			$\map{P'}^{1}_f = Q$.		
						
			\item 
		    If $\ell_2 = \bactinp{n}{\abs{y}\binp{y}{x} \appl{x}{m}}$ 
			then $\exists \ell_1, z, P'$ s.t. \\
			$\stytra{ \Gamma }{\ell_1}{ \Delta }{ P}{ \Delta' }{ P'\subst{m}{z}}$, 
			$\ell_1 = \mapa{\ell_2}^{1}$,
			and 
			$Q \by{\tau}_3  \map{P'\subst{m}{z}}^{1}_f$.	
		
			%$\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta'}^{1}}{\map{P'}^{1}}{\wbf}{\mapt{\Delta'}^{1}}{Q}$.
			
			\item 
		    If $\ell_2 = \tau$ 
			then $\Delta' = \Delta$ and 
			either
			\begin{enumerate}[-]
			\item $\exists P'$ s.t. 
			$\stytra{ \Gamma }{\tau}{ \Delta }{ P}{ \Delta}{ P'}$, and $Q = \map{P'}^{1}_f$.	

			\item $\exists P_1, P_2, x, m, Q'$ s.t. 
			$\stytra{ \Gamma }{\tau}{ \Delta }{ P}{ \Delta}{ P_1 \Par P_2\subst{m}{x} }$, and 
			$Q = \map{P_1}^{1}_f \Par Q'$, where $Q'  \Hby{} \map{P_2\subst{m}{x}}^{1}_f$.

			\item $\exists P_1, P_2, x, R$ s.t. 
			$\stytra{ \Gamma }{\tau}{ \Delta }{ P}{ \Delta}{ P_1 \Par P_2\subst{\abs{y}R}{x} }$, and 
			$Q = \map{P_1 \Par P_2\subst{\abs{y}R}{x}}^{1}_f$.

			\end{enumerate}
		    \end{enumerate}
		    
%		\item   
%			If  $\wtytra{\mapt{\Gamma}^{1}}{\ell_2}{\mapt{\Delta}^{1}}{\pmapp{P}{1}{f}}{\mapt{\Delta'}^{1}}{Q}$
%			then $\exists \ell_1, P'$ s.t.  \\
%			(i)~$\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$,
%			(ii)~$\ell_2 = \mapa{\ell_1}^{1}$, 
%			(iii)~$\wbb{\mapt{\Gamma}^{1}}{\ell}{\mapt{\Delta'}^{1}}{\pmapp{P'}{1}{f}}{\mapt{\Delta'}^{1}}{Q}$.
	\end{enumerate}
\end{proposition}

\begin{proof}

By transition induction. We consider parts (1) and (2) separately:

\noi \textbf{Part (1) - Completeness}. We consider two representative cases, the rest is similar or simpler:
%
\begin{enumerate}[1.]
	%%  Output 
	\item	Subcase  (a): $P =\bout{s}{n} P'$ and $\ell_1 = \bactout{s}{n}$. By assumption, $P$ is well-typed. 
		We may have:
%
		\[
			\tree{
				\Gamma; \emptyset; \Delta_0 \cat s:S_1  \proves  P' \hastype \Proc \quad 
				\Gamma ; \emptyset ; \{n{:} S\}  \proves   n \hastype S }{
				\Gamma; \emptyset; \Delta_0 \cat n{:}S \cat s:\btout{S}S_1 \proves \bout{s}{n} P' \hastype \Proc}
		\]
%
		\noi for some $S, S_1, \Delta_0$.
		%such that $\Delta = \Delta_0 \cat k_1{:}T  \cat k:\btout{T}S$.
		We may then have the following transition:
%
		\[
			\stytra{\Gamma}{\ell_1}{\Delta_0 \cat n{:}S \cat s:\btout{S}S_1 }{\bout{s}{n} P'}{\Delta_0 \cat s{:}S_1 }{P'}
		\]
%
		\noi The encoding of the source judgment for $P$ is as follows:
%
		\[
			\mapt{\Gamma}^{1}; \emptyset; \mapt{\Delta_0 \cat n{:}S \cat s:\btout{S}S_1}^{1} \proves \map{\bout{s}{n} P'}^{1} \hastype \Proc
		\]
%
		\noi which, using Def.~\ref{def:enc:HOp_to_HO} can be expressed as 
%
		\[
			\mapt{\Gamma}^{\mathsf{p}}; \emptyset; \mapt{\Delta_0} 
			\cat n{:}\mapt{S}^{1} 
			\cat s: \btout{\lhot{\btinp{\lhot{\tmap{S}{1}}}\tinact}} \tmap{S_1}{1}
			\proves 
			\bbout{s}{ \abs{z}{\,\binp{z}{x} \appl{x}{n}} } \pmap{P'}{1}
			\hastype \Proc
		\]
%
		\noi Now, $\mapa{\ell_1}^{1} = \bactout{s}{\abs{z}{\,\binp{z}{x} \appl{x}{n}}\, } $. 
		We may infer the following  transition for $\map{P}^{1}$:
%
		\begin{eqnarray*}
			& & \mapt{\Gamma}^{1}; \emptyset; \mapt{\Delta}^{1} 
			\proves 
			\bbout{s}{ \abs{z}{\,\binp{z}{x} \appl{x}{n}} } \pmap{P'}{1}
			\hastype \Proc \\
			& \hby{\mapa{\ell_1}^{1}} & \mapt{\Gamma}^{1}; \emptyset; \mapt{\Delta_0}^{1} 
			\cat s:  \tmap{S_1}{1}
			\proves  \pmap{P'}{1}
			\hastype \Proc \\
			& = & \mapt{\Gamma}^{1}; \emptyset; \mapt{\Delta_0 \cat s:  S_1}^{1}
			\proves  \pmap{P'}{1}
			\hastype \Proc 
		\end{eqnarray*}
%
		\noi from which the thesis follows easily.

	\item	Subcase (c): $P = \binp{n}{x} P'$	and $\ell_1 = \bactinp{n}{m}$.
		By assumption $P$ is well-typed.
		We may have:
%
		\[
			\tree{
				\Gamma; \emptyset; \Delta_0 \cat x:S \cat n:S_1  \proves  P' \hastype \Proc \quad 
				\Gamma ; \emptyset ; \{x: S\}  \proves   x\hastype S}{
				\Gamma; \emptyset; \Delta_0 \cat   n:\btinp{S}S_1 \proves \binp{n}{x} P' \hastype \Proc}
		\]
%
		for some  $S, S_1, \Delta_0$.
%		such that $\Delta = \Delta_0 \cat k:\btinp{T}S$.
		We may infer the following typed transition:
%
		\[
			\Gamma; \emptyset; \Delta_0 \cat   n:\btinp{S}S_1 \proves \binp{n}{x} P' \hastype \Proc
			\hby{\bactinp{n}{m}}
			\Gamma; \emptyset; \Delta_0 \cat  n:S_1 \cat m:S \proves   P'\subst{m}{x} \hastype \Proc
		\]
%
		The encoding of the source judgment for $P$ is as follows:
%
		\begin{eqnarray*}
			& & \mapt{\Gamma}^{1}; \emptyset; \mapt{ \Delta_0 \cat   n:\btinp{S}S_1 }^{1} \proves 
			\map{P}^{1}
			\hastype \Proc \\
			& = & \mapt{\Gamma}^{1}; \emptyset; \mapt{ \Delta_0 }^{1} \cat   n: \btinp{\lhot{\btinp{\lhot{\tmap{S}{1}}}\tinact}} \tmap{S_1}{1} \proves 
			\binp{n}{x} \newsp{s}{\appl{x}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{P'}{1}}} \inact}
			\hastype \Proc
		\end{eqnarray*}
%
		Now, 
		$\mapa{\ell_1}^{1} = \bactinp{n}{\abs{z}{\,\binp{z}{x} \appl{x}{m}}\, }$
		and it is immediate to infer the following 
		transition for $\map{P}^{1}$:
%
		\begin{eqnarray*}
			&  & \mapt{\Gamma}^{1}; \emptyset; \mapt{ \Delta_0 }^{1} \cat   
			n: \btinp{\lhot{\btinp{\lhot{\tmap{S}{1}}}\tinact}} \tmap{S_1}{1} \proves 
			\binp{n}{x} \newsp{s}{\appl{x}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{P'}{1}}} \inact}
			\hastype \Proc \\
			& \hby{\mapa{\ell_1}^{1}}  & \mapt{\Gamma}^{1}; \emptyset; \mapt{ \Delta_0 }^{1} \cat   
			n:  \tmap{S_1}{1} \cat m:  \tmap{S}{1} \proves 
			 \newsp{s}{\appl{x}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{P'}{1}}} \inact}\subst{\abs{z}{\,\binp{z}{x} \appl{x}{m}}}{x}
			\hastype \Proc 
		\end{eqnarray*}
%
		Let us write $R$ to stand for process 
		$\newsp{s}{\appl{x}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{P'}{1}}} \inact}\subst{\abs{z}{\,\binp{z}{x} \appl{x}{m}}}{x}$. 
		%$\newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{Q}{1}}} \inact}\subst{\abs{z}{\,\binp{z}{X} \appl{X}{k_1}}}{X}$.
		We then have:
		\begin{eqnarray*}
		R & \by{\tau} & \newsp{s}{\binp{s}{x} \appl{x}{m} \Par \bbout{\dual{s}}{\abs{x}{\pmap{P'}{1}}} \inact} \\
		& \by{\tau} &  \appl{(\abs{x}{\pmap{P'}{1}})}{m} \Par \inact \\
		& \by{\tau} & \pmap{P'}{1}\subst{m}{x}
		\end{eqnarray*}
		and so the thesis follows.

		%%%%%%%%%%%
		%%  Recursion
		%%%%%%%%%%%

%	\item	Case $P =\recp{X}{P'}$ and $P = \rvar{X}$.
%
%		It follows similar arguments with the previous cases
%		and uses Prop.~\ref{prop:op_corr_HOprec_to_HO} whenever necessary.
		
\end{enumerate}
%
\noi \textbf{Part (2) - Soundness}. We consider two representative cases, the rest is similar or simpler:
%
\begin{enumerate}[1.]
		%%%%%%%%%%%
		%%  Output 
		%%%%%%%%%%%
	\item Subcase (a): $P = \bout{n}{m} P'$ and $\ell_2 = \bactout{n}{\abs{z}{\,\binp{z}{x} \appl{x}{m}}}$.
		%,  $\map{P}^{1} = \bbout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{k'}} } \pmap{P'}{1}$.
		Then 
		we have: % the following typed transition for $\map{P}^{1}$:
%
		\[
			\mapt{\Gamma}^{1};\, \emptyset;\, \mapt{\Delta_0}^{1} \cat 
			n: \btout{\lhot{\btinp{\lhot{\tmap{S}{1}}}\tinact}} \tmap{S_1}{1} 
			\proves 
			 \bbout{n}{ \abs{z}{\,\binp{z}{x} \appl{x}{m}} } \pmap{P'}{1} 
			 \hastype \Proc
		\]
%
		for some $S, S_1$, and $\Delta_0$. 
		We may infer the following typed transition for $\pmap{P}{1}$:
%
		\begin{eqnarray*}
			& & \mapt{\Gamma}^{1};\, \mapt{\Delta_0}^{1} \cat n: \btout{\lhot{\btinp{\lhot{\tmap{S}{1}}}\tinact}} \tmap{S_1}{1} 
			\proves 
			 \bbout{n}{ \abs{z}{\,\binp{z}{x} \appl{x}{m}} } \pmap{P'}{1} 
			 \\
			%& & \bbout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{k'}} } \pmap{P'}{1} \hby{\bactout{k}{\abs{z}{\,\binp{z}{X} \appl{X}{k'}}}} \pmap{P'}{1}  \\
			&\hby{\ell_2}& 
			\mapt{\Gamma}^{1};\, \mapt{\Delta_0}^{1} \cat n: \tmap{S_1}{1} 
			\proves  \pmap{P'}{1} 
		\end{eqnarray*}
%
		%with $\ell_2 = \bactout{k}{\abs{z}{\,\binp{z}{X} \appl{X}{k'}}}$.
		Now, in the source term $P$ we can infer the following transition 
%
		\[
		\Gamma;\,  \Delta_0 \cat n:\btout{S} S_1 \proves \bout{n}{m} P'
		 \hby{\bactout{n}{m}} 
		 \Gamma;\,  \Delta_0 \cat n: S_1 \proves P'
		\]
%
		and thus the thesis follows easily by noticing that 
		$\mapa{\bactout{n}{m}}^{1} = \bactout{n}{\abs{z}{\,\binp{z}{x} \appl{x}{m}}}$.


		%%%%%%%%%%%
		%% Input
		%%%%%%%%%%%
	\item	Subcase (c): $P = \binp{n}{x} P'$ and $\ell_2 = \bactinp{n}{\abs{y}\binp{y}{x} \appl{x}{m}}$.
		Then we have
%
		\[
			\mapt{\Gamma}^{1};\, \emptyset;\, \mapt{\Delta_0}^{1} \cat 
			n: \btinp{\lhot{\btinp{\lhot{\tmap{S}{1}}}\tinact}} \tmap{S_1}{1}
			\proves
			\binp{n}{x} \newsp{s}{\appl{x}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{P'}{1}}} \inact}
			\hastype \Proc
		\]
%
		for some $S$, $S_1$, $\Delta_0$.
		We may infer the following typed transitions for $\pmap{P}{1}$:
%
		\begin{eqnarray*}
			& & 
			\mapt{\Gamma}^{1};\, %\emptyset;\, 
			\mapt{\Delta_0}^{1} \cat 
			n: \btinp{\lhot{\btinp{\lhot{\tmap{S}{1}}}\tinact}} \tmap{S_1}{1}
			\proves
			\binp{n}{x} \newsp{s}{\appl{x}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{P'}{1}}} \inact} \\
			& \hby{\ell_2} & 
			\mapt{\Gamma}^{1};\, %\emptyset;\, 
			\mapt{\Delta_0}^{1} \cat 
			n:\tmap{S_1}{1}
			\cat m:\tmap{S_1}{1}
			\proves
			\newsp{s}{\appl{x}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{P'}{1}}} \inact} \subst{\abs{z}\binp{z}{x}\appl{x}{m}}{x} \\
			& = & 
			\mapt{\Gamma}^{1};\, %\emptyset;\, 
			\mapt{\Delta_0}^{1} 
			\cat n:\tmap{S_1}{1}
			\cat m:\tmap{S}{1}
			\proves
			\newsp{s}{\binp{s}{x}\appl{x}{m} \Par \bbout{\dual{s}}{\abs{x}{\pmap{P'}{1}}} \inact}  \\
			& \hby{\tau} & 
			\mapt{\Gamma}^{1};\, %\emptyset;\, 
			\mapt{\Delta_0}^{1} 
			\cat n:\tmap{S_1}{1}
			\cat m:\tmap{S}{1}
			\proves
			\appl{(\abs{x}{\pmap{P'}{1}})}{m}   \\
			& \hby{\tau} & 
			\mapt{\Gamma}^{1};\, %\emptyset;\, 
			\mapt{\Delta_0}^{1} 
			\cat n:\tmap{S_1}{1}
			\cat m:\tmap{S}{1}
			\proves
			\pmap{P'}{1}\subst{m}{x}   
		\end{eqnarray*}
%
		%with $\ell_2 = \bactinp{k}{\abs{z}{\,\binp{z}{X} \appl{X}{k_1}}}$.
		Now, in the source term $P$ we can infer the following transition 
%
		\[
			\Gamma;\,  \Delta_0 \cat n:\btinp{S} S_1 \proves \binp{n}{x} P'
			\hby{\bactinp{n}{m}} 
			\Gamma;\,  \Delta_0 \cat n: S_1 \cat m: S \proves P'\subst{m}{x}
		\]
%
		and the thesis follows.
%		 easily by noticing that $\mapa{\bactinp{k}{k_1}}^{1} = \bactinp{k}{\abs{z}{\,\binp{z}{X} \appl{X}{k_1}}}$.

		%%%%%%%%%%%
		%%  Recursion
		%%%%%%%%%%%
%	\item	Case $P =\recp{X}{P'}$ and $P = \rvar{X}$.
%
%		It follows similar arguments with the previous case
%		and uses Prop.~\ref{prop:op_corr_HOprec_to_HO} whenever nescessary.
\end{enumerate}
\qed
\end{proof}


\begin{proposition}[Full Abstraction, \HOp into \HO]\rm
	$\horel{\Gamma}{\Delta_1}{P_1}{\wb}{\Delta_2}{Q_1}$
	if and only if
	$\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_1}^{1}}{\pmapp{P_1}{1}{f}}{\wb}{\mapt{\Delta_2}^{1}}{\pmapp{Q_2}{1}{f}}$.
\end{proposition}

\begin{proof}
	\noi {\bf Proof of Soundness Direction.}

	\noi Let
%
	\[
		\Re = \set{\horel{\Gamma}{\Delta_1}{P_1}{\wb}{\Delta_2}{Q_1} \setbar \horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_1}^{1}}{\pmapp{P_1}{1}{f}}{\wb}{\mapt{\Delta_2}^{1}}{\pmapp{Q_1}{1}{f}}}
	\]
%
	\noi	The proof considers a case analysis on the transition $\hby{\ell}$ and
		uses the soundness direction of operational correspondence (cf.~Proposition~\ref{prop:op_corr_HOp_to_HO}).
		We give an interesting case. The others are similar of easier.

	\noi	- Case: $\ell = \news{\tilde{m_1}'} \bactout{n}{m_1}$.

	\noi Proposition~\ref{prop:op_corr_HOp_to_HO} implies that
%
	\[
		\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}'} \bactout{n}{m_1}}}{\Delta_1'}{P_2}
	\]
%
	\noi implies
%
	\[
		\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_1}^{1}}{\pmapp{P_1}{1}{f}}{\hby{\news{\tilde{m_1}'} \bactout{n}{\abs{z}{\binp{z}{x} \appl{x}{m_1}}}}}{\mapt{\Delta_1'}^{1}}{\pmapp{P_2}{1}{f}}
	\]
%
	\noi that in combination with the definition of $\Re$ we get
%
	\begin{eqnarray}
		\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_2}^{1}}{\pmapp{Q_1}{1}{f}}{\Hby{\news{\tilde{m_2}'} \bactout{n}{\abs{z}{\binp{z}{x} \appl{x}{m_2}}}}}{\mapt{\Delta_2'}^{1}}{\pmapp{Q_2}{1}{f}}
		\label{prop:HOp_to_HO:full_abs11}
	\end{eqnarray}
%
	\noi and
%
	\[
		\mhorel{\mapt{\Gamma}^{1}}{\mapt{\Delta_1'}^{1}}{\newsp{\tilde{m_1}'}{\pmapp{P_2}{1}{f} \Par \hotrigger{t}{x}{s}{\abs{z}{\binp{z}{x} \appl{x}{m_1}}} }}
		{\wb}{\mapt{\Delta_2'}^{1}}{}{\newsp{\tilde{m_2}'}{\pmapp{Q_2}{1}{f} \Par \hotrigger{t}{x}{s}{\abs{z}{\binp{z}{x} \appl{x}{m_2}}}}}
	\]
%
	\noi We rewrite the last result as
	\[
		\mhorel{\mapt{\Gamma}^{1}}{\mapt{\Delta_1'}^{1}}{\pmapp{\newsp{\tilde{m_1}'}{P_2 \Par \hotrigger{t}{x}{s}{m_1}}}{1}{f}}
		{\wb}{\mapt{\Delta_2'}^{1}}{}{\pmapp{\newsp{\tilde{m_2}'}{Q_2 \Par \hotrigger{t}{x}{s}{m_2}}}{1}{f}}
	\]
%
	\noi to conclude that
%
	\[
		\mhorel{\Gamma}{\Delta_1'}{\newsp{\tilde{m_1}'}{P_2 \Par \hotrigger{t}{x}{s}{m_1}}}
		{\ \Re\ }{\Delta_2'}{}{\newsp{\tilde{m_2}'}{Q_2 \Par \hotrigger{t}{x}{s}{m_2}}}
	\]
%
	\noi as required


	\noi {\bf Proof of Completeness Direction.}

	\noi Let
%
	\[
		\Re = \set{\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_1}^{1}}{\pmapp{P_1}{1}{f}}{,}{\mapt{\Delta_2}^{1}}{\pmapp{Q_1}{1}{f}} \setbar \horel{\Gamma}{\Delta_1}{P_1}{\wb}{\Delta_2}{Q_1}}
	\]
%
	We show that $\Re \subset \wb$ by a case analysis on the action $\ell$

	\noi - Case: $\ell \notin \set{\news{\tilde{m}} \bactout{n}{\abs{x}{P}}, \bactinp{n}{\abs{x}{P}}}$.

	\noi The proof of Proposition~\ref{prop:op_corr_HOp_to_HO} implies that
%
	\[
		\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_1}^{1}}{\pmapp{P_1}{1}{f}}{\hby{\ell}}{\mapt{\Delta_1'}^{1}}{\pmapp{P_2}{1}{f}}
	\]
%
	\noi implies
%
	\[
		\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}
	\]
%
	\noi From the latter transition and the definition of $\Re$ we imply
%
	\begin{eqnarray}
		&&\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\ell}}{\Delta_2'}{Q_2}
		\label{prop:HOp_to_HO:full_abs1}
		\\
		&&\horel{\Gamma}{\Delta_1'}{P_2}{\wb}{\Delta_2'}{Q_2}
		\label{prop:HOp_to_HO:full_abs2}
	\end{eqnarray}
%
	\noi From~\ref{prop:HOp_to_HO:full_abs1} and proposition~\ref{prop:op_corr_HOp_to_HO} we get
%
	\[
		\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_2}^{1}}{\pmapp{Q_1}{1}{f}}{\Hby{\ell}}{\mapt{\Delta_2'}^{1}}{\pmapp{Q_2}{1}{f}}
	\]
%
	\noi Furthermore, from~\ref{prop:HOp_to_HO:full_abs2} and the definition of $\Re$ we get
%
	\[
		\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_1'}^{1}}{\pmapp{P_2}{1}{f}}{\ \Re\ }{\mapt{\Delta_2'}^{1}}{\pmapp{Q_2}{1}{f}}
	\]
%
	\noi as required.

	\noi - Case: $\ell = \news{\tilde{m}} \bactout{n}{\abs{x}{P}}$

	\noi There are two subcases:

	\noi -Subcase:

	\noi The proof of Proposition~\ref{prop:op_corr_HOp_to_HO} implies that
%
	\[
		\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_1}^{1}}{\pmapp{P_1}{1}{f}}{\hby{\ell}}{\mapt{\Delta_1'}^{1}}{\pmapp{P_2}{1}{f}}
	\]
%
	\noi implies
%
	\[
		\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}
	\]
%
	\noi where the proof is similar with the previous case.

	\noi - Subcase:

	\noi The proof of Proposition~\ref{prop:op_corr_HOp_to_HO} implies that
%
	\[
		\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_1}^{1}}{\pmapp{P_1}{1}{f}}{\hby{\news{\tilde{m_1}'} \bactout{n}{\abs{z}{\binp{z}{x} \appl{x}{m_1}}}}}{\mapt{\Delta_1'}^{1}}{\pmapp{P_2}{1}{f}}
	\]
%
	\noi implies
%
	\[
		\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}'} \bactout{n}{m_1}}}{\Delta_1'}{P_2}
	\]
%
	\noi From the latter transition and the definition of $\Re$ we imply
%
	\begin{eqnarray}
		&&\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}'} \bactout{n}{m_2}}}{\Delta_2'}{Q_2}
		\label{prop:HOp_to_HO:full_abs3}
	\end{eqnarray}
%
	\noi and
%
	\begin{eqnarray}
		& \Gamma; \es; \Delta_1' & \proves \newsp{\tilde{m_1}'}{P_2 \Par \hotrigger{t}{x}{s}{m_1}} \nonumber \\
		& \wb & \Delta_2' \proves \newsp{\tilde{m_2}'}{Q_2 \Par \hotrigger{t}{x}{s}{m_2}}
		\label{prop:HOp_to_HO:full_abs4}
	\end{eqnarray}
%
	\noi From~\ref{prop:HOp_to_HO:full_abs3} and proposition~\ref{prop:op_corr_HOp_to_HO} we get
%
	\[
		\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_2}^{1}}{\pmapp{Q_1}{1}{f}}{\Hby{\news{\tilde{m_2}'} \bactout{n}{\abs{z}{\binp{z}{x} \appl{x}{m_2}}}}}{\mapt{\Delta_2'}^{1}}{\pmapp{Q_2}{1}{f}}
	\]
%
	\noi Furthermore, from~\ref{prop:HOp_to_HO:full_abs4} and the definition of $\Re$ we get
%
	\[
		\mhorel{\mapt{\Gamma}^{1}}{\mapt{\Delta_1'}^{1}}{\pmapp{\newsp{\tilde{m_1}'}{P_2 \Par \hotrigger{t}{x}{s}{m_1}}}{1}{f}}
		{\ \Re\ }{\mapt{\Delta_2'}^{1}}{}{\pmapp{\newsp{\tilde{m_2}'}{Q_2 \Par \hotrigger{t}{x}{s}{m_2}}}{1}{f}}
	\]
%
	\noi as required.

	\noi - Case: $\ell = \bactinp{n}{\abs{x}{P}}$

	\noi We have two subcases.

	\noi - Subcase: Similar with the first subcase of the previous case.

	\noi - Subcase:
	\noi The proof of Proposition~\ref{prop:op_corr_HOp_to_HO} implies that
%
	\[
		\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_1}^{1}}{\pmapp{P_1}{1}{f}}{\hby{\bactinp{n}{\abs{z}{ \binp{z}{x} \appl{x}{s}}}}}{\mapt{\Delta_1''}^{1}} R %{\pmapp{P_2}{1}{f}}
	\]
%
	\noi implies
%
	\begin{eqnarray}
		\horel{\Gamma}{\Delta_1}{P_1}{\hby{\bactinp{n}{m_1}}}{\Delta_1'}{P_2}
		\label{prop:HOp_to_HO:full_abs7}
	\end{eqnarray}
%
	\noi and
%
	\begin{eqnarray}
		\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_1''}^{1}}{R}{\shby{\tau}}{\mapt{\Delta_1'}^{1}}{\pmapp{P_2}{1}{f}}
		\label{prop:HOp_to_HO:full_abs8}
	\end{eqnarray}
%
%	\noi With the last transition happening on a restricted session channel.
%	From \dk{Lemma~\ref{lem:tau_inert}} we can conclude that
%	\begin{eqnarray}
%		\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_1''}^{1}}{R}{\wb}{\mapt{\Delta_1'}^{1}}{\pmapp{P_2}{1}{f}}
%		\label{prop:HOp_to_HO:full_abs9}
%	\end{eqnarray}
%
	\noi From the transition~\ref{prop:HOp_to_HO:full_abs7} and the definition of $\Re$ we imply
%
	\begin{eqnarray}
		&&\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\bactinp{n}{m_2}}}{\Delta_2'}{Q_2}
		\label{prop:HOp_to_HO:full_abs5}
		\\
		&&\horel{\Gamma}{\Delta_1'}{P_2}{\wb}{\Delta_2'}{Q_2}
		\label{prop:HOp_to_HO:full_abs6}
	\end{eqnarray}
%
	\noi From~\ref{prop:HOp_to_HO:full_abs5} and proposition~\ref{prop:op_corr_HOp_to_HO} we get
%
	\[
		\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_2}^{1}}{\pmapp{Q_1}{1}{f}}{\Hby{\bactinp{n}{\abs{z}{\binp{z}{x} \appl{x}{s}}}}}{\mapt{\Delta_2'}^{1}}{\pmapp{Q_2}{1}{f}}
	\]
%
	\noi Furthermore, from~\ref{prop:HOp_to_HO:full_abs6} and the definition of $\Re$ we get
%
	\[
		\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_1'}^{1}}{\pmapp{P_2}{1}{f}}{\ \Re\ }{\mapt{\Delta_2'}^{1}}{\pmapp{Q_2}{1}{f}}
	\]
%
	\noi If we consider result~\ref{prop:HOp_to_HO:full_abs8} we get.
%
	\[
		\horel{\mapt{\Gamma}^{1}}{\mapt{\Delta_1''}^{1}}{R}{\shby{\tau}\ \Re\ }{\mapt{\Delta_2'}^{1}}{\pmapp{Q_2}{1}{f}}
	\]
	where following Lemma~\ref{lem:up_to_session_transition} we show that $R$ is a bisimulation an up to $\SHby{}$.
	\qed
\end{proof}

%\begin{conjecture}[Full Abstraction]
%\begin{enumerate}[a)]
%\item
%If
%$\wbb{ \Gamma}{\ell}{\Delta_1}{ P }{ \Delta_2}{Q}$
%then
%$\wbb{\mapt{\Gamma}^{1}}{\ell}{\mapt{\Delta_1}^{1}}{\map{P}^{1}}{\mapt{\Delta_2}^{1}}
%{\map{Q}^{1}}$.
%\item  
%If 
%$\wbb{\mapt{\Gamma}^{1}}{\ell}{\mapt{\Delta_1}^{1}}{\map{P}^{1}}{\mapt{\Delta_2}^{1}}
%{\map{Q}^{1}}$
%then 
%$\wbb{ \Gamma}{\ell}{\Delta_1}{ P }{ \Delta_2}{Q}$.
%\end{enumerate}
%While (a) is  completeness, (b) is soundness.
%
%\end{conjecture}

\begin{comment}
\begin{proof}[Sketch]
	We must show completeness and soundness properties. 
	For completeness, it suffices to consider source process
	$P_0 = \bout{k}{k'} P \Par \binp{k}{x} Q$. We have that
%
	\[
		P_0 \red P \Par Q\subst{k'}{x}.
	\]
%
	By the definition of encoding we have:
	\begin{eqnarray*}
		\pmap{P_0}{1} & = & \bbout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{k'}} } \pmap{P}{1} \Par \binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact}  \\
		& \red & \pmap{P}{1} \Par \newsp{s}{\appl{X}{s} \subst{\abs{z}{\,\binp{z}{X} \appl{X}{k'}}}{X} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact} \\
		& = & \pmap{P}{1} \Par \newsp{s}{\,\binp{s}{X} \appl{X}{k'} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact} \\
		& \red & \pmap{P}{1} \Par \appl{X}{k'} \subst{\abs{x} \pmap{Q}{1}}{X} \Par \inact \\
		& \scong & \pmap{P}{1} \Par \pmap{Q}{1}\subst{k'}{x}  
	\end{eqnarray*}
	For soundness, it suffices to notice that the encoding does not add new visible actions:
	the additional synchronizations induced by the encoding always occur on private (fresh) names.
	We assume weak bisimilarities, which abstract from internal actions used by the encoding,
	and so  constructing a relation witnessing behavioral equivalence is easy.
	\qed
\end{proof}
\end{comment}

%\subsection{Polyadic Into Monadic}
%The encoding from $\psesp$ to $\sesp$ is easier than the
%encoding of polyadic $\pi$-calculus in the $\pi$-calculus because
%we have linear session endpoints.
%
%\begin{definition}[$\psesp$ to $\sesp$]
%	We write $\encod{\cdot}{\cdot}{2}:\psesp \to \sesp$ whenever
%
%	\begin{tabular}{c}
%			$\map{\bout{k}{k'_1, \cdots, k'_n} P}^{2} \defeq \bout{k}{k'_1} \cdots ;  \bout{k}{k'_n}
%			\pmap{P}{2}$\\
%			$\map{\binp{k}{x_1, \cdots, x_n} P}^{2} \defeq \binp{k}{x_1} \cdots ; \binp{k}{x_n}  \pmap{P}{2}$ \\
%			$\tmap{\btout{S_1, \cdots, S_n} S}{2} \defeq \bbtout{\tmap{S_1}{2}} \cdots; \bbtout{\tmap{S_n}{2}} \tmap{S}{2}$\\
%			$\tmap{\btinp{S_1, \cdots, S_n} S}{2} \defeq \bbtinp{\tmap{S_1}{2}} \cdots; \bbtinp{\tmap{S_n}{2}} \tmap{S}{2}$
%%		\end{tabular}
%%		& \quad &
%%		\begin{tabular}{l}
%%			$\tmap{\btout{S_1 \cat \tilde{S}} S}{2} \defeq \btout{S_1} \tmap{\btout{\tilde{S}} S}{2}$\\
%%			$\tmap{\btinp{S_1 \cat \tilde{S}} S}{2} \defeq \btinp{S_1} \tmap{\btinp{\tilde{S}} S}{2}$
%%		\end{tabular}
%	\end{tabular}
%\end{definition}
%
%Polyadic name sending (resp.\ receive) is encoded as sequence of
%send (resp.\ receive) operations. Linearity of session endpoints
%ensures no race conditions, thus the encoding is sound.
%
%The encoding of the polyadic $\sesp$ semantics is as simple as the
%composition of the two former encodings.
%
%\begin{definition}[Encoding from $\psespnr$ to $\HO$]
%	We define $\encod{\cdot}{\cdot}{3}: \psespnr \longrightarrow \HO$
%	as $\encod{\cdot}{\cdot}{3} = \encod{\cdot}{\cdot}{1} \cat \encod{\cdot}{\cdot}{2}$.	
%\end{definition}

%So far we have consider name abstractions and applications which are \emph{monadic}.
%We now consider the \emph{polyadic} extension of these constructs, %name abstractions and applications.
%written $\abs{x_1, \ldots, x_n} P$ and $\appl{X}{k_1, \ldots, k_n}$, respectively.
%Next we give the encoding from $\HOp$ with polyadic name abstraction to $\HOp^{p}$.
%
%\begin{definition}[Encoding from $\pHOpnr$ to $\pHOp$]
%
%	\begin{tabular}{lcl}
%		$\map{\bout{k}{\abs{\tilde{x}} P_1} P_2}^4$ &$\defeq$& $\bout{k}{\abs{z} \binp{z}{\tilde{x}} \map{P_1}^4} \map{P_2}^4$\\
%		$\map{\appl{X}{\tilde{k}}}$ &$\defeq$& $\newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\tilde{k}} \inact}$
%	\end{tabular}
%\end{definition}

%We compose the latter encoding with the generalisation $\map{\cdot}^3 : \HOp^{p-\mu} \longrightarrow \HO$
%of the encoding $\map{\cdot}^3 : \sesp^{p-\mu} \longrightarrow \HO$ to get a translation
%of $\HOp^{pa-\mu}$ to $\HO$.
%
%\begin{definition}[Encoding from $\HOp^{pa-\mu}$ to $\HO$]
%	We define $\encod{\cdot}{\cdot}{5}: \HOp^{pa-\mu} \longrightarrow \HO$
%	as $\encod{\cdot}{\cdot}{5} = \encod{\cdot}{\cdot}{4} \cat \encod{\cdot}{\cdot}{3}$.	
%\end{definition}

\begin{example}[Encode $\recp{X}{\bout{a}{m} \varp{X}}$ into \HO]

\noi We encode the \HOp process $\recp{X}{\bout{a}{m} \varp{X}}$
into a \HO process. The first application of the mapping
will give:
%
\begin{eqnarray*}
	\pmapp{\recp{X}{\bout{a}{m} \varp{X}}}{1}{f} &=&
	\newsp{s_1}{ \binp{s_1}{x} \pmapp{\bout{a}{m} \varp{X}}{1}{f, \varp{X} \rightarrow x_ax_m} \Par\\
	&&\bout{\dual{s_1}}{ \abs{x_a x_m z} \binp{z}{x} \auxmap{\pmapp{\bout{a}{m} \varp{X}}{1}{f, \varp{X} \rightarrow x_ax_m}}{\es} } \inact}
\end{eqnarray*}
%
\noi with $\pmapp{\bout{a}{m} \varp{X}}{1}{f, \varp{X} \rightarrow x_ax_m}$ defined as:
%
\begin{eqnarray*}
	\pmapp{\bout{a}{m} \varp{X}}{1}{f, \varp{X} \rightarrow x_ax_m} &=&
	\bout{a}{\abs{z}{\binp{z}{x} \appl{x}{m}}} \pmapp{\varp{X}}{1}{f, \varp{X} \rightarrow x_ax_m}
	\\
	&=& \bout{a}{\abs{z}{\binp{z}{x} \appl{x}{m}}} \newsp{s_2}{\appl{x}{a,m, s_2}  \Par \bout{\dual{s_2}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact}
\end{eqnarray*}
%
\noi Furthermore
%
\[
\begin{array}{l}
	\auxmap{\pmapp{\bout{a}{m} \varp{X}}{1}{f, \varp{X} \rightarrow x_ax_m}}{\es}\\
	\qquad \qquad \quad = \auxmap{\bout{a}{\abs{z}{\binp{z}{x} \appl{x}{m}}} \newsp{s_2}{\appl{x}{a,m, s_2}  \Par \bout{\dual{s_2}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact}}{\es}
	\\
	\qquad \qquad \quad = \bout{x_a}{\abs{z}{\binp{z}{x} \appl{x}{x_m}}} \auxmap{\newsp{s_2}{\appl{x}{a,m, s_2}  \Par \bout{\dual{s_2}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact}}{\es}
	\\
	\qquad \qquad \quad = \bout{x_a}{\abs{z}{\binp{z}{x} \appl{x}{x_m}}} \newsp{s_2}{\appl{x}{x_a,x_m, s_2}  \Par \bout{\dual{s_2}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact}
\end{array}
\]
%
\noi The whole encoding would be:
%
\[
\begin{array}{l}
	V = \abs{x_a x_m z} \binp{z}{x} \bout{x_a}{\abs{z}{\binp{z}{x} \appl{x}{x_m}}} \newsp{s_2}{\appl{x}{x_a,x_m, s_2}  \Par \bout{\dual{s_2}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact}\\
	\pmapp{\recp{X}{\bout{a}{m} \varp{X}}}{1}{f} \scong \\
	\ \newsp{s_1}{\bout{\dual{s_1}}{V} \inact \Par \binp{s_1}{x} \bout{a}{\abs{z}{\binp{z}{x} \appl{x}{m}}} \newsp{s_2}{\bout{\dual{s_2}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact} \Par \appl{x}{a,m, s_2}}
\end{array}
\]
%
\noi We can observe $\pmapp{\recp{X}{\bout{a}{m} \varp{X}}}{1}{f}$ as:
\[
	\begin{array}{cl}
		& \pmapp{\recp{X}{\bout{a}{m} \varp{X}}}{1}{f}\\
		\scong&
		\newsp{s_1}{\bout{\dual{s_1}}{V} \inact \Par \binp{s_1}{x} \bout{a}{\abs{z}{\binp{z}{x} \appl{x}{m}}} \newsp{s_2}{\bout{\dual{s_2}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact} \Par \appl{x}{a,m, s_2}}
		\\
		\by{\tau}&
		\bout{a}{\abs{z}{\binp{z}{x} \appl{x}{m}}}\\
		& \newsp{s_2}{\bout{\dual{s_2}}{V} \inact \Par \binp{s_2}{x} \bout{a}{\abs{z}{\binp{z}{x} \appl{x}{m}}} \newsp{s_3}{\bout{\dual{s_3}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact} \Par \appl{x}{a,m, s_3}}
		\\
		\scong_{\alpha}&
		\bout{a}{\abs{z}{\binp{z}{x} \appl{x}{m}}}\\
		 & \newsp{s_1}{\bout{\dual{s_1}}{V} \inact \Par \binp{s_1}{x} \bout{a}{\abs{z}{\binp{z}{x} \appl{x}{m}}} \newsp{s_2}{\bout{\dual{s_2}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact} \Par \appl{x}{a,m, s_2}}\\
		\scong& \bout{a}{\abs{z}{\binp{z}{x} \appl{x}{m}}} \pmapp{\recp{X}{\bout{a}{m} \varp{X}}}{1}{f}
		\\
		\by{\bactout{a}{\abs{z}{\binp{z}{x} \appl{x}{m}}}}& \pmapp{\recp{X}{\bout{a}{m} \varp{X}}}{1}{f}
	\end{array}
\]
%
\noi We further show that $\pmapp{\recp{X}{\bout{a}{m} \varp{X}}}{1}{f}$ is typable:
\begin{eqnarray}
	\tree{
		\begin{array}{l}
			\Gamma; \es; \es \proves a \hastype U_1 = \chtype{\lhot{\btinp{\lhot{U_2}} \tinact}} \\
			\Gamma; \es; \es \proves m \hastype U_2\\
			\Gamma; \es; s_2: \proves s_2 : \btinp{L} \tinact \proves s_2 \hastype \btinp{L} \tinact\\ 
			\Gamma; \es; \es \proves X \hastype \shot{(U_1, U_2, \btinp{L} \tinact)}
		\end{array}
	}{
		\Gamma; \es; s_2 : \btinp{L} \tinact \proves \appl{x}{a,m, s_2} \hastype \Proc
	}
	\label{ex:type1}
\end{eqnarray}
%
\begin{eqnarray}
	\tree{
		\tree{
			\begin{array}{l}
				\Gamma \cat x_a: U_1 \cat x_m: U_2; \es; \es \proves x_a \hastype U_1 = \chtype{\lhot{\btinp{\lhot{U_2}} \tinact}} \\
				\Gamma \cat x_a: U_1 \cat x_m: U_2 ; \es; \es \proves x_m \hastype U_2\\
				\Gamma; \es; z: \btinp{L} \tinact \proves z \hastype \btinp{L} \tinact\\
				\Gamma; \es; \es \proves X \hastype \shot{(U_1, U_2, \btinp{L} \tinact)}
			\end{array}
		}{
			\Gamma \cat x_a: U_1 \cat x_m: U_2 ; \es; z: \btinp{L} \tinact \proves \appl{x}{x_a x_m z} \hastype \Proc
		}
	}{
		\Gamma; \es; \es \proves \abs{x_a x_m z}{\appl{x}{x_a x_m z}} \hastype \shot{(U_1, U_2, \btinp{L} \tinact)}
	}
	\label{ex:type2}
\end{eqnarray}
%
\begin{eqnarray}
	\tree{
		\textrm{Result}~\eqref{ex:type1}
		\quad
		\tree{
			\textrm{Result}~\eqref{ex:type2}
			\quad
			\Gamma; \es; \dual{s_2} : \btout{\shot{(U_1, U_2, \btinp{L} \tinact)}} \tinact \proves \dual{s_2} \hastype \btout{\shot{(U_1, U_2, \btinp{L} \tinact)}} \tinact
		}{
			\Gamma; \es; \dual{s_2} : \btout{\shot{(U_1, U_2, \btinp{L} \tinact)}} \tinact \proves \bout{\dual{s_2}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact \hastype \Proc
		}
	}{
		\Gamma; \es; s_2: \btinp{L} \tinact \cat \dual{s_2}: \btout{\shot{(U_1, U_2, \btinp{L} \tinact)}} \tinact \proves \bout{\dual{s_2}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact \Par \appl{x}{a,m, s_2} \hastype \Proc
	}
	\label{ex:type3}
\end{eqnarray}
%
\begin{eqnarray}
	\tree{
		\begin{array}{l}
			\textrm{Result}~\eqref{ex:type3}
			\quad
			\btinp{L} \tinact \dualof \btout{\shot{(U_1, U_2, \btinp{L} \tinact)}} \tinact\\
			L = \shot{(U_1, U_2, \btinp{L} \tinact)} \textrm{ implies }\\
			\btinp{L} \tinact = \trec{t}{\btinp{\shot{(U_1, U_2, \vart{t})}} \tinact}
		\end{array}
	}{
		\Gamma; \es; \es \proves \newsp{s_2}{\bout{\dual{s_2}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact \Par \appl{x}{a,m, s_2} \hastype \Proc}
	}
	\label{ex:type4}
\end{eqnarray}
%
\begin{eqnarray}
	\tree{
		\textrm{Result}~\eqref{ex:type4}
		~~
		\Gamma; \es; \es \proves a \hastype \chtype{\lhot{\btinp{\lhot{U_2}} \tinact}}
		~~
		\Gamma; \es; \es \proves \abs{z}{\binp{z}{x} \appl{x}{m}} \hastype \lhot{\btinp{\lhot{U_2}} \tinact}
	}{
		\Gamma; \es; \es \proves \bout{a}{\abs{z}{\binp{z}{x} \appl{x}{m}}} \newsp{s_2}{\bout{\dual{s_2}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact \Par \appl{x}{a,m, s_2}} \hastype \Proc
	}
	\label{ex:type5}
\end{eqnarray}
%
\begin{eqnarray}
	\tree{
		\begin{array}{l}
			\textrm{Result}~\eqref{ex:type5}
			\quad
			\Gamma' = \Gamma \backslash X
			\\
			\Gamma; \es; \es \proves X \hastype \shot{(U_1, U_2, \trec{t}{\btinp{\shot{(U_1, U_2, t)}} \tinact})}
			\\
			\Gamma'; \es; \Delta \proves s_1 \hastype \btinp{\shot{(U_1, U_2, \trec{t}{\btinp{\shot{(U_1, U_2, \vart{t})}} \tinact})}} \tinact
		\end{array}
	}{
		\Gamma'; \es; \Delta_1 \proves \binp{s_1}{x} \bout{a}{\abs{z}{\binp{z}{x} \appl{x}{m}}} \newsp{s_2}{\bout{\dual{s_2}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact \Par \appl{x}{a,m, s_2}} \hastype \Proc
	}
	\label{ex:type6}
\end{eqnarray}
%
\begin{eqnarray}
	\tree{
		\begin{array}{l}
			V = \abs{x_a x_m z} \binp{z}{x} \bout{x_a}{\abs{z}{\binp{z}{x} \appl{x}{x_m}}} \newsp{s_2}{\appl{x}{x_a,x_m, s_2}  \Par \bout{\dual{s_2}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact}\\
			\Gamma'; \es; \es \proves V \hastype \shot{(U_1, U_2, \trec{t}{\btinp{\shot{(U_1, U_2, \vart{t})}} \tinact})}\\
			\Gamma'; \es; \Delta_2 \proves \dual{s_1} \hastype \btout{\shot{(U_1, U_2, \trec{t}{\btinp{\shot{(U_1, U_2, t)}} \tinact})}} \tinact
		\end{array}
	}{
		\Gamma'; \es; \Delta_2 \proves \bout{\dual{s_1}}{V} \hastype \Proc
	}
	\label{ex:type7}
\end{eqnarray}
%
\begin{eqnarray*}
	\tree{
		\tree{
			\textrm{Result}~\eqref{ex:type6} \quad \textrm{Result}~\eqref{ex:type7}
		}{
			\Gamma; \es; \Delta_1 \cat \Delta_2 \proves \bout{\dual{s_1}}{V} \inact \Par \binp{s_1}{x} \bout{a}{\abs{z}{\binp{z}{x} \appl{x}{m}}} \newsp{s_2}{\bout{\dual{s_2}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact} \Par \appl{x}{a,m, s_2} \hastype \Proc
		}
	}{
			\Gamma; \es; \es \proves \newsp{s_1}{\bout{\dual{s_1}}{V} \inact \Par \binp{s_1}{x} \bout{a}{\abs{z}{\binp{z}{x} \appl{x}{m}}} \newsp{s_2}{\bout{\dual{s_2}}{\abs{x_a x_m z}{\appl{x}{x_a x_m z}}} \inact} \Par \appl{x}{a,m, s_2}} \hastype \Proc
	}
\end{eqnarray*}
\qed
\end{example}


\begin{comment}
\subsection{Encoding Recursion into Abstraction Passing}\label{ss:fullfotoho}

Encoding the constructs for recursion present in $\sessp$ as process-passing
communication requires to follow the fundamental
principle of copying the process that needs to exhibit recursive behaviour.
The primitive recursor operation creates copies of a process and uses them
as continuations.

We use an example to demostrate our basic intuitions:
%
\begin{example}
	Assume process $P = \recp{X}{\bout{n}{m} \rvar{X}}$. We have
%
	\begin{eqnarray}
		\label{ex:rec1}
		P \scong \bout{n}{m} \recp{X}{\bout{n}{m} \rvar{X}} 
	\end{eqnarray}
%
	\noi The above process emits to its environment infinitely many send actions of channel $m$ along channel $n$.
	Name $n$ includes the recursive
	variable $\rvar{X}$, so the type for $n$ should be recursive.
%
	\[
		\recp{X}{\bout{n}{m} \rvar{X}} \by{\bactout{n}{m}} \recp{X}{\bout{n}{m} \rvar{X}}
	\]
%
	To get a better understanding of how name $n$ is handled
	on such scenarios, consider the process:
	\[
		P \scong \newsp{a}{\bout{a}{n} \inact \Par \recp{X}{\binp{a}{x} \bout{x}{m} (\bout{a}{x} \inact \Par \rvar{X})}}
		%\red \newsp{a}{\bout{n}{m} (\bout{a}{n} \inact \Par \recp{X}{\binp{a}{x} \bout{x}{m} (\bout{a}{x} \inact \Par \rvar{X}))}}
	\]
%
	\noi The above process exhibits the same behaviour as
	process~\ref{ex:rec1}.
	Endpoint $n$ is being passed sequentially on copies of the 
	same process to achieve the effect of infinite sending of value $m$.
%
	\begin{eqnarray*}
		P	&\scong&	\newsp{a}{\bout{a}{n} \inact \Par \recp{X}{\binp{a}{x} \bout{x}{m} (\bout{a}{x} \inact \Par \rvar{X})}}\\
			&\red&		\newsp{a}{\bout{n}{m} (\bout{a}{n} \inact \Par \recp{X}{\binp{a}{x} \bout{x}{m} (\bout{a}{x} \inact \Par \rvar{X}))}}\\
			&\by{\bactout{n}{m}}& \newsp{a}{\bout{a}{n} \inact \Par \recp{X}{\binp{a}{x} \bout{x}{m} (\bout{a}{x} \inact \Par \rvar{X})}}\\
			&\scong&	P
	\end{eqnarray*}
%
	\noi If we want to apply the same principles on higher order semantics we should first
	abstract the recursive process:
%
	\[
		\recp{X}{\binp{a}{x} \bout{x}{m} ( \rvar{X} \Par \bout{a}{x} \inact)}
	\]
%
	\noi as
%
	\[
		V \scong (z) \bout{n}{m} \binp{z}{X} \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\abs{z}{\appl{X}{z}}} \inact}
	\]
%
	So the entire process can be written as:
	\[
		P \scong \newsp{s_1}{\bout{s_1}{V} \inact \Par \binp{\dual{s_1}}{X} \newsp{s_2}{\appl{X}{s_2} \Par \bout{\dual{s_2}}{\abs{z}{\appl{X}{z}}} \inact}}	
	\]
%
	\noi where abstraction $V$ is copied and passed to itself
	infinitely many times:
	\[
		\begin{array}{rcl}
			P &\scong& \newsp{s_1}{\bout{s_1}{V} \inact \Par \binp{\dual{s_1}}{X} \newsp{s_2}{\appl{X}{s_2} \Par \bout{\dual{s_2}}{\abs{z}{\appl{X}{z}}} \inact}} \\
			&\red&
			\newsp{s_2}{\bout{\dual{s_2}}{V} \inact \Par \bout{n}{m} \binp{s_2}{X} \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{{z}{\appl{X}{z}} \inact}}}\\
			&\by{\bactout{n}{m}}&
			\newsp{s_2}{\bout{\dual{s_2}}{V} \inact \Par \binp{s_2}{X} \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\abs{z}{\appl{X}{z}} \inact}}}\\
			&\scong_\alpha&
			P
		\end{array}
	\]
%

	\noi In the typing setting, abstraction $V$ has a linear type:
	\[
		m: U; \es; n: \btout{U} S_1 \tinact \proves
		(z) \bout{n}{m} \binp{z}{X} \newsp{s_2}{\appl{X}{s_2} \Par \bout{\dual{s_2}}{\abs{z{\appl{X}{z}} } \inact} \hastype
		\lhot{S_2}
	\]
	because of the free occurence of session channel $n$ in $V$,
	i.e.\ we cannot apply typing rule $\trule{Prom}$ to the latter
	judgement.

	\noi But when passed, abstraction $V$ is applied in a shared manner, i.e.\ two
	copies of the abstraction are instantiated, thus the whole
	encoding is untypable: 
	\[
		\Gamma; X: \lhot{S_2}; \es \not\proves \newsp{s_2}{\appl{X}{s_2} \Par \bout{\dual{s_2}}{\abs{z} \appl{X}{z}}} \inact}
	\]
%
	\noi The untypability problem would not exist
	provided that the abstraction being passed were not linear.

	\noi A typable solution of the above example would be first to
	define a shared abstraction by replacing the free
	occurence of session name $n$ with an abstraction variable:
%
	\[
		V' = (z, x) \bout{x}{m} \binp{z}{X} \newsp{s}{\appl{X}{s, x} \Par \bout{\dual{s}}{\abs{z, x}{\appl{X}{z, x}} } \inact}
	\]
%
	Abstraction $V'$ can be typed using a shared type:
	\[
		\tree{
			m: U_1; \es; \es \proves
			(z, x) \bout{x}{m} \binp{z}{X} \newsp{s}{\appl{X}{s, x} \Par \bout{\dual{s}}{\abs{z, x}{\appl{X}{z, x}} } \inact}
			\hastype \lhot{U_2}
		}{
			m: U_1; \es; \es \proves
			(z, x) \bout{x}{m} \binp{z}{X} \newsp{s}{\appl{X}{s, x} \Par \bout{\dual{s}}{\abs{z, x}{\appl{X}{z, x}} } \inact}
			\hastype \shot{U_2}
		}~~\trule{Prom}
	\]
%
	\noi and the definition and behaviour of the recursive process, becomes:
%
	\begin{eqnarray*}
		P' &\scong&	\newsp{s_1}{\bout{s_1}{V} \inact \Par \binp{\dual{s_1}}{X} \newsp{s_2}{\appl{X}{s_2, n} \Par \bout{\dual{s_2}}{\abs{z,x}{\appl{X}{z,x}}} \inact}}\\
		&\red&		\newsp{s_2}{\bout{\dual{s_2}}{V} \inact \Par \bout{n}{m} \binp{s_2}{X} \newsp{s}{\appl{X}{s, n} \Par \bout{\dual{s}}{\abs{z, x}{\appl{X}{z, x}}} \inact}}\\
		&\by{\bactout{n}{m}}& \newsp{s_2}{\bout{\dual{s_2}}{V} \inact \Par \binp{s_2}{X} \newsp{s}{\appl{X}{s, n} \Par \bout{\dual{s}}{\abs{z, x}{\appl{X}{z, x}}} \inact}}\\
		&\scong_\alpha& P'
	\end{eqnarray*}
%
	\noi Session channel $n$ is passed and applied
	together with the recursive process.
\end{example}

A preliminary tool to encode the $\sessp$ recursion primitives would be to
provide a mapping from processes to processes with no free names.
We require some auxiliary definitions.
%
\begin{definition}\rm 
	Let $\vmap{\cdot}: 2^{\mathcal{N}} \longrightarrow \mathcal{V}^\omega$
	be a map of sequences names to sequences of variables, defined
	inductively as follows:
%
\[
	\vmap{n} = x_n \qquad \qquad \qquad \vmap{n \cat \tilde{m}} = x_n \cat \vmap{\tilde{m}}
\]
\end{definition}

Given a process $P$, we write $\ofn{P}$ to denote the
\emph{sequence} of free names of $P$, lexicographically ordered.
Intuitively, the following mapping transforms processes
with free session names into abstractions:
%
\begin{definition}\label{d:trabs}\label{d:auxmap}
	Let $\sigma$ be a set of session names.
	Define $\auxmapp{\cdot}{\mathsf{v}}{\sigma}: \HOp \to \HOp$  as in Fig.~\ref{f:auxmap}.
%
\begin{figure}[t]
\[
	\begin{array}{rcl}
		\auxmapp{\news{n} P}{\sigma}{\mathsf{v}} &\bnfis& \news{n} \auxmapp{P}{\mathsf{v}}{{\sigma \cat n}}
		\vspace{1mm} \\

%		\auxmapp{\bout{n}{\abs{x}{Q}} P}{\mathsf{v}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\bout{x_n}{\abs{x,\vmap{\ofn{P}}}{\auxmapp{Q}{\mathsf{v}}{\sigma}}} \auxmapp{P}{\mathsf{v}}{\sigma} & n \notin \sigma\\
%			\bout{n}{\abs{x,\vmap{\ofn{P}}}{\auxmapp{Q}{\mathsf{v}}{\sigma}}} \auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma
%		\end{array}
%		\right.

		\auxmapp{\bout{n}{\abs{x}{Q}} P}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\bout{x_n}{\abs{x}{\auxmapp{Q}{\mathsf{v}}{\sigma}}} \auxmapp{P}{\mathsf{v}}{\sigma} & n \notin \sigma\\
			\bout{n}{\abs{x}{\auxmapp{Q}{\mathsf{v}}{\sigma}}} \auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma
		\end{array}
		\right.
		\vspace{1mm}	\\ 

%		\auxmapp{\bout{n}{m} P}{\mathsf{v}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%		    \bout{n}{m}\auxmapp{P}{\mathsf{v}}{\sigma} & n, m \in \sigma \\
%		    \bout{x_n}{m}\auxmapp{P}{\mathsf{v}}{\sigma} & n \not\in \sigma, m \in \sigma \\
%		    \bout{n}{x_m}\auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma, m \not\in \sigma \\
%		    \bout{x_n}{x_m}\auxmapp{P}{\mathsf{v}}{\sigma} & n, m \not\in \sigma 
%		\end{array}
%		\right.
%		\vspace{1mm} \\ 

		\auxmapp{\binp{n}{X} P}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\binp{x_n}{X} \auxmapp{P}{\mathsf{v}}{\sigma} & n \notin \sigma\\
			\binp{n}{X} \auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma
		\end{array}
		\right.
		\vspace{1mm}	\\ 
%		\auxmapp{\binp{n}{x}P}{\mathsf{v}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%		    \binp{n}{x}\auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma \\
%		    \binp{x_n}{x}\auxmapp{P}{\mathsf{v}}{\sigma} & n \not\in \sigma 
%		\end{array}
%		\right.
%		\vspace{1mm} \\ 
		\auxmapp{\bsel{n}{l} P}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\bsel{x_n}{l} \auxmapp{P}{\mathsf{v}}{\sigma} & n \notin \sigma\\
			\bsel{n}{l} \auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma
		\end{array}
		\right.
		\vspace{1mm} \\
		\auxmapp{\bbra{n}{l_i:P_i}_{i \in I}}{\mathsf{v}}{\sigma} &\bnfis&
		%\auxmapp{\bsel{n}{l} P}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\bbra{x_n}{l_i:\auxmapp{P_i}{\mathsf{v}}{\sigma}}_{i \in I}  & n \notin \sigma\\
			\bbra{n}{l_i:\auxmapp{P_i}{\mathsf{v}}{\sigma}}_{i \in I}  & n \in \sigma
		\end{array}
		\right.
		\vspace{1mm} \\
		\auxmapp{\appl{\X}{n}}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\appl{\X}{x_n} & n \notin \sigma\\
			\appl{\X}{n} & n \in \sigma\\
		\end{array}
		\right. 
%		\auxmapp{\inact}{\mathsf{v}}{\sigma} &\bnfis& \inact\\
%		\auxmapp{P \Par Q}{\mathsf{v}}{\sigma} &\bnfis& \auxmapp{P}{\mathsf{v}}{\sigma} \Par \auxmapp{Q}{\mathsf{v}}{\sigma} 
	\end{array}
\]
\caption{\label{f:auxmap} The auxiliary map (cf. Def.~\ref{d:auxmap}) 
used in the encoding of first-order communication with recursive definitions into higher-order communication (Def.~\ref{d:enc:fotohorec}).
The mapping is defined homomorphically for inaction and parallel composition.}
\end{figure}
\end{definition}

Given a process $P$ with $\fn{P} = m_1, \cdots, m_n$, we are interested in its associated (polyadic) abstraction, which is defined as
$\abs{x_1, \cdots, x_n}{\auxmapp{P}{\mathsf{v}}{\es} }$, where $\vmap{m_j} = x_j$, for all $j \in \{1, \ldots, n\}$.
This transformation from processes into abstractions can be reverted by
using abstraction and application with an appropriate sequence of session names:
%
\begin{proposition}\rm
	Let $P$ be a \HOp process with $\tilde{n} = \ofn{P}$.
	Also, suppose $\tilde{x} = \vmap{\tilde{n}}$.
%	Also, let $A_P$ be the polyadic abstraction $\abs{\tilde{x}}\auxmapp{P}{\mathsf{v}}{\emptyset}$ (cf. Def.~\ref{d:trabs}).
	Then $P \scong \appl{X}{\tilde{n}}\subst{\abs{\tilde{x}}\auxmapp{P}{\mathsf{v}}{\emptyset}}{X}$.
%	$\appl{X}{\smap{\fn{P}}} \subst{(\vmap{\fn{P}}) \map{P}^{\emptyset}}{X} \scong P$
\end{proposition}

\begin{proof}
	The proof is an easy induction on the map $\auxmapp{P}{\mathsf{v}}{\es}$.
	We give a case since other cases are similar.

	\noi - Case: $\auxmapp{\bout{n}{m} P}{\mathsf{v}}{\es} = \bout{x_n}{x_m} \auxmapp{P}{\mathsf{v}}{\es}$

	\noi We rewrite process substitution as:
	$\appl{X}{\tilde{n}} \subst{\abs{\tilde{x}}{\bout{x_n}{y_m} \auxmapp{P}{\mathsf{v}}{\es}}}{X} = (\bout{x_n}{y_m} P) \subst{\tilde{x}}{\tilde{n}}$

	\noi If consider that $x_n, y_m \in \vmap{\tilde{n}}$ then from the definition of $\vmap{\cdot}$ we
	get that $n, m \in \tilde{n}$. Furthermore by the fact that $\tilde{n}$ and $\vmap{\tilde{n}}$ are
	ordered, substitution becomes:
	$\bout{n}{m} \auxmapp{P}{\mathsf{v}}{\es} \subst{\tilde{x}}{\tilde{n}}$.

	\noi The rest of the cases are similar.
	\qed
\end{proof}

We are now ready to define the encoding of $\sessp$
(including constructs for recursion) into strict process-passing.
Thanks to the encoding in \S\,\ref{ss:polmon}, we may use polyadicity in abstraction and application only
as syntactic sugar.
For the sake of completeness, we give again the encodings for 
finite processes and types, as
formalized 
in \S\,\ref{ss:ffotoho}.
%by $\encod{\cdot}{\cdot}{1}: \sessp^{-\mu} \to \HO$.

\begin{definition}[Full First-Order into Higher-Order]\label{d:enc:fotohorec}
	Let $f$ be a function from recursion variables to sequences of name variables.
	%Define $\fencod{\cdot}{\cdot}{2}{f}: \sessp \to \HO$ as
%
Define the typed encoding $\enco{\map{\cdot}^{2}_f, \mapt{\cdot}^{2}, \mapa{\cdot}^{2}}: \sessp \to \HO$,
\begin{figure}[t]
\[
	\begin{array}{rcll}
%		\map{\rec{X}{P}}^{2} &=& \newsp{s}{\binp{s}{\X} \map{P}^{2} \Par \bout{\dual{s}}{\abs{z \cat \vmap{\fn{P}}}{\binp{z}{\X} \map{P}^{\es}}} \inact}\\
%		\map{r}^{2} &=& \newsp{s}{\appl{\X}{s \cat \smap{\fn{P}}} \Par \bout{\dual{s}}{ \abs{z \cat \vmap{\fn{P}}}{\appl{X}{z \cat \vmap{\fn{P}}}}} \inact} \\
		\pmapp{\recp{X}{P}}{2}{f} &\defeq&
		\newsp{s}{\binp{s}{\X} \pmapp{P}{2}{{f,\{\rvar{X}\to \tilde{n}\}}} \Par \bout{\dual{s}}{\abs{\vmap{\tilde{n}}, z } \,{\binp{z}{\X} \auxmapp{\pmapp{P}{2}{{f,\{\rvar{X}\to \tilde{n}\}}}}{\mathsf{v}}{\es}}} \inact} & \quad \tilde{n} = \ofn{P} \\ 
		\pmapp{\rvar{X}}{2}{f} &\defeq& \newsp{s}{\appl{\X}{\tilde{n}, s} \Par \bbout{\dual{s}}{ \abs{\vmap{\tilde{n}},z}\,\,{\appl{X}{ \vmap{\tilde{n}}, z}}} \inact} & \quad \tilde{n} = f(\rvar{X}) \\
		\pmapp{\bout{k}{n} P}{2}{f}	&\defeq&	\bout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{n}} } \pmapp{P}{2}{f} \\
		\pmapp{\binp{k}{x} Q}{2}{f}	&\defeq&	\binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\abs{x}{\pmapp{Q}{2}{f}}} \inact} \\


		\pmapp{\bsel{s}{l} P}{2}{f} &\defeq& \bsel{s}{l} \pmapp{P}{2}{f} \qquad
		\pmapp{\bbra{s}{l_i: P_i}_i \in I}{2}{f} \defeq \bbra{s}{l_i: \pmapp{P_i}{2}{f}}_i \in I\\
		\pmapp{\bout{k}{\abs{\tilde{x}}{Q}} P}{2}{f} &\defeq& \bout{k}{\abs{\tilde{x}}{\pmapp{Q}{2}{f}}} \pmapp{P}{2}{f} \qquad
		\pmapp{\binp{k}{X} P}{2}{f} \defeq \binp{k}{X} \pmapp{P}{2}{f}\\

		\pmapp{P \Par Q}{2}{f} &\defeq& \pmapp{P}{2}{f} \Par \pmapp{Q}{2}{f} \qquad
		\pmapp{\news{n} P}{2}{f} \defeq \news{n} \pmapp{P}{2}{f} \qquad

		\pmapp{\inact}{2}{f} \defeq \inact\\


		\tmap{\btout{S_1} {S} }{2}	&\defeq&	\bbtout{\lhot{\btinp{\lhot{\tmap{S_1}{2}}}\tinact}} \tmap{S}{2}  \\
		\tmap{\btinp{S_1} S }{2}	&\defeq&	\bbtinp{\lhot{\btinp{\lhot{\tmap{S_1}{2}}}\tinact}} \tmap{S}{2} \\
		\tmap{\bbtout{\chtype{S_1}} {S} }{2}	&\defeq&	\bbtout{\shot{\btinp{\shot{\chtype{\tmap{S_1}{2}}}}\tinact}} \tmap{S}{2}  \\
		\tmap{\bbtinp{\chtype{S_1}} {S} }{2}	&\defeq&	\bbtinp{\shot{\btinp{\shot{\chtype{\tmap{S_1}{2}}}}\tinact}} \tmap{S}{2} \\

		\tmap{\btout{L} S}{2} &\defeq& \btout{L} \tmap{S}{2}\\
		\tmap{\btinp{L} S}{2} &\defeq& \btinp{L} \tmap{S}{2}\\
		\tmap{\btsel{l_i: S_i}_{i \in I}}{2} &\defeq& \btsel{l_i: \tmap{S_i}{2}}_{i \in I}\\
		\tmap{\btbra{l_i: S_i}_{i \in I}}{2} &\defeq& \btbra{l_i: \tmap{S_i}{2}}_{i \in I}\\

		\tmap{\vart{t}}{2} &\defeq& {t} \qquad
		\tmap{\trec{t}{S}}{2} \defeq \trec{t}{\tmap{S}{2}} \qquad
		\tmap{\tinact}{2} \defeq \tinact\\

		\mapa{\bactout{n}{m}}^{2} &\defeq&   \bactout{n}{\abs{z}{\,\binp{z}{X} \appl{X}{m}} } \\
		\mapa{\bactinp{n}{m}}^{2} &\defeq&   \bactinp{n}{\abs{z}{\,\binp{z}{X} \appl{X}{m}} } \\

		\mapa{\bactout{n}{\abs{\tilde{x}}{P}}}^{2} &\defeq& \bactout{n}{\abs{\tilde{x}}{\pmapp{P}{2}{\es}}} \qquad
		\mapa{\bactinp{n}{\abs{\tilde{x}}{P}}}^{2} \defeq \bactinp{n}{\abs{\tilde{x}}{\pmapp{P}{2}{\es}}}\\
		\mapa{\tau} &\defeq& \tau
	\end{array}
\]
\caption{\label{f:enc:fotohorec}
Typed encoding of first-order communication into higher-order communication (cf.~Defintion~\ref{d:enc:fotohorec}).
Mappings 
$\map{\cdot}^2$,
$\mapt{\cdot}^2$, 
and 
$\mapa{\cdot}^2$
are homomorphisms for the other processes/types/labels. 
}

\end{figure}
where mappings $\map{\cdot}^{2}$, $\mapt{\cdot}^{2}$, $\mapa{\cdot}^{2}$
are as in Fig.~\ref{f:enc:fotohorec}.
\end{definition}

\begin{remark}
Let $\Delta = \{n_1:S_1, \ldots, n_m:S_m\}$ be a session environment.
Write $\tilde{S}_{\Delta} = S_1, \ldots, S_m$.
	We define  mapping $\mapt{\cdot}^{2}$ on (first-order) shared environments $\Gamma$ as follows:
	\begin{eqnarray*}
	\mapt{\Gamma \cat k:\chtype{S}}^{2} & =  & \mapt{\Gamma}^{2} \cat k:\mapt{\chtype{S}}^{2} \\
	\tmap{\Gamma \cat \rvar{X}:\Delta}{2} & = & \tmap{\Gamma}{2} \cat X:\shot{(\tilde{S}_{\Delta}\,,\,S^*)}\qquad 
		\text{where
	$S^* = \trec{t}{\big((\tilde{S}_{\Delta}\,,\, \btinp{\vart{t}}\tinact)\big)}$}
	\end{eqnarray*}
\end{remark}

%\begin{proposition}\rm
%	Encoding $\fencod{\cdot}{\cdot}{2}{f}: \sessp \to \HO$  
%	is type-preserving (cf. Def.~\ref{def:ep}\,(1)).
%\end{proposition}


\begin{proposition}[Type Preservation, Full First-Order into Higher-Order]\label{prop:typepres2}
Let $P$ be a  $\sessp$ process.
If			$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then 
			$\mapt{\Gamma}^{2}; \emptyset; \mapt{\Delta}^{2} \proves \map{P}_f^{2} \hastype \Proc$. 
\end{proposition}

\begin{proof}
By induction on the inference $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$. 
Details in Appendix~\ref{app:enc_sesp_to_HO}.
	\qed
\end{proof}

%\begin{proposition}\rm
%	Encoding $\fencod{\cdot}{\cdot}{2}{f}: \sessp \to \HO$ 
%	enjoys operational correspondence (cf. Def.~\ref{def:ep}\,(2)).
%\end{proposition}

The following proposition formalizes our strategy  for encoding recursive definitions
as passing of polyadic abstractions:
\begin{proposition}[Operational Correspondence for Recursive Processes]
Let $P$ and $P_1$ be $\sessp$ processes s.t. $P =\recp{X}{P'}$ and $P_1 = P'\subst{\recp{X}{P'}}{\rvar{X}} \scong P$. \\
If $P_1 \hby{\ell} P_2$ then there exist
processes $R_1$, $R_2$,
context $C$, 
action $\ell'$,
and 
mapping $f_1$
such that: 
(1)~$\map{P}_f^{2} \hby{\tau} \map{P'}_{f_1}^{2}\subst{\context{C}{\map{P'}_{f_1}^{2}}}{X} = R_1$; and
(2)~$R_1 \Hby{\ell'} R_2$, with $\ell' = \mapa{\ell}^{2}$.
\end{proposition}

\begin{proof}[Sketch]
Part (1) follows directly from the definition of typed encoding for processes $\map{\cdot}_f^{2}$
(Defintion~\ref{d:enc:fotohorec}).
We have that 
context $\context{C}{\cdot} = \abs{\tilde{m}}\binp{z}{X}\auxmapp{\cdot}{\mathsf{v}}{\sigma}$
(where $\tilde{m} = \ofn{P'},z$)
and
$f_1 = f, \{\rvar{X} \to \ofn{P'}\}$.
Part (2) relies on  Prop.~\ref{p:opcorrfho}.
\qed
\end{proof}

\begin{proposition}[Operational Correspondence, Full First-Order into Higher-Order]
\label{p:auxfullfho}
Let $P$ be a  $\sessp$ process.
If $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then
		\begin{enumerate}[a)]
			\item	 
			   If  $\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$
			   then  $\exists \ell_2$ s.t. \\
			    $\wtytra{\mapt{\Gamma}^{2}}{\ell_2}{\mapt{\Delta}^{2}}{\map{P}_f^{2}}{\mapt{\Delta'}^{2}}{\map{P'}_f^{2}}$
			    and $\ell_2 = \mapa{\ell_1}^{2}$.
			\item   
			If  $\wtytra{\mapt{\Gamma}^{2}}{\ell_2}{\mapt{\Delta}^{2}}{\map{P}^{2}_f}{\mapt{\Delta'}^{2}}{Q}$
			   then $\exists \ell_1, P'$ s.t.  \\
			    (i)~$\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$,
			    (ii)~$\ell_2 = \mapa{\ell_1}^{2}$, 
			    (iii)~$\wbb{\mapt{\Gamma}^{2}}{\ell}{\mapt{\Delta'}^{2}}{\map{P'}_f^{2}}{\mapt{\Delta'}^{2}}{Q}$.
			    \end{enumerate}
\end{proposition}

\begin{proof}[Sketch]
The proof follows similar lines as the proof of Prop.~\ref{p:opcorrfho},
using 
Prop.~\ref{p:auxfullfho} in the extra cases $P =\recp{X}{P'}$ and $P = \rvar{X}$.
	\qed
\end{proof}

\end{comment}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  HOp ---> pi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{From \HOp to \sessp}
\label{subsec:HOp_to_FO}

We now discuss the encodability of  $\HO$ into $\sessp$ where
%, 
%i.e., how to encode a higher-order calculus with abstraction passing only
%into a calculus with name passing only. 
we essentially follow the representability result put forward by 
Sangiorgi~\cite{San92,SaWabook}, but casted in the setting of session-typed communications. 
As we shall see, linearity of session endpoints will play a role in adaptating Sangiorgi's 
encodability strategy into a typed setting. 
Intuitively, such a strategy represents the exchange of a process with the exchange of 
a \emph{trigger}---a freshly generated names. 
Triggers may then be used to activate copies of the process, which now becomes a persistent 
resource represented by an input-guarded replication.
In session-based communication, a session name 
is a linear resource and cannot be replicated.
Consider the following (naive) adaptation of 
Sangiorgi's strategy in which session names are used are triggers and 
exchanged processes would be have to used exactly once:
%
\[
	\begin{array}{lcl}
		\pmap{\bout{u}{\abs{x}{Q}} P}{n} & \defeq &  \newsp{s}{\bout{u}{s} (\pmap{P}{n} \Par \binp{\dual{s}}{x} \pmap{Q}{n})} \\
		\pmap{\binp{u}{x} P}{n} & \defeq& \binp{u}{x} \pmap{P}{n}\\
		\pmap{\appl{x}{u}}{n} & \defeq & \bout{x}{u} \inact
	\end{array}
\]
%
with the remaining \HOp constructs being mapped homomorphically.
Although $\pmap{\cdot}{n}$ captures the correct semantics when
dealing with systems that allow only linear abstractions,
it suffers from non-typability in the presence
of shared abstractions. For instance,
mapping for $P = \bout{n}{\abs{x}{\bout{x}{m}\inact}} \inact \Par \binp{\dual{n}}{x} (\appl{x}{s_1} \Par \appl{x}{s_2})$
would be:
%
\[
	\pmap{P}{n} \defeq
	\newsp{s}{\bout{n}{s} \binp{\dual{s}}{x} \bout{x}{m} \inact \Par \binp{\dual{n}}{x} (\bout{x}{s_1} \inact \Par \bout{x}{s_2} \inact)}
\]
%
The above process is non typable since processes $(\bout{x}{s_1} \inact$ and $\bout{x}{s_2} \inact)$
cannot be put in parallel because they do not have disjoint session environments.

The correct approach would be to use replicated shared names
as triggers instead of session names, when dealing with shared abstractions. 
Below we write $\repl{} P$ as a shorthand notation for $\recp{X}{(P \Par \rvar{X})}$.

\begin{definition}[Higher-Order into First-order]\rm
\label{def:enc:HOp_to_FO}
	Define encoding
	$\enco{\map{\cdot}^2, \mapt{\cdot}^2, \mapa{\cdot}^2}: \HO \to \sessp$
	with mappings 
	$\map{\cdot}^{2}$, $\mapt{\cdot}^{2}$, $\mapa{\cdot}^{2}$ as
	in Fig.~\ref{fig:enc:HOp_to_FO}.
\end{definition}
%
\begin{figure}[t]
	\[
	\begin{array}{rcl}
		\pmap{\bout{u}{\abs{x}{Q}} P}{2} & \defeq &  \left\{
		\begin{array}{ll}
			\newsp{a}{\bout{u}{a} (\pmap{P}{2} \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{2})\,} & s \notin \fn{Q} \\
			\newsp{s}{\bout{u}{s} (\pmap{P}{2} \Par \binp{s}{y} \binp{y}{x} \pmap{Q}{2})\,} & \textrm{otherwise} %\dk{Q \textrm{ linear}} \\
		\end{array}
		\right.
		\\
		\pmap{\binp{u}{x} P}{2} &\defeq&  \binp{u}{x} \pmap{P}{2}\\
		\pmap{\appl{x}{u}}{2} & \defeq & \newsp{s}{\bout{x}{s} \bout{\dual{s}}{u} \inact}
		\\
		\\
		\tmap{\btout{\shot{S}}S_1}{2} & \defeq & \bbtout{\chtype{\btinp{\tmap{S}{2}}\tinact}}\tmap{S_1}{2} \\
		\tmap{\btinp{\shot{S}}S_1}{2} & \defeq & \bbtinp{\chtype{\btinp{\tmap{S}{2}}\tinact}}\tmap{S_1}{2} \\

		\tmap{\btout{\lhot{S}}S_1}{2} & \defeq & \bbtout{\btinp{\tmap{S}{2}}\tinact}\tmap{S_1}{2} \\
		\tmap{\btinp{\lhot{S}}S_1}{2} & \defeq & \bbtinp{\btinp{\tmap{S}{2}}\tinact}\tmap{S_1}{2} \\
		\mapa{\bactout{n}{\abs{ x}{P}} }^{2} &  \defeq & \news{m} \bactout{n}{m} \\
		\mapa{\bactinp{n}{\abs{ x}{P}} }^{2} &  \defeq & \bactinp{n}{m}
	\end{array}
	\]
	\caption{
		Typed encoding of higher-order  into first-order communication (cf.~Defintion~\ref{def:enc:HOp_to_FO}).
		\label{fig:enc:HOp_to_FO}
		Mappings 
		$\map{\cdot}^3$,
		$\mapt{\cdot}^3$, 
		and 
		$\mapa{\cdot}^3$
		are homomorphisms for the other processes/types/labels. 
	}
\end{figure}


\begin{proposition}[Type Preservation, \HOp into \sessp]\rm
\label{prop:typepres_HOp_to_FO}
	Let $P$ be a \HOp process. 
	If $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then 
	$\mapt{\Gamma}^{2}; \emptyset; \mapt{\Delta}^{2} \proves \map{P}^{2} \hastype \Proc$.
\end{proposition}

\begin{proof}
	By induction on the inference $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$. 
	Details in \S~\ref{app:enc:HOp_to_sessp}
	(Page~\pageref{app:enc:HOp_to_sessp}).
	\qed
\end{proof}

\begin{proposition}[Operational Correspondence, \HOp into \sessp]\rm
	Let $P$ be an  $\HO$ process such that  $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$.
	
	\begin{enumerate}[1.]
	\item Suppose $\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$.
	Then we have:
	\begin{enumerate}[a)]
%			\item	 
%			   If  $\stytra{\Gamma}{\bactout{k}{\abs{x}Q}}{\Delta}{P}{\Delta'}{P'}$
%			   then 
%			   $\map{P}^{3} \hby{\news{a}\bactout{k}{a}} \scong \map{P'}^{3} \Par R_a$, \\ where 
%			   either
%			   $R_a = \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{3}$ 
%			   or $R_a = \binp{a}{y} \binp{y}{x} \pmap{Q}{3}$.
		\item	 
			If  $\ell_1 = \bactout{n}{\abs{x}Q}$,
			then $\exists \Gamma', R$ s.t. \\
			$\mapt{\Gamma}^{2};\, \mapt{\Delta}^{2} \proves  \map{P}^{2} 
			\hby{\mapa{\ell_1}^{2}}
			\Gamma' \cdot \mapt{\Gamma}^{2};\, \mapt{\Delta'}^{2} \proves \map{P'}^{2} \Par R$, 
			where either \\
			$R = \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{3}$ 
			or $ R = \binp{s}{y} \binp{y}{x} \pmap{Q}{3}$.
		   
%			\item	 
%			   If  $\stytra{\Gamma}{\bactinp{k}{\abs{x}Q}}{\Delta}{P}{\Delta'}{P'\subst{\abs{x}Q}{X}}$
%			   then 
%			   $\map{P}^{3} \hby{ \bactinp{k}{a} \map{P'}^{3}\subst{a}{x}$.				


		\item	 
			If  %$\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'\subst{\abs{x}Q}{X}}$ with 
			$\ell_1 = \bactinp{n}{\abs{y}Q}$
			and $P' = P_0\subst{\abs{y}Q}{x}$
			then $\exists m$ s.t. \\
			$\mapt{\Gamma}^{2};\, \mapt{\Delta}^{2} \proves \map{P}^{2} 
			\hby{\mapa{\ell_1}^{2}}
			\Gamma';\, \mapt{\Delta'}^{2} \proves  \map{P_0}^{2}\subst{m}{x}$, 
			where $\Gamma' = \mapt{\Gamma}^{2}\subst{m}{x}$.

%			   $\stytra{\mapt{\Gamma}^{3}}{\mapa{\ell_1}^{3}}{\mapt{\Delta}^{3}}{\map{P}^{3}}{\mapt{\Delta'}^{3}}{$.

		\item	 
			If  
			%$\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P_1 \Par P_2\subst{\abs{x}Q}{X}}$
			$\ell_1 = \tau$ and $P' 	\scong P_1 \Par P_2\subst{\abs{x}Q}{X}$
			then \\
			$\mapt{\Gamma}^{2};\, \mapt{\Delta}^{2} \proves  \map{P}^{2}
			\hby{\tau}
			\mapt{\Gamma}^{2};\, \mapt{\Delta'}^{2} \proves  \map{P_1}^{2} \Par \news{n}
			(\map{P_2}^{2}\subst{n}{x} \Par R)$, \\
			where 
			either
			$R = \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{2}$ 
			or $R = \binp{s}{y} \binp{y}{x} \pmap{Q}{2}$.


		\item	 
			If  
			%$\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P_1 \Par P_2\subst{\abs{x}Q}{X}}$
			$\ell_1 = \tau$ and $P' 	\not \scong P_1 \Par P_2\subst{\abs{x}Q}{X}$
			then \\
			$\mapt{\Gamma}^{2};\, \mapt{\Delta}^{2} \proves  \map{P}^{2}
			\hby{\tau}
			\mapt{\Gamma}^{2};\, \mapt{\Delta'}^{2} \proves  \map{P'}^{2}$.
			
				   			   
%			   then  $\exists \ell_2$ s.t. 
%			    $\wtytra{\mapt{\Gamma}^{3}}{\ell_2}{\mapt{\Delta}^{3}}{\map{P}^{3}}{\mapt{\Delta'}^{3}}{\map{P'}^{3}}$
%			    and $\ell_2 = \mapa{\ell_1}^{3}$.
		\end{enumerate}
		\item Suppose 
		$\stytra{\mapt{\Gamma}^{2}}{\ell_2}{\mapt{\Delta}^{2}}{\map{P}^{2}}{\mapt{\Delta'}^{2}}{R}$.
		\begin{enumerate}[a)]
		\item
			%\footnote{$\mapt{\Gamma}^{2}$ in the following three items need adjustments.}
			If  
			$\ell_2 = \news{m}\bactout{n}{m}$
			%$\stytra{\mapt{\Gamma}^{2}}{\news{m}\bactout{n}{m}}{\mapt{\Delta}^{2}}{\map{P}^{2}}{\mapt{\Delta'}^{2}}{R}$
			then $\exists x, Q, P'$ s.t. \\
			$P \hby{\bactout{n}{\abs{x}Q}} P'$
			and $R = \map{P'}^{2} \Par R$, where 
			either
			$R = \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{2}$ 
			or $R = \binp{s}{y} \binp{y}{x} \pmap{Q}{2}$.

		\item   
			If  $\ell_2 = \bactinp{n}{m}$ 
			%$\stytra{\mapt{\Gamma}^{2}}{\bactinp{n}{m}}{\mapt{\Delta}^{2}}{\map{P}^{2}}{\mapt{\Delta'}^{2}}{R}$
			then $\exists x, Q, P'$ s.t. \\
			$P \hby{\bactout{n}{\abs{x}Q}} P'\subst{\abs{x}Q}{X}$
			and $R = \map{P'}^{2}\subst{m}{x}$.
		
		\item   
			If  %$\stytra{\mapt{\Gamma}^{2}}{\tau}{\mapt{\Delta}^{2}}{\map{P}^{2}}{\mapt{\Delta'}^{2}}{R}$
			$\ell_2 = \tau$ 
			then $\exists P'$ s.t.
			$P \hby{\tau} P'$
			and $\horel{\mapt{\Gamma}^{2}}{\mapt{\Delta'}^{2}}{\map{P'}^{2}}{\wbf}{\mapt{\Delta'}^{2}}{R}$.
	\end{enumerate}
	\end{enumerate}
\end{proposition}

\begin{proof}
	Follows directly from Defintion~\ref{def:enc:HOp_to_FO}, using the substitution lemma (Lemma~\ref{lem:subst})
	and Prop.~\ref{prop:typepres_HOp_to_FO}.
	\qed
\end{proof}

\begin{comment}
\begin{proof}[Sketch]
For completeness, we 
consider the \HO process $P = {\bbout{k}{\abs{x} Q} P_1} \Par \binp{k}{X} P_2$. We have that
\[
P \red P_1 \Par P_2 \subst{\abs{x}Q}{X}
\]
In the target language, this reduction is mimicked as follows:
\begin{eqnarray*}
\pmap{P}{2} & = & \newsp{a}{\bout{k}{a} (\pmap{P_1}{3} \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{3})\,} 
                  \Par \binp{k}{x} \pmap{P_2}{3} \\
            & \red & \newsp{a}{\pmap{P_1}{3} \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{3} 
                  \Par  \pmap{P_2}{3}\subst{a}{x}}
\end{eqnarray*}
\qed
\end{proof}
\end{comment}


\begin{conjecture}[Full Abstraction: Higher-Order / First-Order]\rm
	\begin{enumerate}[a)]
		\item
			If
			$\horel{\Gamma}{\Delta_1}{P}{\wb}{\Delta_2}{Q}$
			then
			$\horel{\mapt{\Gamma}^{2}}{\mapt{\Delta_1}^{2}}{\map{P}^{2}}{\wbf}{\mapt{\Delta_2}^{2}}
			{\map{Q}^{2}}$.
		\item  
			If 
			$\horel{\mapt{\Gamma}^{2}}{\mapt{\Delta_1}^{2}}{\map{P}^{2}}{\wb}{\mapt{\Delta_2}^{2}}
			{\map{Q}^{2}}$
			then 
			$\horel{ \Gamma}{\ell}{\Delta_1}{ P }{\wbf}{ \Delta_2}{Q}$.
	\end{enumerate}
	While (a) is  completeness (non trivial), (b) is soundness  (easy in principle).
\end{conjecture}

At this point an open  question would be if we could find an encoding that maps
session names to session names without the creation of shared names.

\dk{put intuition??}

