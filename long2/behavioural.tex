% !TEX root = main.tex
\section{Behavioural Semantics}
\label{sec:beh_sem}

In this section we define a theory for observational equivalence over
session typed \HOp processes. The theory follows the principles
laid by the previous work of the authors
\cite{DBLP:conf/forte/KouzapasYH11,KY13,dkphdthesis}.
We require a bisimulation relation over typed processes that
is also characterised by the corresponding typed, reduction-closed,
barbed congruence relation.

\dk{(Jorge, I think you have a paper we can cite over session typed bisimulations)}

\subsection{Labelled Transition Semantics}\label{ss:lts}

We define a relation $(P_1, \ell, P_2) \in R$ over
(untyped) processes, that allows us to follow how a process may
interact with a process in its enviroment. The interaction
is defined on action $\ell$:
%
\[
	\begin{array}{rcl}
		\ell	& \bnfis  & \tau 
		\bnfbar \news{\tilde{m}} \bactout{n}{V} 
		\bnfbar\bactinp{n}{V} 
		\bnfbar \bactsel{n}{l} 
		\bnfbar \bactbra{n}{l} 
	\end{array}
\]
%
\noi The internal action is defined on label $\tau$.
Action $\news{\tilde{m}} \bactout{n}{V}$ denotes the sending of value $V$ over channel $n$ with
names $\tilde{m}$ being restricted.
Dually the action for the reception of values is 
$\bactinp{n}{V}$.
We also defined actions for selecting a label $l$, $\bactsel{n}{l}$ and branching on a label
$n$, $\bactbra{s}{l}$.

The dual action relation is the symmetric relation $\asymp$, that satisfies the rules:
%
\[
	\bactsel{n}{l} \asymp \bactbra{\dual{n}}{l}
	\qquad
	\news{\tilde{m}'} \bactout{n}{V} \asymp \bactinp{\dual{n}}{V}
\]
%
Dual actions happen on subjects that are dual between them and carry the same
object. Furthermore output action is dual with input action and 
select action is dual with branch action.

\input{figures/fig-unLTS}

{\bf Untyped Labelled Transition System:}
The labelled transition system, LTS, is defined in Figure~\ref{fig:untyped_LTS}.
A process with a send prefix can interact with the environment with a send
action that carries a value $V$ as in rule $\ltsrule{Out}$.
Dually in rule $\ltsrule{In}$
a received prefixed process can observe a receive action of a value $V$.
Select and branch prefixed processes observe the select
and branch actions in rules $\ltsrule{Sel}$ and $\ltsrule{Bra}$ respectively.
Rule $\ltsrule{Res}$ closes the LTS under the name creation
operator provided that the restricted name does not occur free in the observable action.
If a restricted name occurs free in and an output action 
then the name is added as in the bound name list of the action
and the continuation process performs scope opening as described in rule $\ltsrule{Scope}$.
Rules $\ltsrule{LPar}$ and $\ltsrule{RPar}$ close the LTS under the parallel operator 
provided that the observable action does not shared any bound names with the 
parallel processes.
Rule $\ltsrule{Tau}$ states that if two parallel processes can perform dual actions
then the two actions  can synchronise to observe an internal transition. 
Finally rule $\ltsrule{Alpha}$ closes  the LTS under alpha-renaiming.

\subsection{Characteristic Processes}
We can use a session type to define the a {\em characteristic process}
which is the simplest process that is typed
under the given session type.
%
\begin{definition}[Characteristic Process]\rm
	\label{def:characteristic_process}
	Let name $u$ and type $U$; then we define a {\em characteristic process}:
	$\map{U}^k$ as:
%
	\[
	\begin{array}{cc}
		\begin{array}{rclcl}
			\map{\btinp{U} S}^{u} &=& \binp{u}{x} (\map{S}^{u} \Par \map{U}^{x})
			\\
			\map{\btout{U} S}^{u} &=& \bout{u}{\omap{U}} \map{S}^{u} %& & n \textrm{ fresh}
			\\
			\map{\btsel{l : S}}^{u} &=& \bsel{u}{l} \map{S}^{u}
			\\
			\map{\btbra{l_i: S_i}_{i \in I}}^{u} &=& \bbra{u}{l_i: \map{S_i}^{u}}_{i \in I}
			\\
			\map{\tvar{t}}^{k} &=& \varp{X}_{\vart{t}}
			\\
			\map{\trec{t}{S}}^{u} &=& \recp{X_{\vart{t}}}{\map{S}^{u}}
			\\
			\map{\tinact}^{u} &=& \inact
			\\
		\end{array}
		&
		\begin{array}{rcrclcl}
			&&\map{\chtype{S}}^{u} &=& \bout{u}{\omap{S}} \inact
			\\
			&&\map{\chtype{L}}^{u} &=& \bout{u}{\omap{L}} \inact
			\\
			\map{\shot{C}}^{x} &=& \map{\lhot{C}}^{x} &=& \appl{x}{\omap{C}}
			\\
			\\
			&&\omap{S} &=& s && s \textrm{ fresh}
			\\
			\omap{\chtype{S}} &=& \omap{\chtype{L}} &=& a && a \textrm{ fresh}
			\\
			\omap{\shot{C}} &=& \omap{\lhot{C}} &=& \abs{x}{\map{C}^x} 
		\end{array}
	\end{array}
	\]
\end{definition}
%
\begin{comment}
\begin{definition}[Characteristic Process]\rm
	\label{def:characteristic_process}
	Let name $u$ and type $C$; then we define a {\em characteristic process}:
	$\map{C}^k$ as:
%
	\[
	\begin{array}{rclcl}
		\map{\btinp{C} S}^{u} &=& \binp{u}{x} (\map{S}^{u} \Par \map{C}^{x})
		\\
		\map{\btout{C} S}^{u} &=& \bout{u}{n} \map{S}^{u} & & n \textrm{ fresh}
		\\
		\map{\btsel{l : S}}^{u} &=& \bsel{u}{l} \map{S}^{u}
		\\
		\map{\btbra{l_i: S_i}_{i \in I}}^{u} &=& \bbra{u}{l_i: \map{S_i}^{u}}_{i \in I}
		\\
		\map{\tvar{t}}^{k} &=& \varp{X}_{\vart{t}}
		\\
		\map{\trec{t}{S}}^{u} &=& \recp{X_{\vart{t}}}{\map{S}^{u}}
		\\
		\map{\btout{\lhot{C}} S}^{u} &=& \bout{u}{\abs{x}{\map{C}^{x}}} \map{S}^u
		\\
		\map{\btinp{\lhot{C}} S}^{u} &=& \binp{u}{x} (\map{S}^u \Par \appl{x}{n}) & & n \textrm{ fresh}
		\\
		\map{\btout{\shot{C}} S}^{u} &=& \bout{u}{\abs{x}{\map{C}^{x}}} \map{S}^u
		\\
		\map{\btinp{\shot{C}} S}^{u} &=& \binp{u}{x} (\map{S}^u \Par \appl{x}{n}) & & n \textrm{ fresh}
		\\

%		\map{\btinp{\chtype{S}} S}^{k} &=& \binp{k}{x} (\map{S}^k \Par \map{\chtype{S}}^y)
%		&&
%		\map{\btout{\chtype{S}} S}^{k} &=& \bout{k}{a} \map{S}^k  & a\textrm{ fresh}
%		\\

		\map{\tinact}^{u} &=& \inact
		\\
		\map{\chtype{S}}^{u} &=& \bout{u}{s} \inact & & s \textrm{ fresh}
		\\
		\map{\chtype{\lhot{C}}}^{u} &=& \bout{u}{\abs{x} \map{C}^{x}} \inact
		\\
		\map{\chtype{\shot{C}}}^{u} &=& \bout{u}{\abs{x} \map{C}^{x}} \inact
	\end{array}
	\]
\end{definition}
\end{comment}

\begin{proposition}\rm
$ $
	\begin{itemize}
		\item	$\Gamma; \emptyset; \Delta \cat u:S \proves \map{S}^u \hastype \Proc$
		\item	$U = \chtype{S}$ or $U = \chtype{L}$ implies $\Gamma \cat u:U; \emptyset; \Delta \proves \map{U}^u \hastype \Proc$
	\end{itemize}
\end{proposition}

\begin{proof}
	By induction on the definition of $\map{S}^u$ and $\map{U}^u$.
\end{proof}

\begin{corollary}\rm
	If $\Gamma; \emptyset; \Delta \proves \map{C}^{u} \hastype \Proc$
	then
	$\Gamma; \es; \Delta \proves u \hastype C$.
\end{corollary}

\subsection{Typed Labeled Transition System}

\input{figures/fig-envLTS}

We define two relations of the form:
%
\[
	((\Gamma, \Lambda_1, \Delta_1), \ell, (\Gamma, \Lambda_2, \Delta_2)) \in R \textrm{ and }
\]
%
\noi over type tuples, that allows us to follow the progress of types over actions $\ell$.
The upper part of Figure~\ref{fig:envLTS} describes relation $\by{\ell}$.

Rule $\eltsrule{SOut}$ states the conditions for observing action
$\news{\tilde{m}} \bactout{s}{V}$ on a type tuple $(\Gamma, \Lambda, \Delta)$. 
The session environment $\Delta$ of the type tuple should include
a type for $s$ that is prefixed on the output type of type $U$.
Furthermore the dual channel $\dual{s}$ should not be
present in the session environment, since if it was present
the only communication that could take place is the interaction
between the two endpoints.
Under the latter conditions the type tuple may output any
value $V$ that is typed under a subset of $\Delta$ and
the session environment that types the restricted names
$\tilde{m}$. Scope extrusion of session names in $\tilde{m}$ requires
that the dual endpoints of $\tilde{m}$ appear in
the resulting session environment. Similarly for shared names
in $\tilde{m}$ that are extruted.
All free values used for typing $V$ are subtracted from the
resulting type tuple. Also the prefix of session $s$ is consumed
by the action.
Similarly, an output on a shared name is described
with rule $\eltsrule{ShOut}$ where we require a shared name
is typed with $\chtype{U}$. The requirements for
the output $V$ are indentical with the requirements for
rule $\eltsrule{SOut}$.
Rules $\eltsrule{SRecv}$ and $\eltsrule{ShRecv}$ describe
the input action $\bactinp{n}{V}$ ($n$ session or shared channel respectively)
on the type tuple $(\Gamma, \Lambda, \Delta)$.
We require the value $V$ has the same type as name $n$. Furthermore
we expect the resulting type tuple to contain the values that
consist value $V$.
Rules $\eltsrule{Sel}$ and $\eltsrule{Bra}$ describe actions for
select and branch. The only requirements for both
rules is that the dual endpoint is not present in the session
environment and furthermore the action labels are present
in the type.
Hidden transitions do not change the session environment
or they follow the reduction on the session
environment (Definition~\ref{def:ses_red}) as we can see in rule
$\eltsrule{Tau}$.

A second environment LTS, denoted $\hby{\ell}$,
is defined in the lower part of Figure~\ref{fig:envLTS}.
The definition substitutes rules
$\eltsrule{SRecv}$ and $\eltsrule{ShRecv}$
of relation $\by{\ell}$ with rule $\eltsrule{RRcv}$.
% the corresponding input cases
%of $\by{\ell}$ with the definitions of $\hby{\ell}$.
All other cases remain the same as the cases for
relation $\by{\ell}$.
Rule $\eltsrule{RRcv}$ restricts the higher-order input
in relation $\hby{\ell}$;
only characteristic processes and trigger processes
are allowed to be received on a higher-order input.
Names can still be received as in the definition of
the $\by{\ell}$ relation.
The conditions for input follow the conditions
for the $\by{\ell}$ definition.

\paragraph{Typed Transition System}

We define two transition systems over processes, as a combination
of the untyped LTS and the LTS for typed environments:

\begin{definition}[Typed Transition Systems]\label{d:tlts}\rm
	We write
%
	\begin{enumerate}
		\item	$\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_2}{P_2}$
			whenever
			$P_1 \by{\ell} P_2$,
			$(\Gamma, \emptyset, \Delta_1) \by{\ell} (\Gamma, \emptyset, \Delta_2)$
			and $\Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$.

		\item	$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_2}{P_2}$
			whenever
			$P_1 \by{\ell} P_2$,
			$(\Gamma, \emptyset, \Delta_1) \hby{\ell} (\Gamma, \emptyset, \Delta_2)$
			and
			$\Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$.
	\end{enumerate}
%
\end{definition}

We extend to $\By{}$ (resp.\ $\Hby{}$) and $\By{\hat{\ell}}$ (resp.\ $\Hby{\hat{\ell}}$) in the standard way.

\begin{lemma}[Invariant]\label{l:invariant}
	If $\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_2}{P_2}$
	then $\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_2}{P_2}$.
\end{lemma}

\begin{proof}
	The proof is straightforward from the definition of rule $\eltsrule{RRcv}$.
\end{proof}

\subsection{Behavioural Semantics}

We use the typed labelled transition semantics to define
a set of relations over typed processes that allow us to compare
typed processes over a notion of observational equivalence.

We begin with a definition of a notion of confluence
over session environments $\Delta$:
%
\begin{definition}[Session Environment Confluence]\rm
	We denote $\Delta_1 \bistyp \Delta_2$ whenever $\exists \Delta$ such that
	$\Delta_1 \red^* \Delta$ and $\Delta_2 \red^* \Delta$.
\end{definition}
%
A typed relation is a relation over typed programs:

\begin{definition}[Typed Relation]\rm
	We say that
	$\Gamma; \emptyset; \Delta_1 \proves P_1 \hastype \Proc\ \Re \ \Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$
	is a typed relation whenever:
	i) $P_1$ and $P_2$ are programs;
	ii) $\Delta_1$ and $\Delta_2$ are well typed;
	iii) and $\Delta_1 \bistyp \Delta_2$.

	We write
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{P_2}$
	for $\Gamma; \emptyset; \Delta_1 \proves P_1 \hastype \Proc\ \Re\ \Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$.
\end{definition}

Type relations relate only programs (i.e.\ processes with no free variables) with
well typed session environments and furthermore the two session environments
are confluent.

We define the notions of barb and typed barb.

\begin{definition}[Barbs]\rm
	Let program $P$.
	\begin{enumerate}
		\item	We write $P \barb{n}$ if $P \scong \newsp{\tilde{m}}{\bout{n}{V} P_2 \Par P_3}, n \notin \tilde{m}$.
			We write $P \Barb{n}$ if $P \red^* \barb{n}$.

		\item	We write $\Gamma; \emptyset; \Delta \proves P \barb{n}$ if
			$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ with $P \barb{n}$ and $\dual{n} \notin \Delta$.
			We write $\Gamma; \emptyset; \Delta \proves P \Barb{n}$ if $P \red^* P'$ and
			$\Gamma; \emptyset; \Delta' \proves P' \barb{n}$.			
	\end{enumerate}
\end{definition}

A barb $\barb{n}$ is an observable on an output prefix with subject $n$.
Similarly a weak barb $\Barb{n}$ is a barb after a number of reduction steps.
Typed barbs $\barb{n}$ (resp.\ $\Barb{n}$)
happen on typed processes $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$
where we require that the corresponding dual endpoint $\dual{n}$ is not present
in the session type $\Delta$.

We define the notion of the context:

\begin{definition}[Context]\rm
	A context $\C$ is defined on the grammar:
%
\[
	\begin{array}{rcl}
		\C &\bnfis& \hole \bnfbar \bout{u}{V} \C \bnfbar \bout{u}{\abs{x}{\C}} P \bnfbar \binp{u}{x} \C \\
		& \bnfbar & \news{n} \C \bnfbar \C \Par P \bnfbar \bsel{u}{l} \C \bnfbar \bbra{k}{l_1: P_1, \dots, l_i:\C, \dots, l_n: P_n}
	\end{array}
\]
%
	Notation $\context{\C}{P}$ replaces every $\hole$ in $\C$ with $P$.
\end{definition}

A context is a function that takes a process and returns a new process
according to the above syntax.

The first behavioural relation we define is reduction-closed, barbed congruence:
%
\begin{definition}[Reduction-closed, Barbed Congruence]\rm
	Typed relation
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{P_2}$
	is a barbed congruence whenever:
%
	\begin{enumerate}
		\item
		\begin{itemize}
			\item	If $P_1 \red P_1'$ then $\exists P_2', P_2 \red^* P_1'$ and
				$\horel{\Gamma}{\Delta_1'}{P_1'}{\ \Re\ }{\Delta_2'}{P_2'}$
			\item	If $P_2 \red P_2'$ then $\exists P_1', P_1 \red^* P_1'$ and
				$\horel{\Gamma}{\Delta_1'}{P_1'}{\ \Re\ }{\Delta_2'}{P_2'}$
		\end{itemize}

		\item
		\begin{itemize}
			\item	If $\Gamma;\emptyset;\Delta \proves P_1 \barb{s}$ then $\Gamma;\emptyset;\Delta \proves P_2 \Barb{s}$.
			\item	If $\Gamma;\emptyset;\Delta \proves P_2 \barb{s}$ then $\Gamma;\emptyset;\Delta \proves P_1 \Barb{s}$.
		\end{itemize}

		\item	$\forall \C, \horel{\Gamma}{\Delta_1'}{\context{\C}{P_1}}{\ \Re\ }{\Delta_2'}{\context{\C}{P_2}}$
	\end{enumerate}
%
	The largest such congruence is denoted with $\cong$.
\end{definition}
%
Reduction-closed, barbed congruence is closed under reduction semantics and 
preserves barbs under any context. In a sense no barb observer can distinguish
between two related processes.

The second behavioural relation is contextual bisimulation:
%
\begin{definition}[Contextual Bisimulation]\rm
	Typed relation 
	$\Re$ is a {\em contextual bisimulation} if whenever
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{P_2}$ implies:
	\begin{enumerate}
		\item	$\forall \news{\tilde{m_1}} \bactout{n}{V_1}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\by{\news{\tilde{m_1}} \bactout{n}{V_1}}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2, \abs{x}{Q}$ such that
			\[
				\horel{\Gamma}{\Delta_2}{Q_1}{\By{\news{\tilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}
			\]
			and $\forall R$ with $\set{x} = \fv{R}$, 
			then
			\[
				\horel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par R\subst{V_1}{x}}}
				{\ \Re\ }
				{\Delta_2''}{\newsp{\tilde{m_2}}{Q_2 \Par R\subst{V_2}{x}}}
			\]
%
		\item	$\forall \ell \not= \news{\tilde{m}} \bactout{n}{V}$
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2$ such that
			\[
				\horel{\Gamma}{\Delta_1}{Q_1}{\by{\ell}}{\Delta_2'}{Q_2}
			\]
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re\ }{\Delta_2'}{Q_2}$

		\item	The symmetric cases of 1 and 2.
	\end{enumerate}
%
	The Knaster Tarski theorem ensures that the largest contextual bisimulation exists,
	it is called contextual bisimilarity and is denoted by $\wbc$.
\end{definition}

The contextual bisimulation in the general case is a hard relation to be computed
since it is universaly quantified over substituting processes. The next definition
of a bisimulation relation avoids the universal quantifier over processes.

\begin{definition}[Higher-Order Bisimulation]\rm
	\label{def:HO_bisim}
	Typed relation
	$\Re$ is a {\em HO-bisimulation} if whenever
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{Q_1}$ implies:
%
	\begin{enumerate}
		\item	$\forall \news{\tilde{m_1}} \bactout{n}{V_1}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}} \bactout{n}{V_1}}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2, V_2$ such that
			\[
				\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}
			\]
			and for fresh $t$:
			\[
				\mhorel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \hotrigger{t}{V_1}}}
				{\ \Re\ }
				{\Delta_2''}{}{\newsp{\tilde{m_2}}{Q_2 \Par \hotrigger{t}{V_2}}}
			\]
%
		\item	$\forall \ell \not= \news{\tilde{m}} \bactout{n}{V}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2$ such that 
			\[
				\horel{\Gamma}{\Delta_1}{Q_1}{\Hby{\ell}}{\Delta_2'}{Q_2}
			\]
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re\ }{\Delta_2'}{Q_2}$

		\item	The symmetric cases of 1 and 2.
	\end{enumerate}
	The Knaster Tarski theorem ensures that the largest bisimulation exists,
	it is called bisimilarity and is denoted by $\wb$.
\end{definition}

Higher-Order Bisimulation uses higher order input guarded triggers, thus
it cannot be used as an equivalence relation for the \sessp sub-calculus.
An alternative definition of the bisimulation based on first order
output triggers solves this problem.

\begin{definition}[First-Order Bisimulation]\rm
	\label{def:FO_bisim}
	Typed relation 
	$\Re$ is a {\em FO-bisimulation} if whenever
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \mathcal{R}\ }{\Delta_2}{Q_1}$ implies:
	\begin{enumerate}
		\item	$\forall \news{\tilde{m_1}} \bactout{n}{V_1}$ with $\Gamma; \es; \Delta \proves V_1 \hastype U$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}} \bactout{n}{V_1}}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2, V_2$ with $\Gamma; \es; \Delta \proves V_2 \hastype U$ such that
			\[
				\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}
			\]
			and for fresh $t$
			\[
				\mhorel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \fotrigger{t}{x}{s}{\btinp{U} \inact}{V_1}}}
				{\ \Re\ }
				{\Delta_2''}{}{\newsp{\tilde{m_2}}{Q_2 \Par \fotrigger{t}{x}{s}{\btinp{U} \inact}{V_2}}}
			\]
%
		\item	$\forall \ell \not= \news{\tilde{m}} \bactout{n}{V}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2$ such that 
			\[
				\horel{\Gamma}{\Delta_1}{Q_1}{\Hby{\ell}}{\Delta_2'}{Q_2}
			\]
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re\ }{\Delta_2'}{Q_2}$

		\item	The symmetric cases of 1 and 2.
	\end{enumerate}
	The Knaster Tarski theorem ensures that the largest bisimulation exists,
	it is called bisimilarity and is denoted by $\wbf$.
\end{definition}


\begin{comment}
\begin{definition}[Bisimulation]\label{d:bisim}\rm
	Let typed relation $\mathcal{R}$ such that
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \mathcal{R}\ }{\Delta_2}{Q_1}$.
	$\mathcal{R}$ is a {\em bisimulation} whenever:
	\begin{enumerate}
		\item	$\forall \news{\tilde{m_1}} \bactout{n}{\abs{\tilde{x}}{P}}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}} \bactout{n}{\abs{\tilde{x}}{P}}}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2, \abs{\tilde{x}}{Q}$ such that
			\[
				\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}} \bactout{n}{\abs{\tilde{x}}{Q}}}}{\Delta_2'}{Q_2}
			\]
			and for fresh $t$
%			\begin{eqnarray*}
%				\Gamma; \emptyset; \Delta_1'' \proves \newsp{\tilde{s}}{P_2 \Par \context{C}{P \subst{s'}{x}}} \hastype \Proc \\
%				\Gamma; \emptyset; \Delta_2'' \proves \newsp{\tilde{s}}{Q_2 \Par \context{C}{Q \subst{s'}{x}}} \hastype \Proc
%			\end{eqnarray*}
%			then
			\[
				\horel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \hotrigger{t}{\abs{x}{P}}}}
				{\ \mathcal{R}\ }
				{\Delta_2''}{\newsp{\tilde{m_2}}{Q_2 \Par \hotrigger{t}{\abs{x}{Q}}}}
			\]

		\item	$\forall \news{\tilde{m_1}'} \bactout{n}{\tilde{m_1}}$ \dk{with $\Gamma; \es; \Delta \proves m_1 \hastype \tilde{U}$} such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}'} \bactout{n}{\tilde{m_1}}}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2, \tilde{m_2}$ \dk{with $\Gamma; \es; \Delta \proves m_2 \hastype \tilde{U}$} such that
			\[
				\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}'} \bactout{n}{\tilde{m_2}}}}{\Delta_2'}{Q_2}
			\]
			%such that
%			\begin{eqnarray*}
%				\Gamma; \emptyset; \Delta_1'' \proves \newsp{\tilde{s}}{P_2 \Par \context{C}{P \subst{s'}{x}}} \hastype \Proc \\
%				\Gamma; \emptyset; \Delta_2'' \proves \newsp{\tilde{s}}{Q_2 \Par \context{C}{Q \subst{s'}{x}}} \hastype \Proc
%			\end{eqnarray*}
			and for fresh $t$:
			\[
				\horel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \fotrigger{t}{\tilde{U}}{\tilde{m_1}}}}
				{\ \mathcal{R}\ }{\Delta_2''}
				{\newsp{\tilde{m_2}}{Q_2 \Par \fotrigger{t}{\tilde{U}}{\tilde{m_2}}}}
			\]

		\item	$\forall \ell \notin \set{\news{\tilde{m}'} \bactout{n}{m}, \news{\tilde{m}} \bactout{n}{\abs{x}{P}}}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2$ such that 
			\[
				\horel{\Gamma}{\Delta_1}{Q_1}{\Hby{\ell}}{\Delta_1'}{Q_2}
			\]
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \mathcal{R}\ }{\Delta_2'}{Q_2}$

		\item	The symmetric cases of 1, 2 and 3.
	\end{enumerate}
	The Knaster Tarski theorem ensures that the largest bisimulation exists,
	it is called bisimilarity and is denoted by $\wb$.
\end{definition}
\end{comment}

We present a result on process substitution.

\begin{lemma}[Process Substitution]\rm
	\label{lem:proc_subst}
	If 
%
	\begin{enumerate}
		\item	$\horel{\Gamma}{\Delta_1'}{P \subst{\abs{z}{\binp{t}{y} \appl{y}{z}}}{x}}{\wb}{\Delta_2}{Q \subst{\abs{z}{\binp{t}{y} \appl{y}{z}}}{x}}$
			for some fresh $t$.

		\item	$\horel{\Gamma}{\Delta_1''}{P \subst{\abs{z}{\map{U}^{z}}}{x}}{\wb}{\Delta_2''}{Q \subst{\abs{z}{\map{U}^{z}}}{x}}$
			for some $U$.
	\end{enumerate}
%
	then $\forall R$ such that $\fv{R} = z$
\[
	\horel{\Gamma}{\Delta_1}{P \subst{\abs{z}{R}}{x}}{\wb}{\Delta_2}{Q \subst{\abs{z}{R}}{x}}
\]
\end{lemma}

\begin{proof}
	The details of the proof can be found in Appendix~\ref{app:sub_coinc}.
	\qed
\end{proof}

The next theorem justifies our definition choices
for the bisimulation relations, since
they coincide between them and they also
coincide with reduction closed, barbed congruence.

\begin{theorem}[Coincidence]\rm
	\label{the:coincidence}
	Relations $\wb, \wb^f, \wbc$ and $\cong$ coincide.
\end{theorem}

\begin{proof}
	The full details of the proof are in Appendix~\ref{app:sub_coinc}.
	The theorem is split into a hierarchy of Lemmas. 
	Lemma~\ref{lem:wb_eq_wbf} establishes $\wb\ =\ \wbf$.
	Lemma~\ref{lem:wb_is_wbc} exploits the process substitution result
	(Lemma~\ref{lem:proc_subst}) to prove that $\wb \subseteq \wbc$.
	Lemma~\ref{lem:wbc_is_cong} shows that $\wbc$ is a congruence
	which implies $\wbc \subseteq \cong$.
	The final result comes from Lemma~\ref{lem:cong_is_wb} where
	we use label testing to show that $\cong \subseteq \wb$ using
	the technique in developed in~\cite{Hennessy07}. The formulation of input
	triggers in the bisimulation relation allows us to prove
	the latter result without using a matching operator.
	\qed
\end{proof}

Processes that do not use shared names are inherintly $\tau$-inert.

\begin{lemma}[$\tau$-inertness]\rm
	\label{lem:tau_inert}
	Let $P$ an $\HOp^{\minussh}$ process
	and $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$
	\begin{enumerate}
		\item	If $P \red P'$ then $\Gamma; \es; \Delta \wb \Delta' \proves P \wb P'$.
		\item	If $P \red^* P'$ then $\Gamma; \es; \Delta \wb \Delta' \proves P \wb P'$.
	\end{enumerate}
\end{lemma}

\begin{proof}
	The proof is relied on the fact that processes of the
	form $\Gamma; \es; \Delta \proves \bout{s}{V} P_1 \Par \binp{k}{x} P_2$
	cannot have any typed transition observables and the fact
	that bisimulation is a congruence.
	See details in Appendix~\ref{app:sub_tau_inert}.
	\qed
\end{proof}


