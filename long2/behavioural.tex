% !TEX root = main.tex
\section{Behavioural Semantics}
\label{sec:beh_sem}

In this section we define a theory for observational equivalence over
session typed \HOp processes. The theory follows the principles
laid by the previous work of the authors
\cite{DBLP:conf/forte/KouzapasYH11,KY13,dkphdthesis}.
We require a bisimulation relation over typed processes that
is also characterised by the corresponding typed, reduction-closed,
barbed congruence relation.

\dk{(Jorge, I think you have a paper we can cite over session typed bisimulations)}

\subsection{Labelled Transition Semantics}\label{ss:lts}

We define the relation $P_1 \by{\ell} P_2$ over
(untyped) processes, that allows us to follow how a process may
interact with a process in its environment. The interaction
is defined on action $\ell$:
%
\[
	\begin{array}{rcl}
		\ell	& \bnfis  & \tau 
		\bnfbar \news{\tilde{m}} \bactout{n}{V} 
		\bnfbar\bactinp{n}{V} 
		\bnfbar \bactsel{n}{l} 
		\bnfbar \bactbra{n}{l} 
	\end{array}
\]
%
\noi The internal action is defined on label $\tau$.
Action $\news{\tilde{m}} \bactout{n}{V}$ denotes the sending of value $V$ over channel $n$ with
names $\tilde{m}$ being restricted.
Dually the action for the reception of values is 
$\bactinp{n}{V}$.
We also defined actions for selecting a label $l$, $\bactsel{n}{l}$ and branching on a label
$n$, $\bactbra{s}{l}$.

The dual action relation is the symmetric relation $\asymp$, that satisfies the rules:
%
\[
	\bactsel{n}{l} \asymp \bactbra{\dual{n}}{l}
	\qquad
	\news{\tilde{m}'} \bactout{n}{V} \asymp \bactinp{\dual{n}}{V}
\]
%
Dual actions happen on subjects that are dual between them and carry the same
object. Furthermore output action is dual with input action and 
select action is dual with branch action.

\input{figures/fig-unLTS}

{\bf Untyped Labelled Transition System:}
The labelled transition system, LTS, is defined in Figure~\ref{fig:untyped_LTS}.
A process with a send prefix can interact with the environment with a send
action that carries a value $V$ as in rule $\ltsrule{Out}$.
Dually in rule $\ltsrule{In}$
a received prefixed process can observe a receive action of a value $V$.
Select and branch prefixed processes observe the select
and branch actions in rules $\ltsrule{Sel}$ and $\ltsrule{Bra}$ respectively.
Rule $\ltsrule{Res}$ closes the LTS under the name creation
operator provided that the restricted name does not occur free in the observable action.
If a restricted name occurs free in and an output action 
then the name is added as in the bound name list of the action
and the continuation process performs scope opening as described in rule $\ltsrule{Scope}$.
Rules $\ltsrule{LPar}$ and $\ltsrule{RPar}$ close the LTS under the parallel operator 
provided that the observable action does not shared any bound names with the 
parallel processes.
Rule $\ltsrule{Tau}$ states that if two parallel processes can perform dual actions
then the two actions  can synchronise to observe an internal transition. 
Finally rule $\ltsrule{Alpha}$ closes  the LTS under alpha-renaming.

%\subsection{Characteristic Processes}
%We can use a session type to define the a {\em characteristic process}
%which is the simplest process that is typed
%under the given session type.
%
\begin{comment}
\begin{definition}[Characteristic Process]\rm
	\label{def:characteristic_process}
	Let name $u$ and type $U$; then we define a {\em characteristic process}:
	$\mapchar{U}{k}$ as:
%
	\[
	\begin{array}{cc}
		\begin{array}{rclcl}
			\mapchar{\btinp{U} S}{u} &\defeq& \binp{u}{x} (\mapchar{S}{u} \Par \mapchar{U}{x})
			\\
			\mapchar{\btout{U} S}{u} &\defeq& \bout{u}{\omapchar{U}} \mapchar{S}{u} %& & n \textrm{ fresh}
			\\
			\mapchar{\btsel{l : S}}{u} &\defeq& \bsel{u}{l} \mapchar{S}{u}
			\\
			\mapchar{\btbra{l_i: S_i}_{i \in I}}{u} &\defeq& \bbra{u}{l_i: \mapchar{S_i}{u}}_{i \in I}
			\\
			\mapchar{\tvar{t}}{u} &\defeq& \varp{X}_{\vart{t}}
			\\
			\mapchar{\trec{t}{S}}{u} &\defeq& \recp{X_{\vart{t}}}{\mapchar{S}{u}}
			\\
			\mapchar{\tinact}{u} &\defeq& \inact
			\\
		\end{array}
		&
		\begin{array}{rcrclcl}
			&&\mapchar{\chtype{S}}{u} &\defeq& \bout{u}{\omapchar{S}} \inact
			\\
			&&\mapchar{\chtype{L}}{u} &\defeq& \bout{u}{\omapchar{L}} \inact
			\\
			\mapchar{\shot{C}}{x} &\defeq& \mapchar{\lhot{C}}{x} &\defeq& \appl{x}{\omapchar{C}}
			\\
			\\
			&&\omapchar{S} &\defeq& s && s \textrm{ fresh}
			\\
			\omapchar{\chtype{S}} &\defeq& \omapchar{\chtype{L}} &\defeq& a && a \textrm{ fresh}
			\\
			\omapchar{\shot{C}} &\defeq& \omapchar{\lhot{C}} &\defeq& \abs{x}{\mapchar{C}{x}}
		\end{array}
	\end{array}
	\]
\end{definition}
\end{comment}
%
\begin{comment}
\begin{definition}[Characteristic Process]\rm
	\label{def:characteristic_process}
	Let name $u$ and type $C$; then we define a {\em characteristic process}:
	$\map{C}^k$ as:
%
	\[
	\begin{array}{rclcl}
		\map{\btinp{C} S}^{u} &=& \binp{u}{x} (\map{S}^{u} \Par \map{C}^{x})
		\\
		\map{\btout{C} S}^{u} &=& \bout{u}{n} \map{S}^{u} & & n \textrm{ fresh}
		\\
		\map{\btsel{l : S}}^{u} &=& \bsel{u}{l} \map{S}^{u}
		\\
		\map{\btbra{l_i: S_i}_{i \in I}}^{u} &=& \bbra{u}{l_i: \map{S_i}^{u}}_{i \in I}
		\\
		\map{\tvar{t}}^{k} &=& \varp{X}_{\vart{t}}
		\\
		\map{\trec{t}{S}}^{u} &=& \recp{X_{\vart{t}}}{\map{S}^{u}}
		\\
		\map{\btout{\lhot{C}} S}^{u} &=& \bout{u}{\abs{x}{\map{C}^{x}}} \map{S}^u
		\\
		\map{\btinp{\lhot{C}} S}^{u} &=& \binp{u}{x} (\map{S}^u \Par \appl{x}{n}) & & n \textrm{ fresh}
		\\
		\map{\btout{\shot{C}} S}^{u} &=& \bout{u}{\abs{x}{\map{C}^{x}}} \map{S}^u
		\\
		\map{\btinp{\shot{C}} S}^{u} &=& \binp{u}{x} (\map{S}^u \Par \appl{x}{n}) & & n \textrm{ fresh}
		\\

%		\map{\btinp{\chtype{S}} S}^{k} &=& \binp{k}{x} (\map{S}^k \Par \map{\chtype{S}}^y)
%		&&
%		\map{\btout{\chtype{S}} S}^{k} &=& \bout{k}{a} \map{S}^k  & a\textrm{ fresh}
%		\\

		\map{\tinact}^{u} &=& \inact
		\\
		\map{\chtype{S}}^{u} &=& \bout{u}{s} \inact & & s \textrm{ fresh}
		\\
		\map{\chtype{\lhot{C}}}^{u} &=& \bout{u}{\abs{x} \map{C}^{x}} \inact
		\\
		\map{\chtype{\shot{C}}}^{u} &=& \bout{u}{\abs{x} \map{C}^{x}} \inact
	\end{array}
	\]
\end{definition}
\end{comment}

%\begin{proposition}\rm
%$ $
%	\begin{itemize}
%		\item	$\Gamma; \emptyset; \Delta \cat u:S \proves \mapchar{S}{u} \hastype \Proc$
%		\item	$U = \chtype{S}$ or $U = \chtype{L}$ implies $\Gamma \cat u:U; \emptyset; \Delta \proves \mapchar{U}{u} \hastype \Proc$
%	\end{itemize}
%\end{proposition}
%
%\begin{proof}
%	By induction on the definition of $\mapchar{S}{u}$ and $\mapchar{U}{u}$.
%\end{proof}
%
%\begin{corollary}\rm
%	If $\Gamma; \emptyset; \Delta \proves \mapchar{C}{u} \hastype \Proc$
%	then
%	$\Gamma; \es; \Delta \proves u \hastype C$.
%\end{corollary}

\subsection{Typed Labelled Transition System}

\input{figures/fig-envLTS}

We define a relation of the form
$(\Gamma, \Lambda_1, \Delta_1) \by{\ell} (\Gamma, \Lambda_2, \Delta_2)$
over type tuples, that follows the progress of types over
actions $\ell$.

Figure~\ref{fig:envLTS} describes relation $\by{\ell}$.
Rule $\eltsrule{SOut}$ states the conditions for observing action
$\news{\tilde{m}} \bactout{s}{V}$ on a type tuple $(\Gamma, \Lambda, \Delta)$. 
The session environment $\Delta$ of the type tuple should include
a type for $s$ that is prefixed on the output type of type $U$.
Furthermore the dual channel $\dual{s}$ should not be
present in the session environment, since if it was present
the only communication that could take place is the interaction
between the two endpoints.
Under the latter conditions the type tuple may output any
value $V$ that is typed under a subset of $\Delta$ and
the session environment that types the restricted names
$\tilde{m}$. Scope extrusion of session names in $\tilde{m}$ requires
that the dual endpoints of $\tilde{m}$ appear in
the resulting session environment. Similarly for shared names
in $\tilde{m}$ that are extruded.
All free values used for typing $V$ are subtracted from the
resulting type tuple. Also the prefix of session $s$ is consumed
by the action.
Similarly, an output on a shared name is described
with rule $\eltsrule{ShOut}$ where we require a shared name
is typed with $\chtype{U}$. The requirements for
the output $V$ are identical with the requirements for
rule $\eltsrule{SOut}$.
Rules $\eltsrule{SRecv}$ and $\eltsrule{ShRecv}$ describe
the input action $\bactinp{n}{V}$ ($n$ session or shared channel respectively)
on the type tuple $(\Gamma, \Lambda, \Delta)$.
We require the value $V$ has the same type as name $n$. Furthermore
we expect the resulting type tuple to contain the values that
consist value $V$.
Rules $\eltsrule{Sel}$ and $\eltsrule{Bra}$ describe actions for
select and branch. The only requirements for both
rules is that the dual endpoint is not present in the session
environment and furthermore the action labels are present
in the type.
Hidden transitions do not change the session environment
or they follow the reduction on the session
environment (Definition~\ref{def:ses_red}) as we can see in rule
$\eltsrule{Tau}$.

\begin{comment}
A second environment LTS, denoted $\hby{\ell}$,
is defined in the lower part of Figure~\ref{fig:envLTS}.
The definition substitutes rules
$\eltsrule{SRecv}$ and $\eltsrule{ShRecv}$
of relation $\by{\ell}$ with rule $\eltsrule{RRcv}$.
% the corresponding input cases
%of $\by{\ell}$ with the definitions of $\hby{\ell}$.
All other cases remain the same as the cases for
relation $\by{\ell}$.
Rule $\eltsrule{RRcv}$ restricts the higher-order input
in relation $\hby{\ell}$;
only characteristic processes and trigger processes
are allowed to be received on a higher-order input.
Names can still be received as in the definition of
the $\by{\ell}$ relation.
The conditions for input follow the conditions
for the $\by{\ell}$ definition.
\end{comment}

\paragraph{Typed Transition System}

We define a typed labelled transition system over typed processes,
as a combination of the untyped LTS and the LTS for typed environments:

\begin{definition}[Typed Transition System]\label{d:tlts}\rm
	We write
%
%	\begin{enumerate}
%		\item
	$\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_2}{P_2}$
	whenever
	$P_1 \by{\ell} P_2$,
	$(\Gamma, \emptyset, \Delta_1) \by{\ell} (\Gamma, \emptyset, \Delta_2)$
	and $\Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$.

	\noi We extend to $\By{}$ and $\By{\hat{\ell}}$ in the standard way.
%		\item	$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_2}{P_2}$
%			whenever
%			$P_1 \by{\ell} P_2$,
%			$(\Gamma, \emptyset, \Delta_1) \hby{\ell} (\Gamma, \emptyset, \Delta_2)$
%			and
%			$\Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$.
%	\end{enumerate}
%
\end{definition}

%\begin{lemma}[Invariant]\label{l:invariant}
%	If $\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_2}{P_2}$
%	then $\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_2}{P_2}$.
%\end{lemma}

%\begin{proof}
%	The proof is straightforward from the definition of rule $\eltsrule{RRcv}$.
%\end{proof}

\subsection{Behavioural Semantics}

We use the typed labelled transition semantics to define
a set of relations over typed processes that allow us to compare
typed processes over a notion of observational equivalence.

We begin with a definition of a notion of confluence
over session environments $\Delta$:
%
\begin{definition}[Session Environment Confluence]\rm
	We denote $\Delta_1 \bistyp \Delta_2$ whenever $\exists \Delta$ such that
	$\Delta_1 \red^* \Delta$ and $\Delta_2 \red^* \Delta$.
\end{definition}
%
A typed relation is a relation over typed programs:

\begin{definition}[Typed Relation]\rm
	We say that
	$\Gamma; \emptyset; \Delta_1 \proves P_1 \hastype \Proc\ \Re \ \Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$
	is a typed relation whenever:
	i) $P_1$ and $P_2$ are programs;
	ii) $\Delta_1$ and $\Delta_2$ are well typed;
	iii) and $\Delta_1 \bistyp \Delta_2$.

	We write
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{P_2}$
	for $\Gamma; \emptyset; \Delta_1 \proves P_1 \hastype \Proc\ \Re\ \Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$.
\end{definition}

Type relations relate only programs (i.e.\ processes with no free variables) with
well typed session environments and furthermore the two session environments
are confluent.

We define the notions of barb and typed barb.

\begin{definition}[Barbs]\rm
	Let program $P$.
	\begin{enumerate}
		\item	We write $P \barb{n}$ if $P \scong \newsp{\tilde{m}}{\bout{n}{V} P_2 \Par P_3}, n \notin \tilde{m}$.
			We write $P \Barb{n}$ if $P \red^* \barb{n}$.

		\item	We write $\Gamma; \emptyset; \Delta \proves P \barb{n}$ if
			$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ with $P \barb{n}$ and $\dual{n} \notin \Delta$.
			We write $\Gamma; \emptyset; \Delta \proves P \Barb{n}$ if $P \red^* P'$ and
			$\Gamma; \emptyset; \Delta' \proves P' \barb{n}$.			
	\end{enumerate}
\end{definition}

A barb $\barb{n}$ is an observable on an output prefix with subject $n$.
Similarly a weak barb $\Barb{n}$ is a barb after a number of reduction steps.
Typed barbs $\barb{n}$ (resp.\ $\Barb{n}$)
happen on typed processes $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$
where we require that the corresponding dual endpoint $\dual{n}$ is not present
in the session type $\Delta$.

We define the notion of the context:

\begin{definition}[Context]\rm
	A context $\C$ is defined on the grammar:
%
\[
	\begin{array}{rcl}
		\C &\bnfis& \hole \bnfbar \bout{u}{V} \C \bnfbar \bout{u}{\abs{x}{\C}} P \bnfbar \binp{u}{x} \C \\
		& \bnfbar & \news{n} \C \bnfbar \C \Par P \bnfbar \bsel{u}{l} \C \bnfbar \bbra{k}{l_1: P_1, \dots, l_i:\C, \dots, l_n: P_n}
	\end{array}
\]
%
	Notation $\context{\C}{P}$ replaces every $\hole$ in $\C$ with $P$.
\end{definition}

A context is a function that takes a process and returns a new process
according to the above syntax.

The first behavioural relation we define is reduction-closed, barbed congruence:
%
\begin{definition}[Reduction-closed, Barbed Congruence]\rm
	Typed relation
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{P_2}$
	is a barbed congruence whenever:
%
	\begin{enumerate}
		\item
		\begin{itemize}
			\item	If $P_1 \red P_1'$ then $\exists P_2', P_2 \red^* P_1'$ and
				$\horel{\Gamma}{\Delta_1'}{P_1'}{\ \Re\ }{\Delta_2'}{P_2'}$
			\item	If $P_2 \red P_2'$ then $\exists P_1', P_1 \red^* P_1'$ and
				$\horel{\Gamma}{\Delta_1'}{P_1'}{\ \Re\ }{\Delta_2'}{P_2'}$
		\end{itemize}

		\item
		\begin{itemize}
			\item	If $\Gamma;\emptyset;\Delta \proves P_1 \barb{s}$ then $\Gamma;\emptyset;\Delta \proves P_2 \Barb{s}$.
			\item	If $\Gamma;\emptyset;\Delta \proves P_2 \barb{s}$ then $\Gamma;\emptyset;\Delta \proves P_1 \Barb{s}$.
		\end{itemize}

		\item	$\forall \C, \horel{\Gamma}{\Delta_1'}{\context{\C}{P_1}}{\ \Re\ }{\Delta_2'}{\context{\C}{P_2}}$
	\end{enumerate}
%
	The largest such congruence is denoted with $\cong$.
\end{definition}
%
Reduction-closed, barbed congruence is closed under reduction semantics and 
preserves barbs under any context. In a sense no barb observer can distinguish
between two related processes.

The second behavioural relation is contextual bisimulation:
%
\begin{definition}[Contextual Bisimulation]\rm
	\label{def:context_bis}
	Typed relation 
	$\Re$ is a {\em contextual bisimulation} if whenever
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{P_2}$ implies:
	\begin{enumerate}
		\item	$\forall \news{\tilde{m_1}} \bactout{n}{V_1}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\by{\news{\tilde{m_1}} \bactout{n}{V_1}}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2, \abs{x}{Q}$ such that
			\[
				\horel{\Gamma}{\Delta_2}{Q_1}{\By{\news{\tilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}
			\]
			and $\forall R$ with $\set{x} = \fv{R}$, 
			then
			\[
				\horel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par R\subst{V_1}{x}}}
				{\ \Re\ }
				{\Delta_2''}{\newsp{\tilde{m_2}}{Q_2 \Par R\subst{V_2}{x}}}
			\]
%
		\item	$\forall \ell \not= \news{\tilde{m}} \bactout{n}{V}$
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2$ such that
			\[
				\horel{\Gamma}{\Delta_1}{Q_1}{\by{\ell}}{\Delta_2'}{Q_2}
			\]
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re\ }{\Delta_2'}{Q_2}$

		\item	The symmetric cases of 1 and 2.
	\end{enumerate}
%
	The Knaster Tarski theorem ensures that the largest contextual bisimulation exists,
	it is called contextual bisimilarity and is denoted by $\wbc$.
\end{definition}

The contextual bisimulation in the general case
is a hard relation to compute due to:
i) the universal quantifier over contexts in the output case;
and
ii) a higher order input prefix can observe infinitely many
different input actions, since infinitely many different
processes can match the session type of an input prefix.

%the set of higher order input actions
%on an input prefix is infite since infinitely
%many processes can match the session type of
%the input prefix.

%The output action case of the contextual bisimulation
%can be equivalently be defined as:

To handle the universal quantified over processes in the output
case of the contextual bisimulation, consider that
the substitution $R \subst{V}{x}$ can be written up to 
a restricted deterministic transition as:
%The output case for the contextual bisimulation can be equivalently be
%written as:
%
\[
	\newsp{s}{\binp{s}{x} R \Par \bout{\dual{s}}{V} \inact}
\]
%
If we guard the above process with an input prefix
on a fresh name $t$ we can simulate the 
substitution $R \subst{V}{x}$, up to a restricted
deterministic transition, with the input action
$\bactinp{t}{\abs{z}{\binp{z}{x} R}}$:
%
\[
	\horel{\Gamma}{\Delta_1}{\binp{t}{x} \newsp{s}{\appl{x}{s} \Par \bout{\dual{s}}{V} \inact}}
	{\by{\bactinp{t}{\abs{z}{\binp{z}{x} R}}}}
	{\Delta_2}{\newsp{s}{\binp{s}{x} R \Par \bout{\dual{s}}{V} \inact}}
\]
%
Hence, we can replace $R \subst{V}{x}$ in Clause 1
of Definition~\ref{def:context_bis}
with the {\em trigger process}:
%
\[
	\binp{t}{x} \newsp{s}{\appl{x}{s} \Par \bout{\dual{s}}{V} \inact}
\]
%
%Consider an alternative contextual bisimulation definition
%
%Typed relation 
%$\Re$ is a {\em contextual bisimulation} if whenever
%$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{P_2}$ implies:
%\begin{enumerate}
%	\item	$\forall \news{\tilde{m_1}} \bactout{n}{V_1}$ such that
%		\[
%			\horel{\Gamma}{\Delta_1}{P_1}{\by{\news{\tilde{m_1}} \bactout{n}{V_1}}}{\Delta_1'}{P_2}
%		\]
%		implies that $\exists Q_2, \abs{x}{Q}$ such that
%		\[
%			\horel{\Gamma}{\Delta_2}{Q_1}{\By{\news{\tilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}
%		\]
%		for fresh name $t$: %and $\forall R$ with $\set{x} = \fv{R}$, then
%	%
%		\[
%			\mhorel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \hotrigger{t}{x}{s}{V_1}}}
%			{\ \Re\ }
%			{\Delta_2''}{}{\newsp{\tilde{m_2}}{Q_2 \Par \hotrigger{t}{x}{s}{V_2}}}
%		\]
%	%
%	\item	$\forall \ell \not= \news{\tilde{m}} \bactout{n}{V}$
%		\[
%			\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_1'}{P_2}
%		\]
%		implies that $\exists Q_2$ such that
%		\[
%			\horel{\Gamma}{\Delta_1}{Q_1}{\by{\ell}}{\Delta_2'}{Q_2}
%		\]
%		and
%		$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re\ }{\Delta_2'}{Q_2}$
%
%	\item	The symmetric cases of 1 and 2.
%\end{enumerate}
%
%The largest such bisimulation is denoted by $\wb^{\mathsf{altr}}$.
%
%It is very easy to see that $\wbc\ =\ \wb^{\mathsf{altr}}$ because
%
%\begin{eqnarray*}
%	\horel{\Gamma}{\Delta_1}{\newsp{\tilde{m_1}}{P_2 \Par \hotrigger{t}{x}{s}{V_1}}}{\by{ \bactinp{t}{\abs{z}{\binp{z}{x} R}} } \by{\tau}}{\Delta_1'}{\newsp{\tilde{m_1}}{P_2 \Par R\subst{V_1}{x}}}
%	\\
%	\horel{\Gamma}{\Delta_2}{\newsp{\tilde{m_2}}{Q_2 \Par \hotrigger{t}{x}{s}{V_2}}}{\by{ \bactinp{t}{\abs{z}{\binp{z}{x} R}} } \by{\tau}}{\Delta_2'}{\newsp{\tilde{m_1}}{Q_2 \Par R\subst{V_2}{x}}}
%\end{eqnarray*}
%
%The latter definition is equivalent to the output
%case of the contextual bisimulation
%because we can observe an input on a fresh name $t$
%of any abstraction process $\abs{z}{\binp{z}{x} R}$ such that $\set{x} = \fv{R}$.
%
The trigger process allows us to express the
substitution $R \subst{V}{x}$ to an arbitrary process
$R$ as an input prefixed process, by taking
advantage of the fact that actions on an input
prefix allows us to input every process $R$
subject to the substitution $R \subst{V}{x}$.

To define an easy to compute bisimulation we still need to
restrict the input actions that can happen on an input
prefix.
Towards this direction we define the
{\em characteristic process} (resp.~characteristic value)
which is the
{\em simplest} process (resp. value) that can inhabit 
a session type.

As an of example the simplest process that inhabits 
session type $\btinp{\shot{S_1}} \btout{S_2} \tinact$ 
is:
%
\[
	\Gamma; \es; \Delta \cat s_1: S_1 \cat s_2: S_2 \cat u: \btinp{\shot{S_1}} \btout{S_2} \tinact \proves \binp{u}{x} (\bout{u}{s_2} \tinact \Par \appl{x}{s_1})
\]
%
\noi 
We formalise the last intuition in the next definition.
%
\begin{definition}[Characteristic Process]\rm
	\label{def:characteristic_process}
	\noi Let name $u$ and type $U$; then we define the {\em characteristic process}:
	$\mapchar{U}{u}$ and the {\em characteristic value} $\omapchar{U}$ as:
%
	\[
	\begin{array}{cc}
		\begin{array}{rclcl}
			\mapchar{\btinp{U} S}{u} &\defeq& \binp{u}{x} (\mapchar{S}{u} \Par \mapchar{U}{x})
			\\
			\mapchar{\btout{U} S}{u} &\defeq& \bout{u}{\omapchar{U}} \mapchar{S}{u} %& & n \textrm{ fresh}
			\\
			\mapchar{\btsel{l : S}}{u} &\defeq& \bsel{u}{l} \mapchar{S}{u}
			\\
			\mapchar{\btbra{l_i: S_i}_{i \in I}}{u} &\defeq& \bbra{u}{l_i: \mapchar{S_i}{u}}_{i \in I}
			\\
			\mapchar{\tvar{t}}{u} &\defeq& \varp{X}_{\vart{t}}
			\\
			\mapchar{\trec{t}{S}}{u} &\defeq& \recp{X_{\vart{t}}}{\mapchar{S}{u}}
			\\
			\mapchar{\tinact}{u} &\defeq& \inact
			\\
		\end{array}
		&
		\begin{array}{rcrclcl}
			&&\mapchar{\chtype{S}}{u} &\defeq& \bout{u}{\omapchar{S}} \inact
			\\
			&&\mapchar{\chtype{L}}{u} &\defeq& \bout{u}{\omapchar{L}} \inact
			\\
			\mapchar{\shot{C}}{x} &\defeq& \mapchar{\lhot{C}}{x} &\defeq& \appl{x}{\omapchar{C}}
			\\
			\\
			&&\omapchar{S} &\defeq& s && s \textrm{ fresh}
			\\
			\omapchar{\chtype{S}} &\defeq& \omapchar{\chtype{L}} &\defeq& a && a \textrm{ fresh}
			\\
			\omapchar{\shot{C}} &\defeq& \omapchar{\lhot{C}} &\defeq& \abs{x}{\mapchar{C}{x}}
		\end{array}
	\end{array}
	\]
\end{definition}
%

\begin{proposition}\rm
$ $
	\begin{itemize}
		\item	$\Gamma; \emptyset; \Delta \cat u:S \proves \mapchar{S}{u} \hastype \Proc$
		\item	$U = \chtype{S}$ or $U = \chtype{L}$ implies $\Gamma \cat u:U; \emptyset; \Delta \proves \mapchar{U}{u} \hastype \Proc$
		\item	$\Gamma; \es; \Delta \proves \omapchar{U} \hastype U$
	\end{itemize}
\end{proposition}

\begin{proof}
	By induction on the definition of $\mapchar{S}{u}$ and $\mapchar{U}{u}$.
	\qed
\end{proof}

\begin{corollary}\rm
	If $\Gamma; \emptyset; \Delta \proves \mapchar{C}{u} \hastype \Proc$
	then
	$\Gamma; \es; \Delta \proves u \hastype C$.
\end{corollary}

We use a characteristic input value to restrict the input actions that 
can be observed on an input prefix.
%, so we can define
%a bisimulation relation that does not suffer from the observation of 
%of infitely many input actions on the same input prefix.
%
%Following the intuition of characteristic value,
As it turns out, the usage of a characteristic value
alone as an input action for an input prefixed process
is not enough to define a sound bisimulation relation.
%
\begin{example}
	\label{ex:char_proc}
	Consider typed processes:
	%
	\begin{eqnarray*}
		\Gamma; \es; \Delta \cat s: \btinp{\shot{\btinp{C} \tinact}} \tinact &\proves& \binp{s}{x} (\appl{x}{s_1} \Par \appl{x}{s_2})\\
		\Gamma; \es; \Delta \cat s: \btinp{\shot{\btinp{C} \tinact}} \tinact &\proves& \binp{s}{x} (\appl{x}{s_1} \Par \binp{s_2}{y} \inact)
	\end{eqnarray*}
	%
	In the restricted input setting both process can input the
	characteristic value $\abs{x}{\binp{x}{y}} \inact$
	to get
	%
	\begin{eqnarray*}
		\Gamma; \es; \Delta \proves \binp{s_1}{y} \inact \Par \binp{s_2}{y} \inact\\
		\Gamma; \es; \Delta \proves \binp{s_1}{y} \inact \Par \binp{s_2}{y} \inact
	\end{eqnarray*}
	%
	with both process being trivially bisimilar.

	But the former processes are not contextually bisimilar since
	for numerous other input actions they can be distinguished,
	e.g.~for input action $\bactinp{s}{\abs{x} \bout{a}{s_3} \btinp{x}{y} \inact}$.
\end{example}

Allowing the characteristic value as the only input action
that can be observed on an input prefix,
results in an over-discriminating bisimulation.
To solve this problem we introduce the {\em trigger value}.
%that can be observed as the object of an input action.
An trigger value is an abstraction 
prefix on a fresh trigger name $t$ that has the form:
\[
	\Gamma; \es; \Delta \proves \abs{z}{\binp{t}{x} \appl{x}{z}} \hastype U
\]
where $U = \shot{C}$ or $U = \lhot{C}$.

The input trigger can distinguish the processes in Example~\ref{ex:char_proc};
if the input trigger is received (observe action $\bactinp{s}{\abs{z}{\binp{t}{x} \appl{x}{z}}}$)
by both processes in Example~\ref{ex:char_proc} we get processes:
%
\begin{eqnarray*}
	\Gamma; \es; \Delta &\proves& \binp{t}{x} \appl{x}{s_1} \Par \binp{t}{x} \appl{x}{s_2}
	\\
	\Gamma; \es; \Delta &\proves& \binp{t}{x} \appl{x}{s_1} \Par \binp{s_2}{y} \inact
\end{eqnarray*}
%
\noi that can be distinguished by the freshness of name $t$.

One question that arises here is whether the trigger value is enough
to distinguish two processes so that there is no need for a
characteristic value. This is not true since the trigger value
alone also results in an over-discriminating bisimulation relation.
%In fact the trigger can be observed on any input prefix
%of any type.
For example processes:
%
\begin{eqnarray*}
	\Gamma; \es; \Delta \proves \newsp{s}{\binp{n}{x} \appl{x}{s} \Par \bout{\dual{s}}{\abs{x} P} \inact} \hastype \Proc
	\\
	\Gamma; \es; \Delta \proves \newsp{s}{\binp{n}{x} \appl{x}{s} \Par \bout{\dual{s}}{\abs{x} Q} \inact} \hastype \Proc
\end{eqnarray*}
%
\noi can both observe trigger value input and get
%
\begin{eqnarray*}
	\Gamma; \es; \Delta \proves \newsp{s}{\binp{t}{x} \appl{x}{s} \Par \bout{\dual{s}}{\abs{x} P} \inact} \hastype \Proc
	\\
	\Gamma; \es; \Delta \proves \newsp{s}{\binp{t}{x} \appl{x}{s} \Par \bout{\dual{s}}{\abs{x} Q} \inact} \hastype \Proc
\end{eqnarray*}
%
\noi thus it is shown that they are bisimilar.
For input action $\bactinp{s}{\abs{z}{\binp{z}{x} \appl{x}{m}}}$
though, the resulting processes:
\begin{eqnarray*}
	\Gamma; \es; \Delta \proves \newsp{s}{\binp{s}{x} \appl{x}{m} \Par \bout{\dual{s}}{\abs{x} P} \inact} \by{\tau} \Delta \proves P \subst{m}{x}
	\\
	\Gamma; \es; \Delta \proves \newsp{s}{\binp{s}{x} \appl{x}{m} \Par \bout{\dual{s}}{\abs{x} Q} \inact} \by{\tau} \Delta \proves Q \subst{m}{x}
\end{eqnarray*}
\noi are not bisimilar if $P \subst{m}{x}$ is not bisimilar with $Q \subst{m}{x}$.

We formalise the restricted input action with the definition of a
new environment transition relation
%
\[
	(\Gamma, \Lambda_1, \Delta_1) \hby{\ell} (\Gamma, \Lambda_2, \Delta_2)
\]
%
\noi which is defined using the $\by{\ell}$ relation.
The definition uses the same rules for defining the $\by{\ell}$ relation,
but it requires the substitution of rules $\eltsrule{SRv}$ and
$\eltsrule{ShRv}$ with the rule:
%
\[
	\eltsrule{RRv}~~\tree {
		(\Gamma_1; \Lambda_1; \Delta_1) \by{\bactinp{n}{V}} (\Gamma_2; \Lambda_2; \Delta_2)
		\quad
		\begin{array}{crcl}
			& (V & = & \abs{x}{\binp{t}{X} \appl{X}{x}} \wedge t \textrm{ fresh}) \\
			\vee & (V & = &  \abs{x}{P} \wedge P \scong \mapchar{U}{x}) \vee V = m
		\end{array}
	}{
		(\Gamma_1; \Lambda_1; \Delta_1) \hby{\bactinp{n}{V}} (\Gamma_2; \Lambda_1; \Delta_2)
	}
\]
%
\noi The new receive rule is defined on rules
$\eltsrule{SRv}$ and $\eltsrule{ShRv}$. It
allows only a characteristic value (fresh name or abstraction)
or a trigger input on a fresh name $t$ as a higher order input.
%Input of names remains as defined in the rules 
%$\eltsrule{SRv}$ and $\eltsrule{ShRv}$.
%Rule $\eltsrule{RRcv}$ restricts the higher-order input
%in relation $\hby{\ell}$;
%only characteristic processes and trigger processes
%are allowed to be received on a higher-order input.
Non fresh names can still be received as in the definition of
the $\by{\ell}$ relation.
%The conditions for input follow the conditions
%for the $\by{\ell}$ definition.
All other cases of the $\hby{\ell}$ definition 
remain the same as the cases for relation $\by{\ell}$.

The new typed relation derived from the $\hby{\ell}$ environment LTS is
defined as:
%
\begin{definition}[Restricted Typed Transition]\rm
	We write
%
	$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_2}{P_2}$
	whenever
	$P_1 \by{\ell} P_2$,
	$(\Gamma, \emptyset, \Delta_1) \hby{\ell} (\Gamma, \emptyset, \Delta_2)$
	and
	$\Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$.

	\noi We extend to $\Hby{}$ and $\Hby{\hat{\ell}}$ in the standard way.
\end{definition}

\begin{lemma}[Invariant]\label{l:invariant}
	If $\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_2}{P_2}$
	then $\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_2}{P_2}$.
\end{lemma}

\begin{proof}
	The proof is straightforward from the definition of rule $\eltsrule{RRv}$.
\end{proof}

As we discussed previously it is convenient to define
the output action case of the bisimulation using the
trigger process:
%
\[
	\hotrigger{t}{x}{s}{V}
\]
%
\noi for substituting value $\Gamma; \es; \Delta \proves V \hastype U$
over an observer context.
An alternative trigger that uses a first-order input prefix,
can be defined, which is parametrised on the type $U$ of $V$:
%
\[
	\fotrigger{t}{x}{s}{\btinp{U} \inact}{V}
\]
%
Both triggers reduce in a deterministic way under
typed transition $\hby{\ell}$, due to the
freshness of $t$ and the restricted session $s$. Furthermore
both trigger transitions result in the process
$\mapchar{U}{x} \subst{V}{x}$.

The next definition formalises the idea of the trigger process.
%
\begin{definition}[Trigger Process]\rm
	Let $\Gamma; \es; \Delta \proves V \hastype U$.
	We write $\trigger{t}{V}{U}$ for either:
%
	\begin{center}
		\begin{tabular}{lclcl}
			Higher order trigger & & $\htrigger{t}{V}$ &$=$& $\hotrigger{t}{x}{s}{V}$ or\\
			First order trigger & & $\ftrigger{t}{V}{U}$ &$=$& $\fotrigger{t}{x}{s}{\btinp{U} \tinact}{V}$
		\end{tabular}
	\end{center}
\end{definition}

We are now ready to define a bisimulation relation which is not
contextual.

\begin{definition}[Triggered Bisimulation]\rm
	\label{def:bisim}
	Typed relation
	$\Re$ is a {\em triggered bisimulation} if for a trigger $\trigger{t}{V}{U}$, whenever
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{Q_1}$ implies:
%
	\begin{enumerate}
		\item	$\forall \news{\tilde{m_1}} \bactout{n}{V_1}$ with $\dk{\Gamma; \es; \Delta \proves V_1 \hastype U}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}} \bactout{n}{V_1}}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2, V_2$ with $\dk{\Gamma; \es; \Delta \proves V_2 \hastype U}$ such that
			\[
				\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}
			\]
			and for fresh $t$
			\[
				\horel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \trigger{t}{V_1}{U}}}
				{\ \Re\ }
				{\Delta_2''}{}{\newsp{\tilde{m_2}}{Q_2 \Par \trigger{t}{V_2}{U}}}
			\]
%
		\item	$\forall \ell \not= \news{\tilde{m}} \bactout{n}{V}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2$ such that 
			\[
				\horel{\Gamma}{\Delta_1}{Q_1}{\Hby{\ell}}{\Delta_2'}{Q_2}
			\]
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re\ }{\Delta_2'}{Q_2}$

		\item	The symmetric cases of 1 and 2.
	\end{enumerate}
	The Knaster Tarski theorem ensures that the largest triggered bisimulation exists,
	it is called triggered bisimilarity and is denoted by $\wb^{\triggerarrow}$.
\end{definition}

We instantiate higher-order bisimilarity with $\wb^{\htriggerarrow}$ and
first--order bisimilarity with $\wb^{\htriggerarrow}$.

%The contextual bisimulation in the general case is a hard relation to be computed
%since it is universaly quantified over substituting processes. The next definition
%of a bisimulation relation avoids the universal quantifier over processes.

\begin{comment}
\begin{definition}[Higher-Order Bisimulation]\rm
	\label{def:HO_bisim}
	Typed relation
	$\Re$ is a {\em HO-bisimulation} if whenever
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{Q_1}$ implies:
%
	\begin{enumerate}
		\item	$\forall \news{\tilde{m_1}} \bactout{n}{V_1}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}} \bactout{n}{V_1}}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2, V_2$ such that
			\[
				\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}
			\]
			and for fresh $t$:
			\[
				\mhorel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \hotrigger{t}{x}{s}{V_1}}}
				{\ \Re\ }
				{\Delta_2''}{}{\newsp{\tilde{m_2}}{Q_2 \Par \hotrigger{t}{x}{s}{V_2}}}
			\]
%
		\item	$\forall \ell \not= \news{\tilde{m}} \bactout{n}{V}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2$ such that 
			\[
				\horel{\Gamma}{\Delta_1}{Q_1}{\Hby{\ell}}{\Delta_2'}{Q_2}
			\]
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re\ }{\Delta_2'}{Q_2}$

		\item	The symmetric cases of 1 and 2.
	\end{enumerate}
	The Knaster Tarski theorem ensures that the largest bisimulation exists,
	it is called HO-bisimilarity and is denoted by $\wb$.
\end{definition}

Higher-Order Bisimulation uses higher order input guarded triggers, thus
it cannot be used as an equivalence relation for the \sessp sub-calculus.
An alternative definition of the bisimulation based on first order
output triggers solves this problem.

\begin{definition}[First-Order Bisimulation]\rm
	\label{def:FO_bisim}
	Typed relation 
	$\Re$ is a {\em FO-bisimulation} if whenever
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \mathcal{R}\ }{\Delta_2}{Q_1}$ implies:
	\begin{enumerate}
		\item	$\forall \news{\tilde{m_1}} \bactout{n}{V_1}$ with $\Gamma; \es; \Delta \proves V_1 \hastype U$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}} \bactout{n}{V_1}}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2, V_2$ with $\Gamma; \es; \Delta \proves V_2 \hastype U$ such that
			\[
				\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}
			\]
			and for fresh $t$
			\[
				\mhorel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \fotrigger{t}{x}{s}{\btinp{U} \inact}{V_1}}}
				{\ \Re\ }
				{\Delta_2''}{}{\newsp{\tilde{m_2}}{Q_2 \Par \fotrigger{t}{x}{s}{\btinp{U} \inact}{V_2}}}
			\]
%
		\item	$\forall \ell \not= \news{\tilde{m}} \bactout{n}{V}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2$ such that 
			\[
				\horel{\Gamma}{\Delta_1}{Q_1}{\Hby{\ell}}{\Delta_2'}{Q_2}
			\]
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re\ }{\Delta_2'}{Q_2}$

		\item	The symmetric cases of 1 and 2.
	\end{enumerate}
	The Knaster Tarski theorem ensures that the largest bisimulation exists,
	it is called bisimilarity and is denoted by $\wbf$.
\end{definition}
\end{comment}

\begin{comment}
\begin{definition}[Bisimulation]\label{d:bisim}\rm
	Let typed relation $\mathcal{R}$ such that
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \mathcal{R}\ }{\Delta_2}{Q_1}$.
	$\mathcal{R}$ is a {\em bisimulation} whenever:
	\begin{enumerate}
		\item	$\forall \news{\tilde{m_1}} \bactout{n}{\abs{\tilde{x}}{P}}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}} \bactout{n}{\abs{\tilde{x}}{P}}}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2, \abs{\tilde{x}}{Q}$ such that
			\[
				\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}} \bactout{n}{\abs{\tilde{x}}{Q}}}}{\Delta_2'}{Q_2}
			\]
			and for fresh $t$
%			\begin{eqnarray*}
%				\Gamma; \emptyset; \Delta_1'' \proves \newsp{\tilde{s}}{P_2 \Par \context{C}{P \subst{s'}{x}}} \hastype \Proc \\
%				\Gamma; \emptyset; \Delta_2'' \proves \newsp{\tilde{s}}{Q_2 \Par \context{C}{Q \subst{s'}{x}}} \hastype \Proc
%			\end{eqnarray*}
%			then
			\[
				\horel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \hotrigger{t}{\abs{x}{P}}}}
				{\ \mathcal{R}\ }
				{\Delta_2''}{\newsp{\tilde{m_2}}{Q_2 \Par \hotrigger{t}{\abs{x}{Q}}}}
			\]

		\item	$\forall \news{\tilde{m_1}'} \bactout{n}{\tilde{m_1}}$ \dk{with $\Gamma; \es; \Delta \proves m_1 \hastype \tilde{U}$} such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}'} \bactout{n}{\tilde{m_1}}}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2, \tilde{m_2}$ \dk{with $\Gamma; \es; \Delta \proves m_2 \hastype \tilde{U}$} such that
			\[
				\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}'} \bactout{n}{\tilde{m_2}}}}{\Delta_2'}{Q_2}
			\]
			%such that
%			\begin{eqnarray*}
%				\Gamma; \emptyset; \Delta_1'' \proves \newsp{\tilde{s}}{P_2 \Par \context{C}{P \subst{s'}{x}}} \hastype \Proc \\
%				\Gamma; \emptyset; \Delta_2'' \proves \newsp{\tilde{s}}{Q_2 \Par \context{C}{Q \subst{s'}{x}}} \hastype \Proc
%			\end{eqnarray*}
			and for fresh $t$:
			\[
				\horel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \fotrigger{t}{\tilde{U}}{\tilde{m_1}}}}
				{\ \mathcal{R}\ }{\Delta_2''}
				{\newsp{\tilde{m_2}}{Q_2 \Par \fotrigger{t}{\tilde{U}}{\tilde{m_2}}}}
			\]

		\item	$\forall \ell \notin \set{\news{\tilde{m}'} \bactout{n}{m}, \news{\tilde{m}} \bactout{n}{\abs{x}{P}}}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2$ such that 
			\[
				\horel{\Gamma}{\Delta_1}{Q_1}{\Hby{\ell}}{\Delta_1'}{Q_2}
			\]
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \mathcal{R}\ }{\Delta_2'}{Q_2}$

		\item	The symmetric cases of 1, 2 and 3.
	\end{enumerate}
	The Knaster Tarski theorem ensures that the largest bisimulation exists,
	it is called bisimilarity and is denoted by $\wb$.
\end{definition}
\end{comment}

The next result clarifies our choice of restricting
the higher order input action with the input trigger and
the characteristic process; if under the substitution
of the characteristic abstraction and the trigger
input two processes remain bisimilar then they
are bisimilar under any abstraction substitution.

\begin{lemma}[Process Substitution]\rm
	\label{lem:proc_subst}
	If 
%
	\begin{enumerate}
		\item	$\horel{\Gamma}{\Delta_1'}{P \subst{\abs{z}{\binp{t}{y} \appl{y}{z}}}{x}}{\wb}{\Delta_2}{Q \subst{\abs{z}{\binp{t}{y} \appl{y}{z}}}{x}}$
			for some fresh $t$.

		\item	$\horel{\Gamma}{\Delta_1''}{P \subst{\abs{z}{\mapchar{U}{z}}}{x}}{\wb}{\Delta_2''}{Q \subst{\abs{z}{\mapchar{U}{z}}}{x}}$
			for some $U$.
	\end{enumerate}
%
	then $\forall R$ such that $\fv{R} = z$
\[
	\horel{\Gamma}{\Delta_1}{P \subst{\abs{z}{R}}{x}}{\wb}{\Delta_2}{Q \subst{\abs{z}{R}}{x}}
\]
\end{lemma}

\begin{proof}
	The details of the proof can be found in Appendix~\ref{app:sub_coinc}.
	\qed
\end{proof}

The next theorem justifies our definition choices
for the bisimulation relations, since
they coincide between them and they also
coincide with reduction closed, barbed congruence.

\begin{theorem}[Coincidence]\rm
	\label{the:coincidence}
	Relations $\wb, \wb^f, \wbc$ and $\cong$ coincide.
\end{theorem}

\begin{proof}
	The full details of the proof are in Appendix~\ref{app:sub_coinc}.
	The theorem is split into a hierarchy of Lemmas. 
	Lemma~\ref{lem:wb_eq_wbf} establishes $\wb\ =\ \wbf$.
	Lemma~\ref{lem:wb_is_wbc} exploits the process substitution result
	(Lemma~\ref{lem:proc_subst}) to prove that $\wb \subseteq \wbc$.
	Lemma~\ref{lem:wbc_is_cong} shows that $\wbc$ is a congruence
	which implies $\wbc \subseteq \cong$.
	The final result comes from Lemma~\ref{lem:cong_is_wb} where
	we use label testing to show that $\cong \subseteq \wb$ using
	the technique in developed in~\cite{Hennessy07}. The formulation of input
	triggers in the bisimulation relation allows us to prove
	the latter result without using a matching operator.
	\qed
\end{proof}

%\begin{definition}[Session Transition]\rm
%	Let well-typed \HOp process $\Gamma; \es; \Delta \proves P \hastype \Proc$.
%	We write {\em session transition} 
%	$\horel{\Gamma}{\Delta}{P}{\shby{\ell}}{\Delta'}{P'}$ if
%	$\horel{\Gamma}{\Delta}{P}{\hby{\ell}}{\Delta'}{P'}$
%	is derived by not using the environment label transition rules $\eltsrule{ShOut}$
%	and $\eltsrule{ShRv}$.
%\end{definition}
%
%\begin{lemma}[$\tau$-inertness]\rm
%	\label{lem:tau_inert}
%	Let $\Gamma; \es; \Delta \proves P \hastype \Proc$.
%	$\horel{\Gamma}{\Delta}{P}{\shby{\ell}}{\Delta'}{P'}$
%	implies
%	$\horel{\Gamma}{\Delta}{P}{\wb}{\Delta'}{P'}$
%\end{lemma}

\begin{definition}[Session Transition]\rm
	Let balanced \HOp process $\Gamma; \es; \Delta \proves P \hastype \Proc$.
	We say that transition
	$\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ is
	a {\em session transition}, written
	$\horel{\Gamma}{\Delta}{P}{\shby{\tau}}{\Delta'}{P'}$,
	whenever the untyped transition $P \by{\tau} P'$
	is derived on visible actions with a session subject.
\end{definition}

\begin{proposition}[$\tau$-inertness]\rm
	\label{lem:tau_inert}
	Let balanced \HOp process $\Gamma; \es; \Delta \proves P \hastype \Proc$.
	$\horel{\Gamma}{\Delta}{P}{\shby{\tau}}{\Delta'}{P'}$ implies
	$\horel{\Gamma}{\Delta}{P}{\wb}{\Delta'}{P'}$.
\end{proposition}

\begin{proof}
	The proof is relied on the fact that processes of the
	form $\Gamma; \es; \Delta \proves \bout{s}{V} P_1 \Par \binp{k}{x} P_2$
	cannot have any typed transition observables and the fact
	that bisimulation is a congruence.
	See details in Appendix~\ref{app:sub_tau_inert}.
	\qed
\end{proof}

Processes that do not use shared names are inherently $\tau$-inert.

\begin{corollary}[$\mathsf{C}^{\minussh}$ $\tau$-inertness]\rm
	\label{cor:tau_inert}
	Let $\Gamma; \es; \Delta \proves P \hastype \Proc$ an $\mathsf{C}^{\minussh}$ process.
%
	\begin{itemize}
		\item	$\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ if and only if $\horel{\Gamma}{\Delta}{P}{\shby{\tau}}{\Delta'}{P'}$.
		\item	$\horel{\Gamma}{\Delta}{P}{\shby{\tau}}{\Delta'}{P'}$ implies $\horel{\Gamma}{\Delta}{P}{\wb}{\Delta'}{P'}$.
	\end{itemize}
%	\begin{enumerate}
%		\item
%	If $\horel{\Gamma}{\Delta}{P}{\by{\tau}}{\Delta'}{P'}$ then $\horel{\Gamma}{\Delta}{P}{\wb}{\Delta'}{P'}$.
%		\item	If $P \red^* P'$ then $\Gamma; \es; \Delta \wb \Delta' \proves P \wb P'$.
%	\end{enumerate}
\end{corollary}

\begin{lemma}[Up-to Session Transition]\rm
	\label{lem:up_to_session_transition}
	Let $\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2'}{Q_1}$ such
	that if whenever:
%
	\begin{enumerate}
		\item	$\forall \news{\tilde{m_1}} \bactout{n}{V_1}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}} \bactout{n}{V_1}}}{\Delta_3}{P_3}
			\]
			implies that $\exists Q_2, V_2$ such that
			\[
				\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}
			\]
			and
			\[
				\horel{\Gamma}{\Delta_3}{P_3}{\SHby{}}{\Delta_1'}{P_2}
			\]
			and for fresh $t$:
			\[
				\horel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \htrigger{t}{V_1}}}
				{\ \Re\ }
				{\Delta_2''}{}{\newsp{\tilde{m_2}}{Q_2 \Par \htrigger{t}{V_2}}}
%				\mhorel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \hotrigger{t}{x}{s}{V_1}}}
%				{\ \Re\ }
%				{\Delta_2''}{}{\newsp{\tilde{m_2}}{Q_2 \Par \hotrigger{t}{x}{s}{V_2}}}
			\]
%
		\item	$\forall \ell \not= \news{\tilde{m}} \bactout{n}{V}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_3}{P_3}
			\]
			implies that $\exists Q_2$ such that 
			\[
				\horel{\Gamma}{\Delta_1}{Q_1}{\Hby{\ell}}{\Delta_2'}{Q_2}
			\]
			and
			\[
				\horel{\Gamma}{\Delta_3}{P_3}{\SHby{}}{\Delta_1'}{P_2}
			\]
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re\ }{\Delta_2'}{Q_2}$

		\item	The symmetric cases of 1 and 2.
	\end{enumerate}
	Then $\Re\ \subseteq\ \wb$.
\end{lemma}


\begin{proof}
	The proof is very easy if we consider the
	closure
	\[
		\Re^{\SHby{}} = \set{ \horel{\Gamma}{\Delta_1'}{P_2}{,}{\Delta_2'}{Q_1} \setbar \horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2'}{Q_1},
		\horel{\Gamma}{\Delta_1}{P_1}{\SHby{}}{\Delta_1'}{P_2} }
	\]
	We verify that $\Re^{\SHby{}}$ is a bisimulation with
	the use of Proposition~\ref{lem:tau_inert}.
	\qed
\end{proof}
