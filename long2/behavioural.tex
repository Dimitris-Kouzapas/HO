% !TEX root = main.tex
\section{Behavioural Semantics}
\label{sec:beh_sem}
\label{sec:behavioural}

\noi We develop a theory for observational equivalence over
session typed \HOp processes.
The theory follows the principles laid by the previous
work of the authors \cite{KYHH2015,KY2015,dkphdthesis}.
We introduce three different bisimilarities and prove
that
all of them coincide with typed, reduction-closed,
barbed congruence. 

\subsection{Labelled Transition Semantics}
\label{subsec:lts}

\myparagraph{Labels.}
We define an (early) typed labelled transition system
$P_1 \by{\ell} P_2$ (LTS for short) over
untyped processes.
Later on, using the \emph{environmental} transition semantics, 
we can define a typed transition relation to formalise 
how a process interacts with a process in its environment.
The interaction
is defined on action $\ell$:
%
\[
	\begin{array}{rcl}
		\ell	& \bnfis  & \tau 
		\bnfbar \news{\tilde{m}} \bactout{n}{V} 
		\bnfbar\bactinp{n}{V} 
		\bnfbar \bactsel{n}{l} 
		\bnfbar \bactbra{n}{l} 
	\end{array}
\]
%
\noi The internal action is defined by label $\tau$.
Output action $\news{\tilde{m}} \bactout{n}{V}$ denotes the output of value
$V$ over name $n$ with a possibly empty set of names $\tilde{m}$
being restricted (we may write $\bactout{n}{V}$  when $\tilde{m}$ is empty).
Dually, the action for the value input is $\bactinp{n}{V}$.
We also defined actions for selecting a label
$l$, $\bactsel{n}{l}$ and branching on a label
$n$, $\bactbra{s}{l}$.
$\fn{\ell}$ and $\bn{\ell}$ denote 
sets of free/bound names in $\ell$, resp.

The dual action relation is the symmetric relation $\asymp$, that satisfies the rules:
%
\[
	\bactsel{n}{l} \asymp \bactbra{\dual{n}}{l}
	\qquad
	\news{\tilde{m}'} \bactout{n}{V} \asymp \bactinp{\dual{n}}{V}
\]
%
Dual actions, occur on subjects that are dual between
them and carry the same object. Thus,
output action is dual with input action and 
select action is dual with branch action.

\input{figures/fig-unLTS}

\myparagraph{LTS over Untyped Processes}
The labelled transition system (LTS) over untyped processes
is defined in \figref{fig:untyped_LTS}.
We write $P_1 \by{\ell} P_2$ with the usual meaning.
The rules are standard~\cite{KYHH2015,KY2015}.
An application requires an extra silent step $\tau$ to substitute
the application name over the application abstraction as defined
in rule $\ltsrule{App}$.
A process with a send prefix can interact with the environment with a send
action that carries a value $V$ as in rule $\ltsrule{Out}$.
Dually, in rule $\ltsrule{In}$
a received prefixed process can observe a receive action of a value $V$.
Select and branch prefixed processes observe the select
and branch actions in rules $\ltsrule{Sel}$ and $\ltsrule{Bra}$, respectively,
and proceed according to the labels observed.
Rule $\ltsrule{Res}$ closes the LTS under the name creation
operator provided that the restricted name does not occur free in the observable action.
If a restricted name occurs free in an output action 
then the name is added as in the bound name list of the action
and the continuation process performs scope opening as described in rule $\ltsrule{Scope}$.
Rules $\ltsrule{LPar}$ and $\ltsrule{RPar}$ close the LTS under the parallel operator 
provided that the observable action does not shared any bound names with the 
parallel processes.
Rule $\ltsrule{Tau}$ states that if two parallel processes can perform dual actions
then the two actions  can synchronise to observe an internal transition. 
Finally, rule $\ltsrule{Alpha}$ closes  the LTS under alpha-renaming 
and rule $\ltsrule{Rec}$ handles recursion unfolding.

\subsection{Environmental Labelled Transition System}

\input{figures/fig-envLTS}

\label{ss:elts}
\noi 
\figref{fig:envLTS}
defines a labelled transition relation between 
a triple of environments, 
denoted
$(\Gamma, \Lambda_1, \Delta_1) \by{\ell} (\Gamma, \Lambda_2, \Delta_2)$.
It extends the transition systems
in \cite{KYHH2015,KY2015} 
to higher-order sessions. 

\myparagraph{Input Actions} 
are defined by 
$\eltsrule{SRv}$ and $\eltsrule{ShRv}$
%describe the input action
($n$ session or shared name respectively $\bactinp{n}{V}$). 
We require the value $V$ has
the same type as name $s$ and $a$, respectively.  Furthermore we
expect the resulting type tuple to contain the values that consist
with value $V$. The condition $\dual{s} \notin \dom{\Delta}$
in $\eltsrule{SRv}$ ensures that 
the dual name $\dual{s}$ should not be
present in the session environment, since if it were present
the only communication that could take place is the interaction
between the two endpoints (using $\eltsrule{Tau}$ below).

\myparagraph{Output Actions} are defined by $\eltsrule{SSnd}$
and $\eltsrule{ShSnd}$.  
Rule $\eltsrule{SSnd}$ states the conditions for observing action
$\news{\tilde{m}} \bactout{s}{V}$ on a type tuple 
$(\Gamma, \Lambda, \Delta \cdot s: S)$. 
The session environment $\Delta$ with $s: S$ 
should include the session environment of sent value $V$, 
{\em excluding} the session environments of the name $n_j$ 
in $\tilde{m}$ which restrict the scope of value $V$. 
Similarly the linear variable environment 
$\Lambda'$ of $V$ should be included in $\Lambda$. 
Scope extrusion of session names in $\tilde{m}$ requires
that the dual endpoints of $\tilde{m}$ appear in
the resulting session environment. Similarly for shared 
names in $\tilde{m}$ that are extruded.  
All free values used for typing $V$ are subtracted from the
resulting type tuple. The prefix of session $s$ is consumed
by the action.
Similarly, an output on a shared name is described
by rule $\eltsrule{ShSnd}$ where we require that the name
is typed with $\chtype{U}$. Conditions for
the output $V$ are identical to those
% the requirements 
for rule~$\eltsrule{SSnd}$.
We sometimes annotate the output action 
$\news{\tilde{m}} \bactout{n}{V}$
with the type of $V$ as $\news{\tilde{m}} \bactout{n}{V:U}$.

\myparagraph{Other Actions}
Rules $\eltsrule{Sel}$ and $\eltsrule{Bra}$ describe actions for
select and branch. The only requirements for both
rules is that the dual endpoint is not present in the session
environment and the action labels are present
in the type.
Hidden transitions defined by rule $\eltsrule{Tau}$ 
do not change the session environment or they follow the reduction on session
environments (\defref{def:ses_red}). 


\begin{comment}
\figref{fig:envLTS} describes we define 
the environemnt labelled transition relation that
follows the progress of types over actions $\ell$ and has form
$(\Gamma, \Lambda_1, \Delta_1) \by{\ell} (\Gamma, \Lambda_2, \Delta_2)$.

Rule $\eltsrule{SOut}$ states the conditions for observing action
$\news{\tilde{m}} \bactout{s}{V}$ on a type tuple $(\Gamma, \Lambda, \Delta)$:
i) the session environment $\Delta$ of the type tuple should include
a type for $s$ that is prefixed on the output type of type $U$;
ii) the dual channel $\dual{s}$ should not be
present in the session environment, since if it was present
the only communication that could take place is the interaction
between the two endpoints;
iii) the type tuple may output any
value $V$ that is typed under a subset of $\Delta$ and
the session environment that types the restricted names
$\tilde{m}$;
iv) scope extrusion of session names in $\tilde{m}$ requires
the dual endpoints of $\tilde{m}$ to appear in
the resulting session environment (shared names in
$\tilde{m}$ are extruded in a similar manner);
v) all free values used for typing $V$ are subtracted from the
resulting type tuple; and
vi) the prefix of session type of channel $s$ is consumed by the action.
Similarly, rule $\eltsrule{ShOut}$ describes an output on a shared name,
where we require a shared name with value $\chtype{U}$.
The requirements for the observation of action
$\news{\tilde{m}} \bactout{a}{V}$ are identical with the requirements for
rule $\eltsrule{SOut}$.
Rules $\eltsrule{SRecv}$ and $\eltsrule{ShRecv}$ describe
the input action $\bactinp{n}{V}$ ($n$ is a session or a shared channel, respectively)
on the type tuple $(\Gamma, \Lambda, \Delta)$.
We require the value $V$ has the same type as the type in name $n$.
Furthermore,
we expect the resulting type tuple to contain the type of the
values that consist value $V$.
Rules $\eltsrule{Sel}$ and $\eltsrule{Bra}$ describe actions for
select and branch. The only requirements for both
rules is that the dual endpoint is not present in the session
environment and furthermore the action labels are present
in the type.
Hidden transitions do not change the session environment
or they follow the reduction on the session
environment (\defref{def:ses_red}) as we can see in rule
$\eltsrule{Tau}$.
\end{comment}

\begin{comment}
A second environment LTS, denoted $\hby{\ell}$,
is defined in the lower part of \figref{fig:envLTS}.
The definition substitutes rules
$\eltsrule{SRecv}$ and $\eltsrule{ShRecv}$
of relation $\by{\ell}$ with rule $\eltsrule{RRcv}$.
% the corresponding input cases
%of $\by{\ell}$ with the definitions of $\hby{\ell}$.
All other cases remain the same as the cases for
relation $\by{\ell}$.
Rule $\eltsrule{RRcv}$ restricts the higher-order input
in relation $\hby{\ell}$;
only characteristic processes and trigger processes
are allowed to be received on a higher-order input.
Names can still be received as in the definition of
the $\by{\ell}$ relation.
The conditions for input follow the conditions
for the $\by{\ell}$ definition.
\end{comment}

\myparagraph{Typed Transition System}
We define a typed labelled transition system over typed processes,
as a combination of the untyped LTS and the LTS for typed environments:

\begin{definition}[Typed Transition System]\label{d:tlts}\rm
	\label{def:typed_transition}
	We write
	$\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_2}{P_2}$
	whenever
	$P_1 \by{\ell} P_2$,
	$(\Gamma, \emptyset, \Delta_1) \by{\ell} (\Gamma, \emptyset, \Delta_2)$
	and $\Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$.

	We extend to $\By{}$ 
	and $\By{\hat{\ell}}$ 
	where we write 
	$\By{}$ for the reflexive and
	transitive closure of $\by{}$, $\By{\ell}$ for the transitions
	$\By{}\by{\ell}\By{}$ and $\By{\hat{\ell}}$ for $\By{\ell}$ if
	$\ell\not = \tau$ otherwise $\By{}$.
%	\noi We extend to $\By{}$ and $\By{\hat{\ell}}$ in the standard way.
\end{definition}

%\subsection{Behavioural Semantics}

\subsection{Reduction-Closed, Barbed Congruence}
\label{subsec:rc}

Equivalent processes require a notion of session type confluence,
defined over session environments $\Delta$:
%
\begin{definition}[Session Environment Confluence]\rm
	We denote $\Delta_1 \bistyp \Delta_2$ whenever $\exists \Delta$ such that
	$\Delta_1 \red^* \Delta$ and $\Delta_2 \red^* \Delta$.
\end{definition}
%
%Session environment confluence requires from session environment
%to be able to follow each other.

We define a generic typed relation typed processes that
includes the common properties for all the equivalence relations
that we are going to define:
%
\begin{definition}[Typed Relation]\rm
	We say that
	$\Gamma; \emptyset; \Delta_1 \proves P_1 \hastype \Proc\ \Re \ \Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$
	is a typed relation whenever:
	\begin{enumerate}[i)]
		\item	$P_1$ and $P_2$ are closed processes;
		\item	$\Delta_1$ and $\Delta_2$ are balanced; and
		\item	$\Delta_1 \bistyp \Delta_2$.
	\end{enumerate}
%
	\noi We write
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{P_2}$
	for $\Gamma; \emptyset; \Delta_1 \proves P_1 \hastype \Proc\ \Re\ \Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$.
\end{definition}

Type relations relate only closed processes
(i.e.\ processes with no free variables)
with balanced session environments and the two session
environments are confluent.

We define the notions of barb~\cite{MiSa92} and typed barb:
%
\begin{definition}[Barbs]\rm
	Let program $P$.
	\begin{enumerate}
		\item	We write $P \barb{n}$ if $P \scong \newsp{\tilde{m}}{\bout{n}{V} P_2 \Par P_3}, n \notin \tilde{m}$.
			We write $P \Barb{n}$ if $P \red^* \barb{n}$.

		\item	We write $\Gamma; \emptyset; \Delta \proves P \barb{n}$ if
			$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ with $P \barb{n}$ and $\dual{n} \notin \Delta$.
			We write $\Gamma; \emptyset; \Delta \proves P \Barb{n}$ if $P \red^* P'$ and
			$\Gamma; \emptyset; \Delta' \proves P' \barb{n}$.			
	\end{enumerate}
\end{definition}
%
A barb $\barb{n}$ is an observable on an output prefix with subject $n$.
Similarly a weak barb $\Barb{n}$ is a barb after a number of reduction steps.
Typed barbs $\barb{n}$ (resp.\ $\Barb{n}$)
happen on typed processes $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$
where we require that the corresponding dual endpoint $\dual{n}$ is not present
in the session type $\Delta$.

To define a congruence relation we define the notion of the context $\C$:
%
\begin{definition}[Context]\rm
	A context $\C$ is defined on the grammar:
%
\[
	\begin{array}{rcl}
		\C &\bnfis& \hole \bnfbar \bout{u}{V} \C \bnfbar \bout{u}{\abs{x}{\C}} P \bnfbar \binp{u}{x} \C \bnfbar \recp{X}{\C} \bnfbar \appl{(\abs{x}{\C})}{u}\\
		& \bnfbar & \news{n} \C \bnfbar \C \Par P \bnfbar P \Par \C \bnfbar \bsel{u}{l} \C \bnfbar \bbra{k}{l_1: P_1, \dots, l_i:\C, \dots, l_n: P_n}
	\end{array}
\]
%
	Notation $\context{\C}{P}$ replaces every $\hole$ in $\C$ with $P$.
\end{definition}
%
\noi A context is a function that takes a process and returns a new process
according to the above syntax.

The first behavioural relation we define is reduction-closed, barbed congruence:
%
\begin{definition}[Reduction-closed, Barbed Congruence]\rm
	Typed relation
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{P_2}$
	is a barbed congruence whenever:
%
	\begin{enumerate}
		\item
		\begin{itemize}
			\item	If $P_1 \red P_1'$ then $\exists P_2', P_2 \red^* P_1'$ and
				$\horel{\Gamma}{\Delta_1'}{P_1'}{\ \Re\ }{\Delta_2'}{P_2'}$
			\item	If $P_2 \red P_2'$ then $\exists P_1', P_1 \red^* P_1'$ and
				$\horel{\Gamma}{\Delta_1'}{P_1'}{\ \Re\ }{\Delta_2'}{P_2'}$
		\end{itemize}

		\item
		\begin{itemize}
			\item	If $\Gamma;\emptyset;\Delta \proves P_1 \barb{s}$ then $\Gamma;\emptyset;\Delta \proves P_2 \Barb{s}$.
			\item	If $\Gamma;\emptyset;\Delta \proves P_2 \barb{s}$ then $\Gamma;\emptyset;\Delta \proves P_1 \Barb{s}$.
		\end{itemize}

		\item	$\forall \C, \horel{\Gamma}{\Delta_1'}{\context{\C}{P_1}}{\ \Re\ }{\Delta_2'}{\context{\C}{P_2}}$
	\end{enumerate}
%
	The largest such congruence is denoted with $\cong$.
\end{definition}
%
\noi Reduction-closed, barbed congruence is closed under reduction semantics and 
preserves barbs under any context, i.e~no barb observer can distinguish
between two related processes.

\subsection{Contextual Bisimulation}

The second behavioural relation we define is the labelled
characterisation of reduction-closed, barbed congruence,
called contextual bisimulation~\cite{San96H}:
%
\begin{definition}[Contextual Bisimulation]\rm
	\label{def:context_bis}
	Typed relation 
	$\Re$ is a {\em contextual bisimulation} if whenever
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{P_2}$ implies:
	\begin{enumerate}
		\item	$\forall \news{\tilde{m_1}} \bactout{n}{V_1}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\by{\news{\tilde{m_1}} \bactout{n}{V_1}}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2, \abs{x}{Q}$ such that
			\[
				\horel{\Gamma}{\Delta_2}{Q_1}{\By{\news{\tilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}
			\]
			and $\forall R$ with $\set{x} = \fv{R}$, 
			then
			\[
				\horel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par R\subst{V_1}{x}}}
				{\ \Re\ }
				{\Delta_2''}{\newsp{\tilde{m_2}}{Q_2 \Par R\subst{V_2}{x}}}
			\]
%
		\item	$\forall \ell \not= \news{\tilde{m}} \bactout{n}{V}$
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2$ such that
			\[
				\horel{\Gamma}{\Delta_1}{Q_1}{\by{\ell}}{\Delta_2'}{Q_2}
			\]
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re\ }{\Delta_2'}{Q_2}$

		\item	The symmetric cases of 1 and 2.
	\end{enumerate}
%
	The Knaster Tarski theorem ensures that the largest contextual bisimulation exists,
	it is called contextual bisimilarity and is denoted by $\wbc$.
\end{definition}
%

\subsection{Higher-Order Bisimulation and Characteristic Bisimulation ($\wb/\wbf$)}
\label{subsec:char_bis}

The contextual bisimulation in the general case
is a hard relation to compute due to:
%
\begin{enumerate}[i)]
	\item	the universal quantifier over contexts in the output case
		(Clause~1 in \defref{def:context_bis}); and

	\item	a higher order input prefix can observe infinitely many
		different input actions, since infinitely many different
		processes can match the session type of an input prefix.
\end{enumerate}
%
To reduce the burden of the contextual bisimulation
%induced by 
%universal quantification,
%we introduce \emph{higher-order} and \emph{characteristic}  
%bisimulations, two tractable equivalences denoted  $\hwb$ and $\fwb$, respectively.
we take the following two steps: 
%
\begin{enumerate}[(a)]
	\item	we replace Clause~1 in \defref{def:context_bis} with a clause
		involving a more tractable process closure; and
	\item	we refine the transition rule for input in the LTS
		so to define a bisimulation relation
		without observing infinitely many actions on the same input prefix. 
\end{enumerate}
%

%the set of higher order input actions
%on an input prefix is infite since infinitely
%many processes can match the session type of
%the input prefix.

%The output action case of the contextual bisimulation
%can be equivalently be defined as:

\myparagraph{Trigger Processes with Session Communication.}
Concerning~(a), we exploit session types. 
First observe that closure $R\subst{V}{x}$ 
in Clause~1 in \defref{def:context_bis}
is contextually bisimilar to the process:
%
\begin{eqnarray}
	\label{equ:1}
	P = \newsp{s}{\appl{(\abs{z}{\binp{z}{x}{R}})}{s} \Par \bout{\dual{s}}{V} \inact}
\end{eqnarray}
%
\noi
In fact, we have $P \wbc R\subst{V}{x}$, since 
application and session transitions are deterministic.  
Now let us consider process $T_{V}$ below,
where $t$ is a fresh name:
%
\begin{eqnarray}
	\label{equ:0}
	T_{V} = \hotrigger{t}{x}{s}{V}
\end{eqnarray}
%
\noi
Process $T_{V}$ can input the class of
abstractions $\abs{z}{\binp{z}{x} R}$ and
can simulate the closure of~\ref{equ:1}:%$P$:
%
\begin{eqnarray}
	\label{equ:2}
	T_{V} \by{\bactinp{t}{\abs{z}{\binp{z}{x}R}}} P \wbc R \subst{V}{x}
\end{eqnarray}
%s
Processes such as $T_{V}$
input a value at a fresh name;
we will use this class of 
{\bf\em trigger processes} to define a
refined bisimilarity without the demanding 
output Clause~1 in \defref{def:context_bis}.
Given a fresh name $t$, we write:
%
\[
	\htrigger{t}{V} = \hotrigger{t}{x}{s}{V}
\]
%
% to 
%stand for a trigger process $T_{V}$ for value $V$.
We note that in contrast to previous
approaches~\cite{SaWabook,DBLP:journals/lmcs/JeffreyR05} 
our {trigger processes} do {\em not}
use recursion or replication.
This is crucial for preserving linearity of 
session names.



\myparagraph{Characteristic Processes and Values.}
Concerning (b), we limit the possible input abstractions
$\abs{x} P$ by exploiting session types.
We introduce the key concept of {\bf \emph{characteristic process/values}},
which is the 
simplest process/value that can inhabit a type.
E.g.~let $S = \btinp{\shot{S_1}} \btout{S_2} \tinact$
be a session type that as:
i) first input an abstraction, from type $S_1$ to a process;
ii) output a value of type $S_2$; and iii) terminate.
Then, process:
%
\[
	Q = \binp{u}{x} (\bout{u}{s_2} \inact \Par \appl{x}{s_1})
\]
%
\noi is a characteristic process for $S$ along name $u$.
 
We formalise the last intuition in the next definition.
%
\begin{definition}[Characteristic Process]\rm
	\label{def:characteristic_process}
	\noi Let name $u$ and type $U$; then we define the {\em characteristic process}:
	$\mapchar{U}{u}$ and the {\em characteristic value} $\omapchar{U}$ as:
%
	\[
	\begin{array}{cc}
		\begin{array}{rclcl}
			\mapchar{\btinp{U} S}{u} &\defeq& \binp{u}{x} (\mapchar{S}{u} \Par \mapchar{U}{x})
			\\
			\mapchar{\btout{U} S}{u} &\defeq& \bout{u}{\omapchar{U}} \mapchar{S}{u} %& & n \textrm{ fresh}
			\\
			\mapchar{\btsel{l : S}}{u} &\defeq& \bsel{u}{l} \mapchar{S}{u}
			\\
			\mapchar{\btbra{l_i: S_i}_{i \in I}}{u} &\defeq& \bbra{u}{l_i: \mapchar{S_i}{u}}_{i \in I}
			\\
			\mapchar{\tvar{t}}{u} &\defeq& \varp{X}_{\vart{t}}
			\\
			\mapchar{\trec{t}{S}}{u} &\defeq& \recp{X_{\vart{t}}}{\mapchar{S}{u}}
			\\
			\mapchar{\tinact}{u} &\defeq& \inact
			\\
		\end{array}
		&
		\begin{array}{rcrclcl}
			&&\mapchar{\chtype{S}}{u} &\defeq& \bout{u}{\omapchar{S}} \inact
			\\
			&&\mapchar{\chtype{L}}{u} &\defeq& \bout{u}{\omapchar{L}} \inact
			\\
			\mapchar{\shot{C}}{x} &\defeq& \mapchar{\lhot{C}}{x} &\defeq& \appl{x}{\omapchar{C}}
			\\
			\\
			&&\omapchar{S} &\defeq& s && s \textrm{ fresh}
			\\
			\omapchar{\chtype{S}} &\defeq& \omapchar{\chtype{L}} &\defeq& a && a \textrm{ fresh}
			\\
			\omapchar{\shot{C}} &\defeq& \omapchar{\lhot{C}} &\defeq& \abs{x}{\mapchar{C}{x}}
		\end{array}
	\end{array}
	\]
\end{definition}
%
%
%Given a value type $U$, we write $\mapchar{U}{u} $
%for its characteristic process along name $u$.
%Similarly, given value type $U$, we write 
%$\omapchar{U}$ to denote its characteristic value.
\begin{proposition}\rm
$ $
	\begin{enumerate}[$\bullet$]
		\item	$\Gamma; \emptyset; \Delta \cat u:S \proves \mapchar{S}{u} \hastype \Proc$
		\item	$U = \chtype{S}$ or $U = \chtype{L}$ implies $\Gamma \cat u:U; \emptyset; \Delta \proves \mapchar{U}{u} \hastype \Proc$
		\item	$\Gamma; \es; \Delta \proves \omapchar{U} \hastype U$
	\end{enumerate}
\end{proposition}

\begin{proof}
	By induction on the definition of $\mapchar{S}{u}$ and $\mapchar{U}{u}$.
	\qed
\end{proof}

\begin{corollary}\rm
	If $\Gamma; \emptyset; \Delta \proves \mapchar{C}{u} \hastype \Proc$
	then
	$\Gamma; \es; \Delta \proves u \hastype C$.
\end{corollary}

We use the characteristic value $\omapchar{U}$
to limit input transitions.
Following the same reasoning as (\ref{equ:1})--(\ref{equ:2}), 
we can define an alternative trigger process, called
{\bf\em characteristic trigger process} with type 
$U$ to replace Clause~1 in \defref{def:context_bis}.
%
\begin{eqnarray}
	\label{eq:4}
	\ftrigger{t}{V}{U} \defeq \fotrigger{t}{x}{s}{\btinp{U} \tinact}{V}
\end{eqnarray}
%
\noi 
Thus, in contrast to the trigger process in~\eqref{equ:0},
the characteristic trigger process in~\eqref{eq:4}
does not involve a higher-order communication on $t$.

To refine the input transition system, we need to observe 
an additional value:
%
\[
	\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}
\]
%
called the {\bf\em trigger value}.
This is necessary, because it turns out
that a characteristic value 
alone as the observable input 
is not enough to define a sound bisimulation.
Roughly speaking, the trigger value is used
to observe/simulate application processes.

The intuition for usage of the trigger is
demonstrated in the next example.
%
\begin{example}
	\label{ex:motivation}
	First we demonstrate that observing a characteristic value
	input alone is not sufficient
	to define a sound bisimulation closure.
	Consider typed processes $P_1, P_2$:
%
	\begin{eqnarray}
		P_1 = \binp{s}{x} (\appl{x}{s_1} \Par \appl{x}{s_2}) 
		\qquad \qquad
		P_2 = \binp{s}{x} (\appl{x}{s_1} \Par \binp{s_2}{y} \inact) 
		\label{equ:6}
	\end{eqnarray}
%
	with
	\[
		\Gamma; \es; \Delta \cat s: \btinp{\shot{(\btinp{C} \tinact)}} \tinact \proves P_i \hastype \Proc \qquad (i \in \{1,2\}).
	\]
%
	If the above processes input and substitute over $x$
	the characteristic value 
	\[
		\omapchar{\shot{(\btinp{C} \tinact)}} = \abs{x}{\binp{x}{y} \inact}
	\] 
	\noi then both processes evolve into:
%
	\begin{eqnarray*}
		\Gamma; \es; \Delta \proves \binp{s_1}{y} \inact \Par \binp{s_2}{y} \inact \hastype \Proc
	\end{eqnarray*}
	\noi therefore becoming  contextually bisimilar.
	However, the processes in~(\ref{equ:6})
	are clearly {\em not} contextually bisimilar:
	there exist many input actions
	which may be used to distinguish them.
	For example, if 
	$P_1$ and $P_2$ input
%
	\[
		\abs{x}{\newsp{s_3}{\bout{a}{s_3} \binp{x}{y} \inact}}
	\]
%
	\noi with
	$\Gamma; \es; \Delta \proves s \hastype \tinact$,
	then their derivatives are not bisimilar.

	Observing only the characteristic value 
	results in an over-discriminating bisimulation.
	However, if a trigger value, 
	$\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}$
	is received on $s$, 
	then we can distinguish 
	processes in \eqref{equ:6}:  
%
	\begin{eqnarray*}
		\horel{\Gamma}{\Delta}{P_1}{&\By{\bactinp{s}{\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}}}&}{\Delta'}{\binp{t}{x} (\appl{x}{s_1}) \Par \binp{t}{x} (\appl{x}{s_2})}
		\\
		\horel{\Gamma}{\Delta}{P_2}{&\By{\bactinp{s}{\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}}}&}{\Delta''}{\binp{t}{x} (\appl{x}{s_1}) \Par \binp{s_2}{y} \inact}
	\end{eqnarray*}
%

	One question that arises here is whether the trigger value is enough
	to distinguish two processes, hence no need of 
	characteristic values as the input. 
	This is not the case since the trigger value
	alone also results in an over-discriminating bisimulation relation.
	In fact the  trigger value can be observed on any input prefix
	of {\em any type}. For example, consider the following processes:
%
	\begin{eqnarray}
		\Gamma; \es; \Delta \proves \newsp{s}{\binp{n}{x} (\appl{x}{s}) \Par \bout{\dual{s}}{\abs{x} P} \inact} \hastype \Proc\label{equ:7}
		\\
		\Gamma; \es; \Delta \proves \newsp{s}{\binp{n}{x} (\appl{x}{s}) \Par \bout{\dual{s}}{\abs{x} Q} \inact} \hastype \Proc\label{equ:8}
	\end{eqnarray}
%
	\noi if processes in \eqref{equ:7}/\eqref{equ:8}
	input the trigger value, we obtain processes:
%
	\begin{eqnarray*}
		\Gamma; \es; \Delta' \proves  \newsp{s}{\binp{t}{x} (\appl{x}{s}) \Par \bout{\dual{s}}{\abs{x} P} \inact} \hastype \Proc
		\\
		\Gamma; \es; \Delta' \proves  \newsp{s}{\binp{t}{x} (\appl{x}{s}) \Par \bout{\dual{s}}{\abs{x} Q} \inact} \hastype \Proc
	\end{eqnarray*}

	\noi thus we can easily derive a bisimulation closure if we 
	assume a bisimulation definition that allows only trigger value input.

	But if processes in \eqref{equ:7}/\eqref{equ:8}
	input the characteristic value $\abs{z}{\binp{z}{x} (\appl{x}{m})}$,  
	then they would become:
	%
	\begin{eqnarray*}
		\Gamma; \es; \Delta \proves \newsp{s}{\binp{s}{x} (\appl{x}{m}) \Par \bout{\dual{s}}{\abs{x} P} \inact} \wbc \Delta \proves P \subst{m}{x}
		\\
		\Gamma; \es; \Delta \proves \newsp{s}{\binp{s}{x} (\appl{x}{m}) \Par \bout{\dual{s}}{\abs{x} Q} \inact} \wbc \Delta \proves Q \subst{m}{x}
	\end{eqnarray*}
	\noi which are not bisimilar if $P \subst{m}{x} \not\wb Q \subst{m}{x}$.
\end{example}

\noi We now define the \emph{refined} typed LTS. 
The new LTS is defined by considering a transition
rule for input in which admitted values are
trigger or characteristic values:
We formalise the restricted input action with the
definition of a new environment transition relation:
%
\[
	(\Gamma, \Lambda_1, \Delta_1) \hby{\ell} (\Gamma, \Lambda_2, \Delta_2)
\]
%
\noi The new rule is defined on top of the rules in~\figref{fig:envLTS}:
%The definition uses the same rules for defining the $\by{\ell}$ relation,
%but it requires the substitution of rules $\eltsrule{SRv}$ and
%$\eltsrule{ShRv}$ with the rule:
\begin{definition}[Refined Input Environment LTS]\rm
%
\[
	\eltsrule{RRv}~~\tree {
		(\Gamma_1; \Lambda_1; \Delta_1) \by{\bactinp{n}{V}} (\Gamma_2; \Lambda_2; \Delta_2)
		\quad
		\begin{array}{crcl}
			& (V & \scong & \abs{z}{\binp{t}{x} (\appl{x}{z})} \wedge t \textrm{ fresh}) \\
			\vee & (V & \scong &  \omapchar{U}) \vee V \scong m
		\end{array}
	}{
		(\Gamma_1; \Lambda_1; \Delta_1) \hby{\bactinp{n}{V}} (\Gamma_2; \Lambda_1; \Delta_2)
	}
\]
\end{definition}
%
\noi 
Rule $\eltsrule{RRv}$ refines the input action to carry only
a characteristic value (fresh name or abstraction)
or a trigger value on a fresh name $t$.
% as a higher order input.
%Input of names remains as defined in the rules 
%$\eltsrule{SRv}$ and $\eltsrule{ShRv}$.
%Rule $\eltsrule{RRcv}$ restricts the higher-order input
%in relation $\hby{\ell}$;
%only characteristic processes and trigger processes
%are allowed to be received on a higher-order input.
%Non fresh names can still be received as in the definition of
%the $\by{\ell}$ relation.
%The conditions for input follow the conditions
%for the $\by{\ell}$ definition.
The new environment transition system $\hby{\ell}$
uses as input rule
rule $\eltsrule{RRV}$ which is defined on top of rules
$\eltsrule{SRv}$ and $\eltsrule{ShRv}$
in~\figref{fig:envLTS}. All other defining cases
of environment LTS $\hby{\ell}$ remain the same
as in~\figref{fig:envLTS}.

The new typed relation derived from the $\hby{\ell}$ environment LTS is
defined as:
%
\begin{definition}[Restricted Typed Transition]\rm 
	\label{def:restricted_typed_transition}
	We write
%
	$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_2}{P_2}$
	whenever
	$P_1 \by{\ell} P_2$,
	$(\Gamma, \emptyset, \Delta_1) \hby{\ell} (\Gamma, \emptyset, \Delta_2)$
	and
	$\Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$.

	\noi We extend to $\Hby{}$ and $\Hby{\hat{\ell}}$ in the standard way.
\end{definition}

\begin{lemma}[Invariant]\label{l:invariant}
	If $\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_2}{P_2}$
	then $\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_2}{P_2}$.
\end{lemma}

\begin{proof}
	The proof is straightforward from the definition of rule $\eltsrule{RRv}$.
\end{proof}

%As we discussed previously it is convenient to define
%the output action case of the bisimulation using the
%trigger process:
%%
%\[
%	\hotrigger{t}{x}{s}{V}
%\]
%%
%\noi for substituting value $\Gamma; \es; \Delta \proves V \hastype U$
%over an observer context.
%An alternative trigger that uses a first-order input prefix,
%can be defined, which is parametrised on the type $U$ of $V$:
%%
%\[
%	\fotrigger{t}{x}{s}{\btinp{U} \inact}{V}
%\]
%%
%Both triggers reduce in a deterministic way under
%typed transition $\hby{\ell}$, due to the
%freshness of $t$ and the restricted session $s$. Furthermore,
%both trigger transitions result in the process
%$\mapchar{U}{x} \subst{V}{x}$.

The next definition formalises the notion of the trigger process.
%
\begin{definition}[Trigger Process]\rm
	\begin{center}
		\begin{tabular}{lclcl}
			Higher order trigger & & $\htrigger{t}{V}$ &$=$& $\hotrigger{t}{x}{s}{V}$ or\\
			First order trigger & & $\ftrigger{t}{V}{U}$ &$=$& $\fotrigger{t}{x}{s}{\btinp{U} \tinact}{V}$
		\end{tabular}
	\end{center}
\end{definition}

\myparagraph{The Two Bisimulations.} We now define 
higher-order bisimulation, 
a more tractable bisimulation for $\HO$ and $\HOp$.
The two bisimulations differ on the fact that
they use the different 
trigger processes: $\htrigger{t}{V}$ and $\ftrigger{t}{V}{U}$.

\begin{definition}[Higher-Order Bisimulation]\rm
	\label{def:bisim}
	Typed relation
	$\Re$ is a {\em Higher-Order bisimulation} if whenever
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{Q_1}$ implies:
%
	\begin{enumerate}
		\item	$\forall \news{\tilde{m_1}} \bactout{n}{V_1}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}} \bactout{n}{V_1}}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2, V_2$ such that
			\[
				\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}
			\]
			and for fresh $t$
			\[
				\horel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \htrigger{t}{V_1}}}
				{\ \Re\ }
				{\Delta_2''}{}{\newsp{\tilde{m_2}}{Q_2 \Par \htrigger{t}{V_2}}}
			\]
%
		\item	$\forall \ell \not= \news{\tilde{m}} \bactout{n}{V}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2$ such that 
			\[
				\horel{\Gamma}{\Delta_1}{Q_1}{\Hby{\ell}}{\Delta_2'}{Q_2}
			\]
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re\ }{\Delta_2'}{Q_2}$

		\item	The symmetric cases of 1 and 2.
	\end{enumerate}
	The Knaster Tarski theorem ensures that the largest Higher-Order bisimulation exists,
	it is called higher-order bisimilarity and is denoted by $\wb$.
\end{definition}
%
The Higher-Order bisimulation definition uses higher order input guarded triggers,
thus it cannot be used as an equivalence relation for the \sessp sub-calculus.
An alternative definition of the bisimulation based on the characteristic
output triggers solves this problem.

\begin{definition}[Characteristic Bisimulation]\rm
	\label{def:cbisim}
	Typed relation 
	$\Re$ is a {\em Characteristic bisimulation} if whenever
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \mathcal{R}\ }{\Delta_2}{Q_1}$ implies:
	\begin{enumerate}
		\item	$\forall \news{\tilde{m_1}} \bactout{n}{V_1: U}$ such that %with \dk{$\Gamma; \es; \Delta \proves V_1 \hastype U$} such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}} \bactout{n}{V_1: U}}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2, V_2$ such that %with \dk{$\Gamma; \es; \Delta \proves V_2 \hastype U$} such that
			\[
				\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}} \bactout{n}{V_2: U}}}{\Delta_2'}{Q_2}
			\]
			and for fresh $t$
			\[
				\horel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \ftrigger{t}{V_1}{U}}}
				{\ \Re\ }
				{\Delta_2''}{}{\newsp{\tilde{m_2}}{Q_2 \Par \ftrigger{t}{V_2}{U}}}
			\]
%
		\item	$\forall \ell \not= \news{\tilde{m}} \bactout{n}{V}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}
			\]
			implies that $\exists Q_2$ such that 
			\[
				\horel{\Gamma}{\Delta_1}{Q_1}{\Hby{\ell}}{\Delta_2'}{Q_2}
			\]
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re\ }{\Delta_2'}{Q_2}$

		\item	The symmetric cases of 1 and 2.
	\end{enumerate}
	The Knaster Tarski theorem ensures that the largest bisimulation exists,
	it is called Characteristic bisimilarity and is denoted by $\wbf$.
\end{definition}

The next result clarifies our choice of restricting
the higher order input action with the input trigger and
the characteristic process; if under the substitution
of the characteristic abstraction and the trigger
input two processes remain bisimilar then they
are bisimilar under any abstraction substitution.

\begin{lemma}[Process Substitution]\rm
	\label{lem:proc_subst}
	If 
%
	\begin{enumerate}
		\item	$\horel{\Gamma}{\Delta_1'}{P \subst{\abs{z}{\binp{t}{y} (\appl{y}{z})}}{x}}{\wb}{\Delta_2}{Q \subst{\abs{z}{\binp{t}{y} (\appl{y}{z})}}{x}}$
			for some fresh $t$.

		\item	$\horel{\Gamma}{\Delta_1''}{P \subst{\omapchar{U}}{x}}{\wb}{\Delta_2''}{Q \subst{\omapchar{U}}{x}}$
			for some $U$.
	\end{enumerate}
%
	then $\forall R$ such that $\fv{R} = z$
\[
	\horel{\Gamma}{\Delta_1}{P \subst{\abs{z}{R}}{x}}{\wb}{\Delta_2}{Q \subst{\abs{z}{R}}{x}}
\]
\end{lemma}

\begin{proof}
	The details of the proof can be found in \appref{app:sub_coinc}.
	\qed
\end{proof}

The next theorem justifies our definition choices
for the bisimulation relations, since
they coincide between them and they also
coincide with reduction closed, barbed congruence.

\begin{theorem}[Coincidence]\rm
	\label{the:coincidence}
	Relations $\wb, \wb^f, \wbc$ and $\cong$ coincide.
\end{theorem}

\begin{proof}
	The full details of the proof are in \appref{app:sub_coinc}.
	The theorem is split into a hierarchy of Lemmas. 
	\lemref{lem:wb_eq_wbf} establishes $\wb\ =\ \wbf$.
	\lemref{lem:wb_is_wbc} exploits the process substitution result
	(\lemref{lem:proc_subst}) to prove that $\wb \subseteq \wbc$.
	\lemref{lem:wbc_is_cong} shows that $\wbc$ is a congruence
	which implies $\wbc \subseteq \cong$.
	The final result comes from \lemref{lem:cong_is_wb} where
	we use label testing to show that $\cong \subseteq \wb$ using
	the technique in developed in~\cite{Hennessy07}. The formulation of input
	triggers in the bisimulation relation allows us to prove
	the latter result without using a matching operator.
	\qed
\end{proof}

%\begin{definition}[Session Transition]\rm
%	Let well-typed \HOp process $\Gamma; \es; \Delta \proves P \hastype \Proc$.
%	We write {\em session transition} 
%	$\horel{\Gamma}{\Delta}{P}{\shby{\ell}}{\Delta'}{P'}$ if
%	$\horel{\Gamma}{\Delta}{P}{\hby{\ell}}{\Delta'}{P'}$
%	is derived by not using the environment label transition rules $\eltsrule{ShOut}$
%	and $\eltsrule{ShRv}$.
%\end{definition}
%
%\begin{lemma}[$\tau$-inertness]\rm
%	\label{lem:tau_inert}
%	Let $\Gamma; \es; \Delta \proves P \hastype \Proc$.
%	$\horel{\Gamma}{\Delta}{P}{\shby{\ell}}{\Delta'}{P'}$
%	implies
%	$\horel{\Gamma}{\Delta}{P}{\wb}{\Delta'}{P'}$
%\end{lemma}

\begin{definition}[Deterministic Transition]\rm
	Let balanced \HOp process $\Gamma; \es; \Delta \proves P \hastype \Proc$.
	Transition $\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ is called:
	\begin{itemize}
		\item	{\em Session transition}, written
			$\horel{\Gamma}{\Delta}{P}{\hby{\stau}}{\Delta'}{P'}$,
			whenever the untyped transition $P \by{\tau} P'$
			is derived on visible actions with a session subject.

		\item	{\em \betatran}, written
			$\horel{\Gamma}{\Delta}{P}{\hby{\btau}}{\Delta'}{P'}$,
			whenever the untyped transition $P \by{\tau} P'$
			is derived on rule $\ltsrule{App}$.
	\end{itemize}
%
	We write $\horel{\Gamma}{\Delta}{P}{\hby{\dtau}}{\Delta'}{P'}$ for
	either a session transition or a \betatran.
\end{definition}

\begin{proposition}[$\tau$-inertness]\rm
	\label{lem:tau_inert}
	Let balanced \HOp process $\Gamma; \es; \Delta \proves P \hastype \Proc$.
	$\horel{\Gamma}{\Delta}{P}{\hby{\dtau}}{\Delta'}{P'}$ implies
	$\horel{\Gamma}{\Delta}{P}{\wb}{\Delta'}{P'}$.
\end{proposition}

\begin{proof}
	The proof is relied on the fact that processes of the
	form $\Gamma; \es; \Delta \proves \bout{s}{V} P_1 \Par \binp{k}{x} P_2$
	cannot have any typed transition observables and the fact
	that bisimulation is a congruence.
	See details in \appref{app:sub_tau_inert}.
	\qed
\end{proof}

Processes that do not use shared names are inherently $\tau$-inert.

\begin{corollary}[$\CAL^{\minussh}$ $\tau$-inertness]\rm
	\label{cor:tau_inert}
	Let $\Gamma; \es; \Delta \proves P \hastype \Proc$ an $\CAL^{\minussh}$ process.
%
	\begin{itemize}
		\item	$\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ if and only if $\horel{\Gamma}{\Delta}{P}{\hby{\dtau}}{\Delta'}{P'}$.
		\item	$\horel{\Gamma}{\Delta}{P}{\hby{\dtau}}{\Delta'}{P'}$ implies $\horel{\Gamma}{\Delta}{P}{\wb}{\Delta'}{P'}$.
	\end{itemize}
%	\begin{enumerate}
%		\item
%	If $\horel{\Gamma}{\Delta}{P}{\by{\tau}}{\Delta'}{P'}$ then $\horel{\Gamma}{\Delta}{P}{\wb}{\Delta'}{P'}$.
%		\item	If $P \red^* P'$ then $\Gamma; \es; \Delta \wb \Delta' \proves P \wb P'$.
%	\end{enumerate}
\end{corollary}

\begin{lemma}[Up-to Deterministic Transition]\rm
	\label{lem:up_to_deterministic_transition}
	Let $\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2'}{Q_1}$ such
	that if whenever:
%
	\begin{enumerate}
		\item	$\forall \news{\tilde{m_1}} \bactout{n}{V_1}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}} \bactout{n}{V_1}}}{\Delta_3}{P_3}
			\]
			implies that $\exists Q_2, V_2$ such that
			\[
				\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}
			\]
			and
			\[
				\horel{\Gamma}{\Delta_3}{P_3}{\Hby{\dtau}}{\Delta_1'}{P_2}
			\]
			and for fresh $t$:
			\[
				\horel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \htrigger{t}{V_1}}}
				{\ \Re\ }
				{\Delta_2''}{}{\newsp{\tilde{m_2}}{Q_2 \Par \htrigger{t}{V_2}}}
%				\mhorel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \hotrigger{t}{x}{s}{V_1}}}
%				{\ \Re\ }
%				{\Delta_2''}{}{\newsp{\tilde{m_2}}{Q_2 \Par \hotrigger{t}{x}{s}{V_2}}}
			\]
%
		\item	$\forall \ell \not= \news{\tilde{m}} \bactout{n}{V}$ such that
			\[
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_3}{P_3}
			\]
			implies that $\exists Q_2$ such that 
			\[
				\horel{\Gamma}{\Delta_1}{Q_1}{\Hby{\ell}}{\Delta_2'}{Q_2}
			\]
			and
			\[
				\horel{\Gamma}{\Delta_3}{P_3}{\Hby{\dtau}}{\Delta_1'}{P_2}
			\]
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re\ }{\Delta_2'}{Q_2}$

		\item	The symmetric cases of 1 and 2.
	\end{enumerate}
	Then $\Re\ \subseteq\ \wb$.
\end{lemma}


\begin{proof}
	The proof is very easy if we consider the
	closure
	\[
		\Re^{\Hby{\dtau}} = \set{ \horel{\Gamma}{\Delta_1'}{P_2}{,}{\Delta_2'}{Q_1} \setbar \horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2'}{Q_1},
		\horel{\Gamma}{\Delta_1}{P_1}{\Hby{\dtau}}{\Delta_1'}{P_2} }
	\]
	We verify that $\Re^{\Hby{\dtau}}$ is a bisimulation with
	the use of \propref{lem:tau_inert}.
	\qed
\end{proof}
