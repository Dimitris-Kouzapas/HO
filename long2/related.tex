% !TEX root = main.tex
\section{Related Work}
\label{sec:related}

\myparagraph{Expressiveness in Concurrency.}
There is a vast literature on expressiveness studies for process calculi;
we refer to~\cite{DBLP:journals/entcs/Parrow08} for a survey
(see also~\cite[\S\,2.3]{PerezPhD10}). 
In particular, the expressive power of the $\pi$-calculus has received much attention.
Studies cover, e.g., 
relationships between first-order and higher-order concurrency~(see, e.g.,~\cite{San923,San96int}),
comparisons between 
synchronous and asynchronous communication~(see, e.g.,~\cite{Boudol92,Palamidessi03,BeauxisPV08}),
and
(non)encodability issues for different choice operators~(see, e.g.,~\cite{Nestmann00,DBLP:conf/esop/PetersNG13}).
To substantiate claims related to (relative) expressive power,
early works appealed to different definitions of encoding.
%For instance, Palamidessi~\cite{Palamidessi03} defines \emph{uniform encodings} as those encodings which are homomorphic wrt parallel composition, respect renamings, and respect a ``reasonable semantics.''
Later on, 
proposals of abstract 
frameworks which formalise the notion of encoding 
and state associated syntactic and semantic criteria 
were put forward; 
two proposals are~\cite{DBLP:journals/iandc/Gorla10,DBLP:journals/tcs/FuL10}. 
These frameworks are applicable to different calculi, and 
have shown useful to clarify known results and to derive new ones.
Our formulation of (precise) typed encoding (\defref{def:goodenc}) 
builds upon existing proposals (including~\cite{Palamidessi03,DBLP:journals/iandc/Gorla10,DBLP:conf/icalp/LanesePSS10})
in order to account for the session type systems
associated to the process languages under comparison.


\myparagraph{Expressiveness of Higher-Order Process Calculi.}
Early expressiveness studies for higher-order calculi are~\cite{Tho90,San923}; 
more recent works include~\cite{BundgaardHG06,DBLP:conf/icalp/LanesePSS10,DBLP:journals/iandc/LanesePSS11,XuActa2012,DBLP:conf/wsfm/XuYL13}.
Due to the close relationship between higher-order process calculi and functional calculi, 
works devoted to encoding (variants of) the $\lambda$-calculus into (variants of) the $\pi$-calculus (see, e.g.,~\cite{San92,DBLP:journals/tcs/Fu99,DBLP:journals/iandc/YoshidaBH04,BHY,DBLP:conf/concur/SangiorgiX14}) are also worth mentioning.
The work~\cite{San923} gives an encoding of the higher-order $\pi$-calculus
into the first-order $\pi$-calculus which is fully abstract with respect to reduction-closed, barbed congruence. 
A basic form of input/output types is used in~\cite{DBLP:journals/tcs/Sangiorgi01}, where the encoding in~\cite{San923} is casted in the asynchronous setting, with output and applications coalesced in a single construct. Building upon~\cite{DBLP:journals/tcs/Sangiorgi01}, 
a simply typed encoding for synchronous processes is given in~\cite{SaWabook}; the reverse encoding (i.e.,  first-order communication into higher-order processes) is also studied there for an asynchronous, localized $\pi$-calculus (only the output capability of names can be sent around).
The work~\cite{San96int} studies hierarchies for calculi with \emph{internal} first-order mobility and 
with higher-order mobility without name-passing (similarly as the subcalculus \HO). 
The hierarchies are based on expressivity: 
formally defined according to the order of types needed in typing, 
they describe different ``degrees of mobility''.
Via fully abstract encodings, it is shown that that name- and process-passing calculi with equal order of types have the same expressiveness.
With respect to these previous results, our approach based on session types 
has several important consequences and allows us to derive new results.  Our study reinforces the intuitive view of ``encodings as protocols'', namely session protocols which enforce precise linear and shared disciplines for names, a distinction not investigated in~\cite{San923,DBLP:journals/tcs/Sangiorgi01}. 
In turn, the linear/shared distinction is central in proper definitions of trigger processes, which are essential to encodings and behavioural equivalences.
More interestingly, we showed that $\HO$, a  minimal higher-order session calculus (no name passing, only first-order application) suffices to encode $\sessp$ (the session calculus with name passing) but also 
$\HOp$  and 
its extension  with higher-order applications (denoted $\HOpp$). 
Thus, using session types all these calculi are shown to be equally expressive with fully abstract encodings.
To our knowledge, these are the first expressiveness results of this kind.

Other related works are~\cite{BundgaardHG06,XuActa2012,DBLP:journals/iandc/LanesePSS11}.
The paper~\cite{BundgaardHG06} proposes a fully abstract, continuation-passing style encoding of the 
$\pi$-calculus into Homer, a rich higher-order process calculus with explicit locations, local names, and nested locations.
The work~\cite{XuActa2012} studies the encodability of the higher-order $\pi$-calculus (extended with a relabeling operator) into the first-order $\pi$-calculus; encodings in the reverse direction are also proposed, following \cite{Tho90}.
A minimal calculus of higher-order concurrency is studied in~\cite{DBLP:journals/iandc/LanesePSS11}: it lacks restriction,  name passing, output prefix (so  communication is asynchronous), and constructs for infinite behavior. 
Nevertheless, this calculus (a sublanguage of \HO) is shown to be Turing complete. Moreover, 
strong bisimilarity is decidable and coincides with reduction-closed, barbed congruence. 

\jpc{Building upon~\cite{ThomsenB:plachoasgcfhop},
the work~\cite{XuActa2012} studies 
the (non)encodability of the $\pi$-calculus into 
a higher-order $\pi$-calculus with a powerful 
name relabelling operator, which is 
shown to be essential in encoding name-passing}. %, following \cite{Tho90}.
A core higher-order calculus is studied in~\cite{DBLP:journals/iandc/LanesePSS11}: 
it lacks restriction,  name passing, output prefix %(communication is asynchronous), 
and constructs for infinite behaviour. 
This calculus  has 
a simple notion of bisimilarity which coincides with reduction-closed, barbed congruence.
%be Turing complete, while 
%have a decidable notion of (strong) bisimilarity that coincides with barbed congruence. 
\jpc{
The absence of restriction plays a key role in the characterisations in~\cite{DBLP:journals/iandc/LanesePSS11};
hence, our characterisation of contextual equivalence for \HO (which has restriction)
cannot be derived from that in~\cite{DBLP:journals/iandc/LanesePSS11}. 
} 

%Our work is closely related in spirit to the expressiveness studies in~\cite{DBLP:conf/icalp/LanesePSS10,DBLP:conf/wsfm/XuYL13}.
In~\cite{DBLP:conf/icalp/LanesePSS10}
the core calculus in~\cite{DBLP:journals/iandc/LanesePSS11} is extended with restriction,
synchronous communication, and polyadicity. It is shown that 
synchronous communication can encode asynchronous communication, % (as in the first-order setting),
and that process passing polyadicity induces a hierarchy in expressive power. % (unlike the first-order setting).
%A further extension with process abstractions of order one
%(functions from processes to processes)
% is shown to strictly add expressive power with respect to passing of processes only.
\jpc{The paper~\cite{DBLP:conf/wsfm/XuYL13} 
complements~\cite{DBLP:conf/icalp/LanesePSS10} 
by studying the expressivity %of second-order abstractions.
%with replication ($!P$).  
%The work \cite{DBLP:conf/wsfm/XuYL13} focuses  
%%name and process abstractions are distinguished and contrasted, also 
%on expressiveness of the hirarchy of polyadic abstraction parameters. 
%(the same kind of polyadicity present in \pHOp)
%By adapting the encodings in~\cite{DBLP:conf/icalp/LanesePSS10} 
%Polyadicity 
of 
second-order process abstractions.
Polyadicity is shown to induce an expressiveness hierarchy; 
also,
by adapting the encoding in~\cite{SangiorgiD:expmpa},
process abstractions are encoded into name abstractions.
In contrast, we 
give a fully abstract encoding of
 \PHOpp into \HO that preserves session types; this improves~\cite{DBLP:conf/icalp/LanesePSS10,DBLP:conf/wsfm/XuYL13}   
by enforcing linearity disciplines on process behaviour.
The focus of~\cite{DBLP:conf/icalp/LanesePSS10,DBLP:conf/wsfm/XuYL13} is on 
the expressiveness of untyped, higher-order processes; they
%Moreover,~\cite{DBLP:conf/icalp/LanesePSS10,DBLP:conf/wsfm/XuYL13}
do not address 
tractable equivalences for processes  (such as 
$\hwb$ and $\fwb$) which only require observation of finite %number of 
higher-order values,  
whose formulations rely on session types.}
%therefore, our work complements their  results. 
% by clarifying the status of typeful %, resource-aware 
%structured communications. % in trigger-based representations of process passing, both in encodings and  equivalences.

\myparagraph{Session Typed Processes.}
The works~\cite{DemangeonH11,Dardha:2012:STR:2370776.2370794} 
study encodings of binary session calculi into a linearly typed $\pi$-calculus. 
While~\cite{DemangeonH11}~gives a precise encoding of \sessp into a linear calculus 
(an extension of \cite{BHY}),  
the work~\cite{Dardha:2012:STR:2370776.2370794} 
gives the operational correspondence 
(without full abstraction, cf.~\defref{def:sep}-4)
for the first- and higher-order 
$\pi$-calculi into \cite{LinearPi}. 
They investigate an embeddability of two different typing systems;
by the result of \cite{DemangeonH11}, 
\HOpp is encodable  into the linearly typed $\pi$-calculi.     

The syntax of $\HOp$ is a subset of that in~\cite{tlca07,MostrousY15}.
The work~\cite{tlca07} develops a full higher-order session calculus
with process abstractions and applications; it admits the type 
$U=U_1 \rightarrow U_2 \dots U_n \rightarrow \Proc$ and its linear type 
$U^1$
which corresponds to $\shot{\tilde{U}}$ and $\lhot{\tilde{U}}$ in 
a super-calculus of $\HOpp$ and $\PHOp$. 
%in~\cite{MostrousY15} in the asynchronous setting.
%The session type
%system considered is influenced by the type systems for $\lambda$-calculi and
%uses type syntax of the form $U_1 \rightarrow U_2 \dots U_n \rightarrow \Proc$
%for shared values and $(U_1 \rightarrow U_2 \dots U_n \rightarrow \Proc)^{1}$
%for linear values.
%Such a type is expressed in $\HOpp$
%terms using the type $\shot{U}$ (respectively, $\lhot{U}$)
%with $U$ being a nested higher-order type; and 
%the $\HOp$ uses only types of the form
%$\shot{C}$ and $\lhot{C}$ with $C$ being a first-order channel type.
Our results show that
the calculus in~\cite{tlca07} is not only expressed but 
also reasoned in 
$\HO$ (with limited form of arrow types, $\shot{C}$ and $\lhot{C}$), via precise encodings. \dk{None of the above works proposes tractable 
bisimulations for higher-order processes.}  



\myparagraph{Other Works on Typed Behavioural Equivalences.}
Since types can limit
contexts (environments) where processes can interact, typed equivalences
usually offer {\em coarse} semantics than untyped semantics. 
The work  \cite{PiSa96b} demonstrated the IO-subtyping can equate 
the optimal encoding of the $\lambda$-caclulus by Milner which was not i
n the untyped polyadic $\pi$-calculus \cite{MilnerR:funp}. 
After \cite{PiSa96b}, many works on typed $\pi$-calculi 
have investigated correctness of encodings of known concurrent and
sequential calculi in order to examine semantic
effects of proposed typing systems. 

The type discipline closely related
to session types is a family of linear typing systems. The
work \cite{LinearPi} first proposed a linearly typed reduction-closed, barbed congruence and 
reasoned a tail-call optimisation of higher-order functions which are
encoded 
as processes. 
The work \cite{Yoshida96} had
used a bisimulation of graph-based types to prove the full abstraction
of encodings of the polyadic synchronous $\pi$-calculus into the
monadic synchronous $\pi$-calculus. 
Later typed equivalences of a
family of linear and affine calculi \cite{BHY,YBH04,BergerHY05} 
were used to encode 
PCF \cite{Plotkin1977223,Milner19771}, the simply typed $\lambda$-calculi with sums and products, and system F \cite{GirardJY:protyp}
fully abstractly (a fully abstract encoding of the $\lambda$-calculi 
was an open problem in \cite{MilnerR:funp}).  
The work \cite{YHB02} proposed a new bisimilarity
method associated with linear type structure and strong
normalisation. It presented applications to reason secrecy in
programming languages. A subsequent work \cite{HY02} adapted these results
to a practical direction. It proposes new typing
systems for secure higher-order and multi-threaded programming 
languages. 
In these works, typed properties, linearity and liveness, 
play a fundamental role in the analysis. In general, linear types 
are suitable to encode ``sequentiality'' in the sense of 
\cite{HylandJME:fulapi,AbramskyS:fulap}.

\myparagraph{Typed Behavioural Equivalences.}
\NY{This work follows the principles 
for
session type behavioural semantics in 
\cite{KYHH2015,KY2015,DBLP:journals/iandc/PerezCPT14}
where a bisimulation is defined on a LTS 
that assumes a session typed
observer.
%The bisimilarity is characterised by the corresponding
%reduction-closed, barbed congruence using techniques derived from~\cite{Hennessy07}.
Our theory for higher-order session types 
differentiates from 
the work in~\cite{KYHH2015,KY2015}, which 
considers the first-order
binary and multiparty session types, respectively.
The work \cite{DBLP:journals/iandc/PerezCPT14} gives a behavioural theory 
for a 
logically motivated
language of binary sessions 
without shared names.}
%Determinacy properties (confluence, $\tau$-inertness) are proven.

%The theory for higher-order session type quivalences is more challenging than
%their corresponding first-order bisimulation theory.
Our approach for the higher-order builds upon techniques by Sangiorgi~\cite{SangiorgiD:expmpa,San96H}
and Jeffrey and Rathke~\cite{JeffreyR05}.
The work %Sangiorgi as part of his Ph.D.~research
%\cite{San96H,SangiorgiD:expmpa}
\cite{SangiorgiD:expmpa}
introduced the first fully-abstract encoding from the higher-order 
$\pi$-calculus into the $\pi$-calculus. 
Sangiorgi's encoding is based on the idea of a replicated input-guarded process 
(called a trigger process). We use a similar 
replicated triggered process 
to encode \HOp into \sessp (\defref{d:enc:hopitopi}).
 Operational correspondence for
the triggered encoding is shown using a context bisimulation
with first-order labels.
%Although contextual bisimilarity has a satisfactory discriminative power,
%its use is hindered by the universal quantification on output clauses.
To deal with the issue of context biimilarity, 
Sangiorgi proposes \emph{normal bisimilarity}, 
a tractable  equivalence without universal quantification. 
To prove that context and normal bisimilarities coincide,~\cite{SangiorgiD:expmpa} uses 
triggered processes.
%The encoding also motivates the definition of a form of
Triggered bisimulation is also defined on first-order labels
where the contextual bisimulation is restricted to arbitrary
trigger substitution. %rather than arbitrary process substitutions.
This
characterisation of context bisimilarity  was refined in~\cite{JeffreyR05} for
calculi with recursive types, not addressed in~\cite{San96H,SangiorgiD:expmpa} and
relevant in our work.
The
bisimulation in~\cite{JeffreyR05}
is based on an LTS which is extended with trigger meta-notation.
%for a full higher-order $\pi$-calculus that allows
%higher-order applications.
As in~\cite{San96H,SangiorgiD:expmpa}, 
the LTS in~\cite{JeffreyR05}
observes first-order triggered values instead of
higher-order values, offering a more direct characterisation of contextual equivalence
and lifting the restriction to finite types.
We briefly contrast 
the approach in~\cite{JeffreyR05} and our approach based on 
\dk{higher-order ($\hwb$) and} characteristic ($\fwb$) bisimilarities:
\begin{enumerate}[$\bullet$]
%\begin{enumerate}[i.]
\item 
The LTS in~\cite{JeffreyR05} is enriched with extra labels for triggers;
an output action transition emits a trigger and introduces a parallel replicated trigger.
Our 
approach retains usual labels/transitions; in  case of output,
our bisimilarities introduce a parallel
non-replicated trigger.
\item Higher-order input in~\cite{JeffreyR05} involves 
the input of a trigger which reduces after substitution.
Rather than a trigger name, our bisimulations  
decree the input of a triggered value $\abs{z}\binp{t}{x} \appl{x}{z}$.
\item Unlike~\cite{JeffreyR05}, 
our $\fwb$ treats  
first- and higher-order values uniformly. In the latter case, 
since the typed LTS distinguishes between linear and shared values, 
replicated closures are used only for shared values.

\item In~\cite{JeffreyR05} a matching construct is
crucial to prove completeness of bisimilarity,
while our language lacks matching. 
%Contrarily 
\jpc{In contrast,} 
we use the characteristic
process interaction with the environment, exploring 
session type structures, i.e., instead of
name matching a name is embedded into a process and then observe its behaviour.

\end{enumerate}

The work~\cite{DBLP:conf/lics/SangiorgiKS07} defines \emph{environmental bisimulations},
which 
%Sangiorgi et al.~\cite{DBLP:conf/lics/SangiorgiKS07}, 
use a higher-order LTS 
to define a bisimulation that stores the knowledge known to
the observer; hence, observed actions are based on the observer's knowledge
at any given time. This approach is enhanced in~\cite{DBLP:journals/cl/KoutavasH12,DBLP:conf/esop/KoutavasH11}
where a mapping from constants to higher-order values is introduced. This 
allows to observe first-order values instead
of higher-order values. It differs from~\cite{San96H,JeffreyR05} in that 
the mapping between higher- and first-order values is no longer implicit.


\iftodo \NY{Dimitiris needs to ingegrate with the above.}
\myparagraph{Typed Behavioural Equivalences.}
The current work follows the principles for
session type behavioural semantics that were laid
by the previous works of the
authors~\cite{dkphdthesis,KYHH2015,KY2015}.
A bisimulation relation is defined on a labelled
transition system that assumes a session typed
observer.
The bisimilarity is characterised by the corresponding
reduction-closed, barbed congruence using a
proof technique that is derived from~\cite{Hennessy07}.
The theory for higher-order session types developed here
differentiates from 
the work in~\cite{dkphdthesis,KYHH2015,KY2015}, which 
considers the behavioural semantics for first-order
binary and multiparty session types.
Also the work \cite{DBLP:journals/iandc/PerezCPT14} studies typed behavioural equivalencies for binary session types.
The underlying process languages does not have shared names which, as we have shown, strictly add expressive power. 
Moreover, for this deterministic language, confluence and $\tau$-inertness properties are established.

%The theory for higher-order session type quivalences is more challenging than
%their corresponding first-order bisimulation theory.
To cope with the challenges presented by the higher-order
session theory, 
our approach continues the line of research 
originally drawn by Sangiorgi~\cite{San96H,SangiorgiD:expmpa}
and later improved by Jeffrey and Rathke~\cite{DBLP:journals/lmcs/JeffreyR05}.
The works %Sangiorgi as part of his Ph.D.~research
\cite{San96H,SangiorgiD:expmpa}
introduced the first fully abstract encoding from the higher-order 
$\pi$-calculus to the $\pi$-calculus. 
The replicated triggered process 
is also used in this work for the encoding of \HOp into \sessp (\defref{def:enc:HOp_to_p}).
Sangiorgi's encoding is based on the idea of a replicated input guarded process 
(called a trigger process). Operational correspondence for
the triggered encoding is shown using the contextual bisimulation
with first-order labels.
Although contextual bisimilarity has a satisfactory discriminative power,
its use is hindered by the universal quantification on output clauses.
Sangiorgi then proposed \emph{normal bisimilarity}, a tractable  equivalence 
on processes without universal quantification. 
To show the coincidence between contextual and normal bisimilarities, 
the use of triggered processes and bisimilarity is developed in \cite{San96H}.
%The encoding also motivates the definition of a form of
Triggered bisimulation is also defined on first-order labels
where the contextual bisimulation is restricted to arbitrary
trigger substitution rather than arbitrary process substitutions.
The triggered bisimulation was further refined by Jeffrey and
Rathke, who study calculi with recursive types, not addressed in~\cite{San96H,SangiorgiD:expmpa} and
relevant in our work.
They introduce their own version of a
bisimulation~\cite{DBLP:journals/lmcs/JeffreyR05}
based on a LTS which is extended with trigger meta-notation.
%for a full higher-order $\pi$-calculus that allows
%higher-order applications.
Like Sangiorgi's approach, the labelled transition semantics
in~\cite{DBLP:journals/lmcs/JeffreyR05}
observes first-order triggered values instead of
higher-order values, offering a more direct characterisation of contextual equivalence
and lifting the restriction to finite types.


There are similarities and differences between of the characteristic bisimulation
and the bisimulation as defined by Jeffrey and Rathke:
%
\begin{enumerate}[i)]
	\item	\cite{DBLP:journals/lmcs/JeffreyR05} extends a first-order
		LTS with a trigger meta-notation whereas in this
		work we use a higher-order LTS
		(below we use the meta-notation adopted in~\cite{DBLP:journals/lmcs/JeffreyR05}).

	\item	The output of a higher-order value $\abs{x}{Q}$ on name
		$n$ in \cite{DBLP:journals/lmcs/JeffreyR05}
		requires the output of
		a fresh trigger name $t$ (notation $\tau_t$)
		on channel $n$ 
		and then the introduction of a replicated triggered process
		(notation $(t \Leftarrow (x) Q)$)
		in the context of the acting process:
		%
		\[
			P \by{\news{t} \bactout{n}{\tau_{t}}} P' \Par (t \Leftarrow (x) Q) \by{\bactinp{t}{v}} P' \Par \appl{(x) Q}{v} \Par (t \Leftarrow (x) Q) 
		\]
		%
		In the characteristic bisimulation approach we only observe
		an output of a value that can be either first- or higher-order:
		%
		\[
			P \hby{\bactout{n}{V}} P' 
		\]
		%
		with $V = \abs{x}{Q}$ or $V = m$.
		A non-replicated triggered process ($\htrigger{t}{V}$)
		appears in
		the parallel context of the acting process when
		we compare two processes for behavioural equality
		(cf.~characteristic bisimulation \defref{def:cbisim}).
		In fact using the LTS in
		\defref{def:typed_transition} we can get:
		%
		\begin{eqnarray*}
			P' \Par \htrigger{t}{\abs{x}{Q}}
			&\by{\abs{z}{\binp{z}{y} \repl{} \binp{t}{x} \appl{y}{x}}}&
			P' \Par \newsp{s}{\binp{s}{y} \repl{} \binp{t}{x} \appl{y}{x} \Par \bout{s}{\abs{x}{Q}} \inact}\\
			&\by{\tau}&
			P' \Par \repl{}\binp{t}{y} \appl{\abs{x}{Q}}{y}
		\end{eqnarray*}
		%
		that simulates the approach in \cite{DBLP:journals/lmcs/JeffreyR05}.

		The characteristic bisimulation output approach differentiates from
		the approach in \cite{DBLP:journals/lmcs/JeffreyR05}:
		\begin{itemize}
			\item	The typed LTS predicts the case of linear
				output values and will never allow replication
				of such a value;
				if $V$ is linear the input action would have no replication
				operator, as
				$\abs{z}{\binp{z}{y} \binp{t}{x} \appl{y}{x}}$.

			\item	The characteristic bisimulation introduces a uniform approach
				not only for
				higher-order values but for first-order values
				as well, i.e.~triggered process can accept any
				process that can substitute a first-order value as well.
				This is derived from the fact that the $\HOp$
				calculus makes no use of a matching operator, in contrast
				to the calculus defined in \cite{DBLP:journals/lmcs/JeffreyR05})
				where name matching is crucial to prove completeness
				of the bisimilarity relation.
				We chose not to include the matching operator
				because of the requirement of a minimal calculus.
				In the lack of matching we use types to inhabit
				a value so to observe its simplest interaction
				with the environment.

			\item	The \HOp calculus requires only first-order
				applications. Higher-order applications,
				as in \cite{DBLP:journals/lmcs/JeffreyR05},
				are presented as an extension in the \HOpp
				calculus.

			\item	The trigger process is non-replicated. In fact
				the trigger process guards the output
				value with a higher-order input prefix. The
				functionality of the input is then used to
				simulate the contextual bisimilarity that subsumes
				the replicated trigger approach (cf.~\secref{subsec:char_bis}).
				The transformation of an output action as an input
				action allows for treating an output
				using the restricted LTS (\defref{def:restricted_typed_transition}):
				%
				\[
					P' \Par \htrigger{t}{\abs{x}{Q}} \hby{\bactinp{t}{\abs{x}{\mapchar{U}{x}}}}
					P' \Par \news{s}{ \appl{\mapchar{U}{x}}{s} \Par \bout{\dual{s}}{\abs{x}{Q}} \inact}
				\]
		\end{itemize}
		%
		%In essence we are transforming a replicated trigger into a process
		%that is input-prefixed on a fresh name that receives a higher-order
		%value;

	\item	The input of a higher-order value in the \cite{DBLP:journals/lmcs/JeffreyR05}
		requires 
		the input of a meta-syntactic fresh trigger, which then
		substituted on the application variable, thus the meta-syntax
		is extended to represent applications, e.g.:
%		for triggered application instead
%		of higher-order applications:
		%
		\[
			\binp{n}{x} P \by{\bactinp{n}{\tau_k}} \appl{(\abs{x}{P})}{\tau_k} \by{\tau} P \subst{x}{\tau_k} 
		\]
		%
		Every instance of process variable $x$ in $P$ being substituted
		with trigger value $\tau_k$ to give an application of the form $\appl{\tau_k}{x}$.
		In contrast the approach in the characteristic bisimulation observes the
		triggered value
		$\abs{z}\binp{t}{x} \appl{x}{z}$ as an input instead of the
		meta-syntaxtic trigger:
		%
		\[
			P \hby{\bactinp{n}{\abs{z}\binp{t}{x} \appl{x}{z}}} P \subst{\abs{z}\binp{t}{x} \appl{x}{z}}{x}
		\]
		%
		Every instance of process variable $x$ in $P$
		is substituded to give application of the form
		$\appl{(\abs{z}{\binp{t}{x} \appl{x}{z}})}{v}$
		Note that in the characteristic bisimulation semantics
		we can also observe a characteristic process as an input.
		
	\item 	Triggered applications in~\cite{DBLP:journals/lmcs/JeffreyR05}
		are observed as an output of the application
		value over the fresh trigger name:
%		using an output
%		lead into an output observation of the
%		application value over
%		the fresh trigger name.
		%
		\[
			\appl{\tau_k}{v} \by{\bactout{k}{v}} \inact
		\]
		%
		In constrast in the characteristic bisimulation
		we have two kind of applications:
		i) the trigger value application allows us
		to simulate an application on a fresh trigger name.
		ii) the characteristic value application
		allows us to inhabit an application value 
		and observe the interaction its interaction
		with the environment
%		of 
		%instead of observing an 
		%application and its value as an action we observe:
%		i) allows us to observe a trigger name
%		through the trigger value application; and
%		ii) we observe the application
%		value by inhabiting it in the characteristic value
%		and observing the interaction of the corresponding
%		characteristic process with its environment.
		%
		\begin{eqnarray*}
			\appl{(\abs{z}{\binp{t}{x} \appl{x}{z}})}{v} &\by{\tau}& \binp{t}{x} (\appl{x}{v})
			\by{\bactinp{t}{\abs{x}{\mapchar{U}{x}}}}
			\appl{(\abs{x}{\mapchar{U}{x}})}{v}
			\by{\tau} \mapchar{U}{x} \subst{n}{x}
		\end{eqnarray*}
		%
\end{enumerate}

%The main differences of the triggered
%bisimulation approach comparing to our approach are:
%i) We use observe higher-order values on the LTS in contrast to first-order 
%values in~\cite{DBLP:journals/lmcs/JeffreyR05}.
%ii) In our approach we avoid the replicated triggered process,
%by transforming the output process into a higher-order guarded input.
%iii) The triggered bisimulation gives semantics for higher-order application,
%whereas in our approach we give semantics for first-order applications
%and show that higher-order applications are fully encodable.

%Boreale and Sangiorgi, 
%Deng and Hennessy, 
%Jeffrey and Rathke, Hennessy and Koutavas, Schmitt and Lenglet, Pi\E9rard and Sumii.
%Perez et al (bisimilarities for binary sessions), Kouzapas and Yoshida (bisimilarities for binary and multiparty sessions).
%Bisimilarities for HO processes: \cite{Xu07}.
\else\fi
