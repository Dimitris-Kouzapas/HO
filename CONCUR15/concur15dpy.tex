%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% CONCUR VERSION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,UKenglish]{lipics}
%This is a template for producing LIPIcs articles. 
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
% for section-numbered lemmas etc., use "numberwithinsect"
 
\usepackage{microtype,xspace,enumerate,comment,stmaryrd}%if unwanted, comment out or use option "draft"
\usepackage{mathpartir}
%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory
\input{macros}
%\bibliographystyle{plain}% the recommended bibstyle
\theoremstyle{definition}

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Characteristic Bisimulations for Higher-Order Session Processes}
\titlerunning{Characteristic Bisimulations for Higher-Order Session Processes} %optional, in case that the title is too long; the running title should fit into the top page column

\author[1,2]{Dimitrios Kouzapas}
\author[3]{Jorge A. P\'{e}rez}
\author[1]{Nobuko Yoshida}
\affil[1]{Imperial College London, UK
%\\ \url{yoshida@doc.ic.ac.uk}
}
\affil[2]{University of Glasgow, UK
%\\ \url{Dimitrios.Kouzapas@glasgow.ac.uk}
}
\affil[3]{University of Groningen, The Netherlands 
%\\ \url{j.a.perez@rug.nl}
}

\authorrunning{D. Kouzapas, J.\,A. P\'{e}rez and N. Yoshida} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'

\Copyright{Dimitrios Kouzapas, Jorge A. P\'{e}rez and Nobuko Yoshida}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\subjclass{
F.3.1 Specifying and Verifying and Reasoning about Programs;
F.3.2 Semantics of Programming Languages.
}
%Dummy classification -- please refer to \url{http://www.acm.org/about/class/ccs98-html}}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation". 
\keywords{Behavioral equivalences, session types,
 higher-order process calculi.}% mandatory: Please provide 1-5 keywords
%% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\serieslogo{}%please provide filename (without suffix)
%\volumeinfo%(easychair interface)
%  {Billy Editor and Bill Editors}% editors
%  {2}% number of editors: 1, 2, ....
%  {Conference title on which this volume is based on}% event
%  {1}% volume
%  {1}% issue
%  {1}% starting page number
%\EventShortName{CONCUR}
\DOI{10.4230/LIPIcs.xxx.yyy.p}% to be completed by the volume editor
%% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{tikz}
\usetikzlibrary{calc}


\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Abstract
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
Characterising 
contextual equivalence is a long-standing issue for higher-order (process) languages. 
In the setting of a higher-order $\pi$-calculus with sessions, 
we develop \emph{characteristic bisimilarity}, 
a typed bisimilarity which fully characterises contextual equivalence.
To our knowledge, ours is the first characterisation of its kind.
Using simple values inhabiting (session) types, 
our approach distinguishes from untyped methods for 
characterising contextual equivalence in higher-order processes:
we show that observing as inputs only a precise finite set of higher-order values suffices 
to reason about higher-order session processes. 
We demonstrate how characteristic bisimilarity can be used to justify optimisations in session protocols with mobile code communication.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{sec:intro}

\subparagraph{Context.}
In \emph{higher-order process calculi} 
communicated
values %exchanged in communications 
may contain  processes.
Higher-order concurrency has received significant attention 
from untyped and typed perspectives (see, e.g.,~\cite{SangiorgiD:expmpa,JeffreyR05,DBLP:journals/iandc/LanesePSS11,DBLP:journals/cl/KoutavasH12,MostrousY15}).
 In this work, we consider \HOp, a higher-order process calculus with \emph{session primitives}:
in addition to 
functional
abstractions/applications (as in the call-by-value $\lambda$-calculus), \HOp 
contains constructs for 
synchronisation on shared names, 
  session communication on linear names, 
  %(value passing, labelled choice), 
  and recursion.
Thus, \HOp processes may specify %reciprocal exchanges (protocols) 
protocols
for higher-order  processes that
 can be 
 %verified via type-checking 
 type-checked 
 using \emph{session types}~\cite{honda.vasconcelos.kubo:language-primitives}.
Although models of session 
communication with % higher-order features 
process passing
exist~\cite{tlca07,DBLP:journals/jfp/GayV10},
their  \emph{behavioural equivalences} 
%and \emph{relative expressiveness}
remain little understood. 
Since types can limit the contexts (environments) in which processes can interact, typed equivalences
usually offer {\em coarser} semantics than untyped semantics.
Hence, clarifying the status of these equivalences is key to, e.g., 
justify non-trivial  optimisations in protocols involving both name- and process-passing.
 

A well-known behavioural equivalence for higher-order processes
is \emph{context bisimilarity}~\cite{San96H}. This 
 characterisation of %reduction-closed, 
barbed congruence 
offers an adequate distinguishing power at the price of heavy universal quantifications in output clauses.
Obtaining alternative 
characterisations of context bisimilarity
is thus a recurring, important problem 
for higher-order calculi---see, e.g.,~\cite{SangiorgiD:expmpa,San96H,JeffreyR05,DBLP:journals/cl/KoutavasH12}. %,DBLP:journals/corr/Xu13a}. 
In particular, Sangiorgi~\cite{SangiorgiD:expmpa,San96H} has 
given %important 
%useful
characterisations of context bisimilarity
for higher-order processes; such 
characterisations, however,  %in~\cite{SangiorgiD:expmpa,San96H} 
do not scale to  
  calculi with \emph{recursive types}, which %in our experience 
  are essential to %the practice of 
session-based concurrency. A characterisation  
%context bisimilarity 
that solves this limitation was developed by Jeffrey and Rathke in~\cite{JeffreyR05}.

\subparagraph{This Work.}
Building upon~\cite{SangiorgiD:expmpa,San96H,JeffreyR05}, 
our discovery is that \emph{linearity} of session types plays a vital role 
in solving 
the %long-standing, 
open problem of characterising context bisimilarity for higher-order mobile processes with session communications.
Our approach is to exploit 
%protocol specifications given by session types to limit 
the coarser semantics induced by session types to limit
the behaviour of higher-order session processes. 
 Formally, we enforce this limitation by defining
a \emph{refined} labelled transition system (LTS)
which effectively 
narrows down the spectrum of allowed process behaviours, 
exploiting elementary processes inhabiting session types.
%thus enabling tractable reasoning techniques. 
We then introduce \emph{characteristic bisimilarity}: this  
 new notion of typed bisimilarity   is 
\emph{tractable}, in that 
it relies on the refined LTS for input actions and, more importantly, 
does not appeal to universal quantifications on output actions. 
%shown to coincide with context bisimilarity.
Our main result is that characteristic  %tractable
bisimilarity coincides with context bisimilarity.
Besides confirming the value of characteristic bisimilarity as an useful reasoning technique for 
higher-order processes with sessions,
%for  specifications of trivial practical scenarios, 
this result is 
%also technically 
remarkable 
also from a technical perspective, for associated 
completeness proofs do not require 
operators for 
name-matching,
% in the process language, 
in contrast to untyped methods for  higher-order processes
with recursive types~\cite{JeffreyR05}.
%Remarkably session type structures enable to provide 
%a coincidence without name-matching operators in the calculi.

%\smallskip 
We explain how we exploit session types to 
define characteristic bisimilarity.
Key notions are \emph{triggered} and \emph{characteristic processes/values}.
Below, we 
write $\binp{s}{x}{P}$ 
for an input on %(linear) 
endpoint $s$, 
and $\bout{\dual{s}}{V} Q$
for an output of value $V$ 
on endpoint $\dual{s}$ (the \emph{dual} of~$s$).
Also, $R \by{\bactinp{s}{V}} R'$ denotes an input transition along $n$
and
$R \by{\news{\widetilde{m}} \bactout{s}{V}} R'$
denotes an output transition along $s$, 
sending value $V$, and extruding names $\widetilde{m}$. 
Weak transitions are as usual.
Throughout the paper, we write $\Re, \Re',\ldots$ to denote binary relations on (typed) processes.


%\smallskip
\subparagraph{Issues of Context Bisimilarity.}
Context bisimilarity ($\wbc$, \defref{def:wbc}) is an overly demanding relation on higher-order processes. 
There are two issues, associated to demanding clauses for output and input actions. 
%The first demanding issue arises from the universal quantification on the output clause of context bisimilarity:
A \emph{first issue} %appears in 
is 
the universal quantification on the output clause of context bisimilarity.
Suppose $P \,\Re\, Q$, for some context bisimulation~$\Re$. We have:
\begin{enumerate}[$(\star)$]
	\item	Whenever 
		$P \by{\news{\widetilde{m_1}} \bactout{s}{V}} P'$
		there exist
		$Q'$ and $W$
		such that 
		$Q \By{\news{\widetilde{m_2}} \bactout{s}{W}} Q'$
		and, \\ \emph{\textbf{for all} $R$}  with $\fv{R}=x$, 
		$\newsp{\widetilde{m_1}}{P' \Par R\subst{V}{x}} \,\Re\, \newsp{\widetilde{m_2}}{Q' \Par R\subst{W}{x}}$.
\end{enumerate}

\noi The \emph{second issue} is due to inputs: it  
%appears in input clauses, and 
follows from 
the fact that we work with an \emph{early}
labelled transition system (LTS). Thus, %a higher-order 
an input prefix may observe
infinitely many different values.
To alleviate this burden,
%induced by 
%universal quantification,
in %our notion of
\emph{characteristic
bisimilarity} ($\fwb$)
we take two (related) steps: 
\begin{enumerate}[(a)]
	\item We replace $(\star)$ with a clause involving a \emph{more tractable} process closure; and 
	\item We refine  inputs % transitions 
	to avoid observing infinitely many actions on the same input prefix.
\end{enumerate}




\subparagraph{Trigger Processes.} % with Session Communication.}
To address~(a), we exploit session types. 
We first 
observe that closure $R\subst{V}{x}$ 
in $(\star)$
is context bisimilar to the process
%\begin{equation}\label{equ:1}
	$P = \newsp{s}{\appl{(\abs{z}{\binp{z}{x}{R}})}{s} \Par \bout{\dual{s}}{V} \inact}$.
%\end{equation}
%\noi 
In fact,
we do have $P \wbc R\subst{V}{x}$, 
since 
application and 
reduction of 
dual endpoints 
%($s$ and $\dual{s}$) 
are deterministic.  

Now let us
consider process $T_{V}$ below, where $t$ is a fresh name.  
%\begin{equation}\label{equ:0}
%\end{equation}
%We call $\abs{z}{\binp{z}{x} R}$ a {\bf\em trigger value}. 
If $T_{V}$ inputs value $\abs{z}{\binp{z}{x} R}$ then
we can simulate the closure of $P$:
\begin{equation}\label{equ:2}
%\hotrigger{t}{V_1} 
T_{V} = \hotrigger{t}{x}{s}{V} \quad\mbox{and}\quad 
T_{V}
\by{\bactinp{t}{\abs{z}{\binp{z}{x} R}}} P 
\wbc 
R\subst{V}{x}
\end{equation}
Processes such as $T_{V}$ 
offer a value at a fresh name; this class of 
{\bf\em trigger processes} 
already suggests a tractable formulation of 
bisimilarity without the demanding 
%output 
clause $(\star)$. 
%However, 
%Trigger p
Process $T_{V}$ in~\eqref{equ:2} requires a higher-order communication along $t$.
%As we explain now, we can do better than this; the key is using \emph{elementary inhabitants} of session types.
As we explain below, we can give an alternative trigger process; the key is using \emph{elementary inhabitants} of session types.
%Given a fresh name $t$, we write $\htrigger{t}{V}$ to  stand for a trigger process $T_{V}$ for value $V$.

\smallskip

%Then we can use 
%$\newsp{\tilde{m_1}}{P_1 \Par \htrigger{t}{V_1}}$ instead 
%of Clause 1) in Definition \ref{def:wbc} if we input 
%$\abs{z}{\binp{z}{x} R}$.   

\subparagraph{Characteristic Processes and Values.}
To address (b), we limit the possible 
input values (such as $\abs{z}{\binp{z}{x} R}$ above) %processes 
by exploiting session types.
The key concept is that of {\bf \emph{characteristic process/value}}
of a type,  
%The characteristic process of a session type $S$ is the process inhabiting $S$. 
the 
simplest term inhabiting that type (\defref{def:char}).
This way, for instance, let $S = \btinp{\shot{S_1}} \btout{S_2} \tinact$
be a session type: first
input an abstraction, %from values $S_1$ to processes, 
then output a value of type $S_2$.
Then, process $\binp{u}{x} (\bout{u}{s_2} \inact \Par \appl{x}{s_1})$
is a characteristic process for $S$ 
\jpc{along $u$.}
%Thus, characteristic processes follow the communication structures decreed by session types.
Given a session type $S$, we write $\mapchar{S}{u} $
for its characteristic process along   $u$
(cf.~\defref{def:char}).
Also, %Similarly, 
given value type $U$, then
$\omapchar{U}$ denotes its characteristic value.
As we explain now, we use 
%the %characteristic %Precisely, we exploit  the
% characteristic value %$\lambda x.\mapchar{U}{x}$. %$\lambda x.\mapchar{U}{x}$. 
$\omapchar{U}$
 to limit input transitions.

\subparagraph{Refined Input Transitions.}
To refine  input transitions, we need to observe 
an additional value, 
$\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}$, 
called the {\bf\em trigger value}. 
This is necessary: it turns out
that a characteristic value 
alone as the observable input 
is not enough to define a sound bisimulation (cf. \exref{ex:motivation}).
Intuitively, the trigger value is used
to observe/simulate application processes.
%to {\em count} the number of free higher-order variables inside 
%the receiver. 
%\jpc{See Example~\ref{ex:motivation} for further details.}
Based on the above discussion, we refine 
the transition rule for input actions (cf. \defref{def:rlts}). 
%We write $P \by{\bactinp{n}{V}} P'$ for the input transition along $n$.
Roughly, the 
refined
rule 
is:
%\[
%\tree {
%	P \by{\bactinp{n}{V}} P' \quad 
%	V = m \vee V \scong \abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}
%	\vee  V \scong \omapchar{U}  \textrm{ with } t \textrm{ fresh} 
%}{
%	P' \hby{\bactinp{n}{V}} P'
%}
%\]
$$
\boxed{
~~P \by{\bactinp{s}{V}} P' \,\land\, (V = m \vee V \scong \abs{{x}}{\binp{t}{y} (\appl{y}{{x}})} \vee  V \scong \omapchar{U}  \textrm{ with } t \textrm{ fresh}) ~~\Rightarrow~~
P' \hby{\bactinp{s}{V}} P'~~}
$$
\noi
Note the distinction between standard and refined transitions: $\by{\bactinp{s}{V}}$ vs. $\hby{\bactinp{s}{V}}$.
Our refined  rule for \jpc{(higher-order)} input admits only names, trigger values, and characteristic values.
Using this rule, we define an alternative, refined  LTS on typed processes: 
we use it to define
%both higher-order ($\hwb$) and 
characteristic  bisimulation 
%(Defs.~\ref{d:hbw} and~\ref{d:fwb}),
($\fwb$, Def.~\ref{d:fwb}),
in which the demanding clause~$(\star)$ is replaced with 
a more tractable output clause based on 
%trigger processes \jpc{(cf.~\eqref{equ:2})}  and 
characteristic 
trigger processes
\jpc{(cf.~\eqref{eq:4})}.
%respectively.
%We show that $\hwb$ is useful for \HOp and \HO, and that~$\fwb$ can be uniformly used in all subcalculi, including \sessp. 


\subparagraph{Characteristic Triggers.}
Following the same reasoning as (\ref{equ:2}), 
we can use an alternative trigger process, called
{\bf\em characteristic trigger process} with type 
$U$ to replace clause
% (1) in Definition~\ref{def:wbc}:
($\star$): % in \defref{def:wbc}:
\begin{equation}
	\label{eq:4}
	\boxed{
	~~\ftrigger{t}{V}{U} \defeq \fotrigger{t}{x}{s}{\btinp{U} \tinact}{V}~~
	}
\end{equation}

%Note that if $U=L$, $\ftrigger{t}{V}{U}$ subsumes 
%$\htrigger{t}{V}$. 
\noi
This is justified because in~\eqref{equ:2} $T_V \hby{\bactinp{t}{\omapchar{\btinp{U} \tinact}}} \wbc \newsp{s}{\mapchar{\btinp{U} \tinact}{s} \Par \bout{\dual{s}}{V} \inact }$.
\noi 
\jpc{Thus, unlike process~\eqref{equ:2}, the characteristic trigger process 
in~\eqref{eq:4}
does not involve a
higher-order communication on %fresh name 
$t$.}
In contrast to previous approaches~\cite{SangiorgiD:expmpa,JeffreyR05} 
our %{trigger processes} 
 characteristic trigger processes 
do {\em not} use recursion or 
replication. This is key to preserve linearity of session endpoints.  


\NY{It is also noteworthy that \HOp lacks name matching, 
which is usually crucial to prove completeness of bisimilarity---see, e.g.,~\cite{JeffreyR05}.
Instead of matching, we use types:
a process trigger embeds a name into a characteristic
process so to observe its session behaviour.}

\subparagraph{Outline.}
%This paper  is structured as follows.
%\begin{enumerate}[$\bullet$]
%\item 
Next we present
the %higher-order 
session calculus \HOp. 
%A small example is given in \S\,X.
\secref{sec:types} gives the session type system for \HOp
and states type soundness.
%\item 
\secref{sec:behavioural} 
develops %\emph{higher-order} and 
\emph{characteristic} bisimilarity and 
%which alleviates the issues of context bisimilarity~\cite{San96H} and 
states our main result: characteristic and context bisimilarities coincide for 
%is shown  to coincide for 
well-typed \HOp processes (\thmref{the:coincidence}).
\secref{sec:relwork}~concludes with related works. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Calculus
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{A Higher-Order Session $\pi$-Calculus}
\label{sec:calculus}

\noindent 
We introduce the %syntax and semantics of the 
\emph{Higher-Order Session $\pi$-Calculus} (\HOp).
\HOp includes both name- and abstraction-passing, shared and session communication,  
as well as recursion; it is 
essentially 
the  language
proposed 
in~\cite{tlca07} (where tractable bisimilarities are not addressed). 

\smallskip

 


	\begin{figure}
	\[
		\begin{array}{rcl}
			u,w &\bnfis& n \bnfbar x,y,z \qquad
			n \bnfis a,b  \bnfbar s, \dual{s} \qquad 
			V,W  \bnfis u \bnfbar \abs{x}{P} \\[1mm]
			P,Q & \bnfis & \bout{u}{V}{P}  \bnfbar  \binp{u}{x}{P} \bnfbar
			\bsel{u}{l} P \bnfbar \bbra{u}{l_i:P_i}_{i \in I}   \\[1mm]
			& \bnfbar & \rvar{X} \bnfbar \recp{X}{P} \bnfbar \appl{V}{W} \bnfbar P\Par Q \bnfbar \news{n} P \bnfbar \inact
		\end{array}
	\]
	\[
	\begin{array}{c}
		P \Par \inact \scong P
		\quad
		P_1 \Par P_2 \scong P_2 \Par P_1
		\quad
		P_1 \Par (P_2 \Par P_3) \scong (P_1 \Par P_2) \Par P_3
		\quad 
		\recp{X}{P} \scong P\subst{\recp{X}{P}}{\rvar{X}}
		\\%[1mm]

		\news{n} \inact \scong \inact
		\qquad 
		P \Par \news{n} Q \scong \news{n}(P \Par Q)
		\	(n \notin \fn{P})
		\qquad
		P \scong Q \textrm{ if } P \scong_\alpha Q
	\end{array}
\]
	\[
		\!\!\!\begin{array}{lllcrll}
			\orule{App} & (\abs{x}{P}) \, V   \red    P \subst{V}{x}
			& 
			  

			\orule{Pass} & \bout{n}{V} P \Par \binp{\dual{n}}{x} Q   \red   P \Par Q \subst{V}{x} 
			
			\\[1mm]

			 \orule{Res} & P \red P'  \Rightarrow  \news{n} P  \red  \news{n} P' 

			&  
			\orule{Sel}
			&  \!\!\! \bsel{n}{l_j} Q \Par \bbra{\dual{n}}{l_i : P_i}_{i \in I}  \red   Q \Par P_j ~~(j \in I)
			
			\\[1mm]
			\orule{Par} & P \red P'   \Rightarrow    P \Par Q  \red   P' \Par Q  
			&  
			\orule{Cong} & P \scong Q \red Q' \scong P'   \Rightarrow  P  \red  P' 
	\end{array}
	\]
	%\vspace{-3mm}
\caption{$\HOp$: Syntax and Operational Semantics (Structural Congruence and Reduction).
\label{fig:redsem}}
%\Hlinefig
	%\vspace{-2mm}
\end{figure}

\subparagraph{Syntax.} 
The syntax of \HOp is defined in \figref{fig:redsem} (upper part).
We use $a,b,c, \dots$ (resp.~$s, \dual{s}, \dots$) 
to range over shared (resp. session) names. 
We use $m, n, t, \dots$ for session or shared names. 
We define the dual operation over names $n$ as $\dual{n}$ with
$\dual{\dual{s}} = s$ and $\dual{a} = a$.
Intuitively, names $s$ and $\dual{s}$ are dual  \emph{endpoints} while 
shared names represent non-deterministic points. 
Variables are denoted with $x, y, z, \dots$, 
and recursive variables are denoted with $\varp{X}, \varp{Y} \dots$.
An abstraction %(or higher-order value) 
$\abs{x}{P}$ is a process $P$ with name parameter $x$.
%Symbols $u, v, \dots$ range over identifiers; and  $V, W, \dots$ to denote values. 
Values $V,W$ include 
identifiers $u, v, \ldots$ %(first-order values) 
and 
abstractions $\abs{x}{P}$ (first- and higher-order values, resp.). 

{Terms} 
include $\pi$-calculus constructs for sending/receiving values $V$.
Process $\bout{u}{V} P$ denotes the output of   $V$
over name $u$, with continuation $P$;
process $\binp{u}{x} P$ denotes the input prefix on name $u$ of a value
that 
will substitute variable $x$ in continuation $P$. 
Recursion %is expressed by 
$\recp{X}{P}$
%which 
binds the recursive variable $\varp{X}$ in process $P$.
Process 
%ny
%$\appl{x}{u}$ 
$\appl{V}{W}$ 
is the application
which substitutes values $W$ on the abstraction~$V$. 
\dk{Typing  ensures \jpc{that} $V$ is not a name.}
Processes $\bbra{u}{l_i: P_i}_{i \in I}$  and $\bsel{u}{l} P$ define labelled choice:
given a finite index set $I$, process $\bbra{u}{l_i: P_i}_{i \in I}$ offers a choice 
among processes with pairwise distinct labels;
%on labels $l_i$ with continuation $P_i$, given that $i \in I$.
 process $\bsel{u}{l} P$ selects label $l$ on name $u$ and then behaves as $P$.
%Given $i \in I$ 
%Others are standard c
Constructs for 
inaction $\inact$,  parallel composition $P_1 \Par P_2$, and 
name restriction $\news{n} P$ are standard.
Session name restriction $\news{s} P$ %simultaneously 
binds endpoints $s$ and $\dual{s}$ in $P$.
%A well-formed process relies on assumptions for
%guarded recursive processes.
We use $\fv{P}$ and $\fn{P}$ to denote sets of free 
%\jpc{recursion}
variables and names; 
we assume $V$ in $\bout{u}{V}{P}$ does not include free recursive 
variables. % $\rvar{X}$. 
If $\fv{P} = \emptyset$, we call $P$ {\em closed}.
%; and closed $P$ without 
%free session names a {\em program}. 



 \subparagraph{Semantics.}
%	\label{subsec:semantics}
	\figref{fig:redsem} (lower part) defines the operational semantics 
of \HOp, given as
%We define 
a reduction relation that relies 
on 
a \emph{structural congruence} $\scong$. %, in the standard way. % are defined in \figref{fig:reduction} (bottom). 
\jpc{We assume the expected extension of $\scong$ to values $V$.}
Reduction is denoted $\red$; some intuitions on the rules in \figref{fig:redsem} %(lower part) 
follow.
Rule~$\orule{App}$ is a value application; 
rule~$\orule{Pass}$ defines a shared interaction at $n$ 
(\jpc{with} $\dual{n}=n$) or a session interaction;  
rule~$\orule{Sel}$ is the standard rule for labelled choice/selection:
given an index set $I$, 
a process selects label $l_j$ on name $n$ over a set of
labels $\set{l_i}_{i \in I}$ offered by a branching 
on the dual endpoint $\dual{n}$; and other rules are standard.
We write $\red^\ast$ for a multi-step reduction. 


%\begin{example}
\begin{example}[Hotel Booking Scenario]\label{exam:proc}
To illustrate \HOp and its expressive power, 
we consider a usecase scenario that adapts the example given by Mostrous and Yoshida~\cite{tlca07,MostrousY15}.
The scenario involves a $\Client$ process that wants to book
a hotel room. % for her holidays. % in a remote island
%The Client 
$\Client$
narrows the choice down to two hotels, and requires 
 a quote from the two in order to
decide. The round-trip time (RTT) required for
taking quotes from the two hotels is not optimal, % (cf.~\cite{MostrousY15}),
so the client sends mobile processes to both hotels
to automatically negotiate and book a room. 

We now present two \HOp implementations of this scenario.
For convenience, we write $\If e\ \Then (P_1\ \Else \ P_2)$ 
to denote a conditional process that executes $P_1$ or $P_2$ depending on boolean expression $e$ (encodable using labelled choice).
The \emph{first implementation} is  as follows:
%
%\[
	\begin{eqnarray*}%{rcl}
		 P_{xy}  \!\!\! & \defeq &  \!\!\! \bout{x}{\rtype} \binp{x}{\Quote} \bout{y}{\Quote}
		y \triangleright \left\{
				\begin{array}{l}
					\accept: \bsel{x}{\accept} \bout{x}{\creditc} \inact,\\
					\reject: \bsel{x}{\reject} \inact
				\end{array}
				\right\}
		\\ %[3mm]
		 \Client_1 \!\!\!\!\! & \defeq  &  \!\!\! \newsp{h_1, h_2}{\bout{s_1}{\abs{x}{P_{xy} \subst{h_1}{y}}} \bout{s_2}{\abs{x}{P_{xy} \subst{h_2}{y}}} \inact \Par  \\
		& & 
		\!\!\! \binp{\dual{h_1}}{x} \binp{\dual{h_2}}{y}  \If x \leq y\   \Then (\bsel{\dual{h_1}}{\accept} \bsel{\dual{h_2}}{\reject} \inact \ \Else \ \bsel{\dual{h_1}}{\reject} \bsel{\dual{h_2}}{\accept} \inact )
		}
	\end{eqnarray*}
%\]
%
Process $\Client_1$ sends two abstractions with body $P_{xy}$, one to each hotel, 
		using sessions $s_1$ and $s_2$.
		That is, $P_{xy}$ is the mobile code:
	while
		name $x$ is meant to be instantiated by the hotel as the negotiating
		endpoint, name $y$ is used to interact with $\Client_1$.	
		Intuitively, process $P_{xy}$ (i)  sends the room requirements to the hotel;
		(ii) receives a quote from the hotel;
		(iii) sends the quote to  $\Client_1$;
		(iv) expects a choice from   $\Client_1$ whether to accept or reject the offer;
		(v) if the choice is accept then it informs the hotel and performs the booking;
		otherwise, if the choice is reject then it informs the hotel and ends the session.
				$\Client_1$ instantiates two copies of  $P_{xy}$ as abstractions
		on session $x$. It uses two
		fresh endpoints $h_1, h_2$ to substitute channel $y$
		in $P_{xy}$. This enables communication with the mobile code(s).
		In fact, 
		$\Client_1$ uses the dual endpoints $\dual{h_1}$ and $\dual{h_2}$
		to receive the negotiation
		result from the two remote instances of $P$ and then inform the two
		processes for the final booking decision.

Notice that	the above implementation does not affect
the time needed for the whole protocol to execute,
since the two remote processes are used
to send/receive data to $\Client_1$.

We present now a \emph{second  implementation}
%of the same scenario, 
in which the two mobile processes are meant 
to interact with each other (rather than with the client) to reach to an agreement:
%
\[
	\begin{array}{rcl}
	    R_x & \defeq & \If\ \Quote_1 \leq \Quote_2 \, \Then  (\bsel{x}{\accept} \bout{x}{\creditc} \inact \  \Else \ \bsel{x}{\reject} \inact) \\
		Q_1 &\defeq&	\bout{x}{\rtype} \binp{x}{\Quote_1} \bout{y}{\Quote_1} \binp{y}{\Quote_2} R_x \\
		Q_2 &\defeq&	\bout{x}{\rtype} \binp{x}{\Quote_1} \binp{y}{\Quote_2} \bout{y}{\Quote_1} R_x \\
%			&&
%				\begin{array}{ll}
%					\If\ \Quote_1 \leq \Quote_2 &\Then  \bsel{x}{\accept} \bout{x}{\creditc} \inact \  \Else \ \bsel{x}{\reject} \inact %\\
%				%	 & \Else \bsel{x}{\reject} \inact
%				\end{array}
%		\\
%		Q_2 &\defeq&	\bout{x}{\rtype} \binp{x}{\Quote_1} \binp{y}{\Quote_2} \bout{y}{\Quote_1}\\
%			&&
%				\begin{array}{ll}
%					\If\ \Quote_1 \leq \Quote_2  & \Then \bsel{x}{\accept} \bout{x}{\creditc} \inact\\
%					 & \Else \bsel{x}{\reject} \inact
%				\end{array}
%		\\
		\Client_2 &\defeq& \newsp{h}{\bout{s_1}{\abs{x}{Q_1 \subst{h}{y}}} \bout{s_2}{\abs{x}{Q_2 \subst{\dual{h}}{y}}} \inact}
	\end{array}
\]
%\end{example}
Processes $Q_1$ and $Q_2$  negotiate a quote from the
		hotel in the same fashion as process $P_{xy}$ in $\Client_1$.
%		Notice that $Q_2$ is defined exactly as $Q_1$ except for the sequence of messages on~$y$:
%		rather than 
%		sending $\Quote_1$ first and receiving $\Quote_2$ later, 
%		process $Q_2$ receives $\Quote_2$ first and sends $\Quote_1$ later.
		The key difference with respect to $P_{xy}$ is that $y$ is used for
		interaction between process $Q_1$ and $Q_2$. Both processes send
		their quotes to each other and then internally follow the same
		logic to reach to a decision.
		Process  $\Client_2$ then uses sessions $s_1$ and $s_2$ to send the two
		instances of $Q_1$ and $Q_2$ to the two hotels, using them 
	 as abstractions
		on name $x$. It further substitutes
		the two endpoints of a fresh channel $h$ to channels $y$ respectively,
		in order for the two instances to communicate with each other.



%\begin{itemize}
%	\item	Processes $P_1$ and $P_2$ are responsible for negotiating a quote from the
%		hotel in the same fashion as process $P$ in the previous implementation.
%
%	\item	The difference with process $P$ is that the channel $y$ is used for
%		interaction between process $P_1$ and $P_2$. Both processes send
%		there quotes to each other and then internally follow the same
%		logic to reach to a decision.
%
%	\item	The role of $\Client_2$ is to instantiate $P_1$ and $P_2$ as abstractions
%		on name $x$. It further substitutes
%		the two endpoints of a fresh channel $h$ to channels $y$ respectively,
%		in order for the two instances to be able to communicate with each other.
%
%	\item	Process $\Client_2$ then uses sessions $s_1$ and $s_2$ to send the two
%		instances of $P_1$ and $P_2$ to the two hotels.
%\end{itemize}

The differences between $\Client_1$ and $\Client_2$ can be  seen in the sequence diagrams of \figref{fig:exam}. 
We will assign session types to these client processes in Example \ref{exam:type}.
Later on, we will show that they are behaviourally equivalent using characteristic bisimilarity;
see \propref{p:examp}.
\begin{figure}
\input{diagram}
\caption{Sequence diagrams for $\Client_1$ and $\Client_2$ as in Example~\ref{exam:proc}\label{fig:exam}.}
%\vspace{-2mm}
\end{figure}
\end{example}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Types and Typing}
\label{sec:types}
% !TEX root = main.tex
\noi %Here we define 
We define a session typing system for \HOp and state its main properties. 
Our system distills the key features of~\cite{tlca07,MostrousY15}.
We give selected definitions; 
see~\cite{KouzapasPY15} for a full description. 

%thus it is simpler.
%Our system is simpler than that in~\cite{tlca07,MostrousY15}, thus distilling the key
%features of higher-order sessions. %communications. %in a session-typed setting.

 

%\subsection{Types}
%\label{subsec:types}
\subparagraph{Types.}
The syntax of types of \HOp is given below:
\[
	\begin{array}{cc}
		\begin{array}{lcl}
			\text{(value)} & U \bnfis & C \bnfbar L
			\\[1mm]
			\text{(name)} & C \bnfis & S \bnfbar \chtype{S} \bnfbar \chtype{L}
			\\[1mm]
			\text{(abstr)} & L \bnfis & \shot{U} \bnfbar \lhot{U}
		\end{array}
		&
		\begin{array}{lcl}
			\text{(session)} & S \bnfis &  \btout{U} S \bnfbar \btinp{U} S \bnfbar \tinact
			\\[1mm]
			&\bnfbar& \btsel{l_i:S_i}_{i \in I} \bnfbar \trec{t}{S} \bnfbar \vart{t}
			\\[1mm]
			&\bnfbar& \btbra{l_i:S_i}_{i \in I}
		\end{array}
	\end{array}
	\]
Value type $U$ includes
the first-order types $C$ and the higher-order
types $L$. Session types are denoted with $S$ and
shared types with $\chtype{S}$ and $\chtype{L}$.
%Note that we dissallow type $\chtype{U}$, thus
%in the type discipline shared names cannot carry shared names.
%In name types, $\chtype{U}$ is shared name types 
%which are sent via shared names. 
Types $\shot{U}$ and $\lhot{U}$ denote
{\em shared} and {\em linear} higher-order 
%\jpc{functional}
types, respectively.
%,
%used to type abstraction values.
%$\lhot{C}$ \cite{tlca07,mostrous_phd} ensures values which contain free 
%session names used once. 
As for session types,  
%We write $S$ to denote %binary 
%session types. 
the {\em output type}
$\btout{U} S$ %is assigned to a name that 
first sends a value of
type $U$ and then follows the type described by $S$.  Dually,
$\btinp{U} S$ denotes an {\em input type}. The {\em branching type}
$\btbra{l_i:S_i}_{i \in I}$ and the {\em selection type}
$\btsel{l_i:S_i}_{i \in I}$ define the labelled choice. 
We assume the {\em recursive type} $\trec{t}{S}$ is guarded,
i.e.,  $\trec{t}{\vart{t}}$ is not allowed. 
%We stress that carried type $U$ in $\btout{U} S$ and
%$\btinp{U} S$ can contain free type variables, which is crucial
%to encode $\HOp$ into $\HO$.
Type $\tinact$ is the termination type. 

%Types of \HO exclude $\nonhosyntax{C}$ from 
%value types of \HOp; the types of \sessp exclude $L$. 
%From each $\CAL \in \{\HOp, \HO, \pi \}$, $\CAL^{-\mathsf{sh}}$ 
%excludes shared name types ($\chtype{S}$ and $\chtype{L}$), 
%from name type $C$.

Following \cite{onSessionDualityBDGK},
we write $S_1 \dualof S_2$ if 
$S_1$ is the \emph{dual} of $S_2$.   
%See the Appendix (\defref{def:dual}) for a definition; 
Intuitively, 
duality
converts $!$ into $?$ and $\oplus$ into $\&$ (and viceversa). 
%incorporating also the fixed point construction.
%(see in the Appendix). 

 

%\subsection{Typing System of \HOp}
%\label{subsec:typing}
\subparagraph{Typing Environments and Judgements.}
\noi Typing \emph{environments} are defined below:
%\[
\begin{eqnarray*}
	\Gamma  & \bnfis  &\emptyset \bnfbar \Gamma \cat \varp{x}: \shot{U} \bnfbar \Gamma \cat u: \chtype{S} \bnfbar \Gamma \cat u: \chtype{L} 
        \bnfbar \Gamma \cat \rvar{X}: \Delta \\
	\Lambda &\bnfis & \emptyset \bnfbar \Lambda \cat \AT{x}{\lhot{U}}
	\qquad\qquad
	\Delta  \bnfis  \emptyset \bnfbar \Delta \cat \AT{u}{S}
\end{eqnarray*}
%]
\noi 
$\Gamma$ maps variables and shared names to value types, and recursive 
variables to session environments;  
it admits weakening, contraction, and exchange principles.
$\Lambda$ maps variables to 
%the
 linear %functional 
higher-order
types, and $\Delta$ maps
session names to session types. 
Both $\Lambda$ and $\Delta$ %behave linearly: they 
are
only subject to exchange.  
%We require that t
The domains of $\Gamma,
\Lambda$ and $\Delta$ are assumed pairwise distinct. 
$\Delta_1\cdot \Delta_2$ is 
the disjoint union of $\Delta_1$ and $\Delta_2$.  
We define \emph{typing judgements} for values 
%$V$
and processes: % $P$:
%\begin{center}
%\begin{tabular}{c}
	$$\Gamma; \Lambda; \Delta \proves V \hastype U \qquad \qquad \qquad \qquad \qquad \Gamma; \Lambda; \Delta \proves P \hastype \Proc$$
%\end{tabular}
%\end{center}
\noi The first judgement
says that under environments $\Gamma; \Lambda; \Delta$ value $V$
has type $U$; the second judgement says that under
environments $\Gamma; \Lambda; \Delta$ process $P$ has the process type~$\Proc$.
The type soundness result for \HOp (Thm.~\ref{t:sr})
relies on two auxiliary notions on session environments: 
%that contain dual endpoints typed with dual types.
%The following definition ensures two session endpoints 
%are dual each other. 

%\smallskip

\begin{definition}[Session Environments: Balanced/Reduction]\label{d:wtenvred}%\rm
	Let $\Delta$ be a session environment.
	\begin{enumerate}[$\bullet$]
	\item A session environment $\Delta$ is {\em balanced} if whenever
	$s: S_1, \dual{s}: S_2 \in \Delta$ then $S_1 \dualof S_2$.
	\item We define the reduction relation $\red$ on session environments as: %\\ %[-2mm]
\begin{eqnarray*}
	\Delta \cat s: \btout{U} S_1 \cat \dual{s}: \btinp{U} S_2  & \red & 
	\Delta \cat s: S_1 \cat \dual{s}: S_2  \\
	\Delta \cat s: \btsel{l_i: S_i}_{i \in I} \cat \dual{s}: \btbra{l_i: S_i'}_{i \in I} &\red& \Delta \cat s: S_k \cat \dual{s}: S_k' \ (k \in I)
\end{eqnarray*}
\end{enumerate}
\end{definition}

\noi We rely on a typing system that is similar to the one developed in~\cite{tlca07,MostrousY15}. 
We state the type soundness result for \HOp processes;
see~\cite{KouzapasPY15} for details of the associated proofs.

%\smallskip

\begin{theorem}[Type Soundness]\label{t:sr}%\rm
			Suppose $\Gamma; \es; \Delta \proves P \hastype \Proc$
			with
			$\Delta$ balanced. 
			Then $P \red P'$ implies $\Gamma; \es; \Delta'  \proves P' \hastype \Proc$
			and $\Delta = \Delta'$ or $\Delta \red \Delta'$
			with $\Delta'$ balanced. 
\end{theorem}


\begin{example}[Hotel Booking Revisited]\label{exam:type}
Assume $S = \btout{\Quote} \btbra{\accept: \tinact, \reject: \tinact}$ and
$U = \btout{\rtype} \btinp{\Quote} \btsel{\accept: \btout{\creditc} \tinact, \reject: \tinact }$.
We give types to the client processes of~\exref{exam:proc}:
\begin{eqnarray*}
\es; \es; y: S & \proves &  \abs{x}{P_{xy}} \hastype \lhot{U} \\
\es; \es; s_1: \btout{\lhot{U}} \tinact \cat s_2: \btout{\lhot{U}} \tinact & \proves &  \Client_1 \hastype \Proc \\
\es; \es; y: \btout{\Quote} \btinp{\Quote} \tinact & \proves &  \abs{x}{Q_i} \hastype \lhot{U} \quad (i=1,2)\\
\es; \es; s_1: \btout{\lhot{U}} \tinact \cat s_2: \btout{\lhot{U}} \tinact & \proves &  \Client_2 \hastype \Proc
\end{eqnarray*}
%The type for $\abs{x}{P_{xy}}$ is $\es; \es; y: S \proves \abs{x}{P_{xy}} \hastype \lhot{U}$
%and the type for $\Client_1$ is
%$~~
%	\es; \es; s_1: \btout{\lhot{U}} \tinact \cat s_2: \btout{\lhot{U}} \tinact \proves \Client_1 \hastype \Proc
%$.
%The types for $Q_1$ and $Q_2$ are
%$	\es; \es; y: \btout{\Quote} \btinp{\Quote} \tinact \proves \abs{x}{Q_i} \hastype \lhot{U}
%$ ($i=1,2$)
%and the type for $\Client_2$ is
%$~~
%	\es; \es; s_1: \btout{\lhot{U}} \tinact \cat s_2: \btout{\lhot{U}} \tinact \proves \Client_2 \hastype \Proc
%$.
\end{example}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Characteristic
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Characteristic Session Bisimulation}
\label{sec:behavioural}
 
\noi We develop a theory for observational equivalence over
session typed \HOp processes that follows the principles
laid in our previous works~\cite{KYHH2015,KY2015}.
We introduce 
%three different bisimulations 
\emph{characteristic bisimulation} (\defref{d:fwb})
and prove
\jpc{that}
%all of them coincide 
it coincides
with reduction-closed,
barbed congruence (\thmref{the:coincidence}).

We begin by defining an (early) labelled transition system (LTS) on
untyped processes~(\S\,\ref{ss:lts}). 
Then, using the \emph{environmental} transition semantics (\S\,\ref{ss:elts}), 
we define a typed LTS to formalise 
how a typed process interacts with a typed observer. 

\subsection{Labelled Transition System for Processes}\label{ss:lts}
%\myparagraph{Labels.}
%\noi 

%process in its environment. 
Interaction is defined on action labels $\ell$:
%\begin{center}
%\begin{tabular}{l}
	$$\ell	\bnfis   \tau 
		\bnfbar	\bactinp{n}{V} 
		\bnfbar	\news{\widetilde{m}} \bactout{n}{V}
		\bnfbar	\bactsel{n}{l} 
		\bnfbar	\bactbra{n}{l} $$
%\end{tabular}
%\end{center}
\noi 
Label $\tau$ defines internal actions.
Action $\news{\widetilde{m}} \bactout{n}{V}$ denotes the sending of value $V$
over channel $n$ with
a possible empty set of restricted names $\widetilde{m}$ 
(we may write $\bactout{n}{V}$ when $\widetilde{m}$ is empty).
%and 
%$\news{\widetilde{m}} \bactout{n}{\AT{V}{U}}$
%when the type of $V$ is~$U$.
Dually, the action for value reception is 
$\bactinp{n}{V}$.
Actions for select
and branch on
a label~$l$ are denoted $\bactsel{n}{l}$ and $\bactbra{n}{l}$, resp.
We write $\fn{\ell}$ and $\bn{\ell}$ to denote the
 sets of free/bound names in $\ell$, resp.
%and set $\mathsf{n}(\ell)=\bn{\ell}\cup \fn{\ell}$. 
Given $\ell \neq \tau$, we write 
$\subj{\ell}$
to denote the \emph{subject} of $\ell$.


\emph{Dual actions} %, defined below, 
occur on subjects that are dual between them and carry the same
object; thus, output is dual to input and 
selection is dual to branching.
Formally, duality 
\jpc{on actions}
is the symmetric relation $\asymp$ that satisfies:
\jpc{(i)~$\bactsel{n}{l} \asymp \bactbra{\dual{n}}{l}$ 
and (ii)~$\news{\widetilde{m}} \bactout{n}{V} \asymp \bactinp{\dual{n}}{V}$}.
%
%\begin{tabular}{c}
%	$\bactsel{n}{l} \asymp \bactbra{\dual{n}}{l}
%	\qquad \qquad \qquad
%	\news{\widetilde{m}} \bactout{n}{V} \asymp \bactinp{\dual{n}}{V}$s
%
%\end{tabular}


%%%%%%%%%%%%%%%%%%%% LTS Figure %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
\[
	\begin{array}{c}
%	\inferrule[ ]{ }{b}
	\inferrule*[left=\ltsrule{App}]{ }{(\abs{x}{P}) \, V   \by{\tau} P \subst{V}{x}}
%		\ltsrule{App} \ 		(\abs{x}{P}) \, V   \by{\tau} P \subst{V}{x}
		\qquad
		\inferrule*[left=\ltsrule{Snd}]{ }{\bout{n}{V} P \by{\bactout{n}{V}} P}
%		\ltsrule{Snd}\	\bout{n}{V} P \by{\bactout{n}{V}} P 
		\qquad
		\inferrule*[left=\ltsrule{Rv}]{ }{\binp{n}{x} P \by{\bactinp{n}{V}} P\subst{V}{x} }
%		\ltsrule{Rv}\	\binp{n}{x} P \by{\bactinp{n}{V}} P\subst{V}{x} 
		\\[2mm]
		\inferrule*[left=\ltsrule{Sel}]{ }{\bsel{s}{l}{P} \by{\bactsel{s}{l}} P}
		%\ltsrule{Sel}\ \bsel{s}{l}{P} \by{\bactsel{s}{l}} P
		\qquad \quad
		\inferrule*[left=\ltsrule{Bra}]{ }{\bbra{s}{l_i:P_i}_{i \in I} \by{\bactbra{s}{l_j}} P_j \ (j\in I)}
		%\ltsrule{Bra}\ \bbra{s}{l_i:P_i}_{i \in I} \by{\bactbra{s}{l_j}} P_j \ (j\in I)
		\\[2mm]
		\inferrule[\ltsrule{Alpha}]{P \scong_\alpha Q \quad Q\by{\ell} P'}{P \by{\ell} P'}
%		\ltsrule{Alpha}
%		\tree{
%			P \scong_\alpha Q \quad Q\by{\ell} P'
%		}{
%			P \by{\ell} P'
%		}
		\qquad \quad
		\inferrule[\ltsrule{Res}]{P \by{\ell} P' \quad n \notin \fn{\ell}}{\news{n} P \by{\ell} \news{n} P'}
%		\ltsrule{Res}
%		\tree{
%			P \by{\ell} P' \quad n \notin \fn{\ell}
%		}{
%			\news{n} P \by{\ell} \news{n} P' 
%		}
		%\\[5mm]
		\qquad \quad
		\inferrule[\ltsrule{New}]{P \by{\news{\widetilde{m}} \bactout{n}{V}} P' \quad m \in \fn{V}}{\news{m} P \by{\news{m\cat\widetilde{m}'} \bactout{n}{V}} P'}
%		\ltsrule{New}
%		\tree{
%			P \by{\news{\widetilde{m}} \bactout{n}{V}} P' \quad m \in \fn{V}
%		}{
%			\news{m} P \by{\news{m\cat\widetilde{m}'} \bactout{n}{V}} P'
%		}
		\\[4mm]
		\inferrule[\ltsrule{Par${}_L$}]{P \by{\ell} P' \quad \bn{\ell} \cap \fn{Q} = \es}{P \Par Q \by{\ell} P' \Par Q}
%		\ltsrule{Par${}_L$}
%		\tree{
%
%			P \by{\ell} P' \quad \bn{\ell} \cap \fn{Q} = \es
%		}{
%			P \Par Q \by{\ell} P' \Par Q
%		}
%		\\[5mm]
\quad ~~
		\inferrule[\ltsrule{Tau}]{P \by{\ell_1} P' \qquad Q \by{\ell_2} Q' \qquad \ell_1 \asymp \ell_2}{P \Par Q \by{\tau} \newsp{\bn{\ell_1} \cup \bn{\ell_2}}{P' \Par Q'}}
%		\ltsrule{Tau}
%		\tree{
%			P \by{\ell_1} P' \qquad Q \by{\ell_2} Q' \qquad \ell_1 \asymp \ell_2
%		}{
%			P \Par Q \by{\tau} \newsp{\bn{\ell_1} \cup \bn{\ell_2}}{P' \Par Q'}
%		} 
		\quad ~~
		\inferrule[\ltsrule{Rec}]{P\subst{\recp{X}{P}}{\rvar{X}} \by{\ell} P'}{\recp{X}{P}  \by{\ell} P'}
%		\ltsrule{Rec}
%		\tree{
%			P\subst{\recp{X}{P}}{\rvar{X}} \by{\ell} P' 
%		}{
%			\recp{X}{P}  \by{\ell} P'
%		}
	\end{array}
\]
%\vspace{-5mm}
	\caption{The Untyped LTS for \HOp processes. We omit rule $\ltsrule{Par${}_R$}$.  \label{fig:untyped_LTS}}
%\vspace{-2mm}
\end{figure}
%%%%%%%%%%%%%%%%%%%% End LTS Figure %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\myparagraph{LTS over Untyped Processes.}
The %labelled transition system (LTS) 
LTS
over \emph{untyped processes}
is given in
\figref{fig:untyped_LTS}. 
We write $P_1 \by{\ell} P_2$ with the usual meaning.
The rules are standard~\cite{KYHH2015,KY2015}.
A process with an output prefix can
interact with the environment with an output action that carries a value
$V$ (rule~$\ltsrule{Snd}$).  Dually, in rule $\ltsrule{Rv}$ a
receiver process can observe an input of an arbitrary value $V$.
Select and branch processes observe the select and branch
actions in rules $\ltsrule{Sel}$ and $\ltsrule{Bra}$, resp.
Rule $\ltsrule{Res}$ closes the LTS under restriction 
if the restricted name does not occur free in the
observable action. 
%If a restricted name occurs free,  
If a restricted name occurs free in
the carried value of an output action,
the process performs scope opening (rule~$\ltsrule{New}$).  
Rule~$\ltsrule{Rec}$ handles recursion unfolding.
Rule~$\ltsrule{Tau}$ 
states that two parallel processes which perform
dual actions can synchronise by an internal transition.
%states that if two parallel processes can perform
%dual actions then the two actions can synchronise by 
%an internal transition. 
Rules $\ltsrule{Par${}_L$}$/$\ltsrule{Par${}_R$}$ 
and $\ltsrule{Alpha}$ close the LTS
under parallel composition and $\alpha$-renaming. 
%provided that the observable
%action does not share any bound names with the parallel processes.

\subsection{Environmental Labelled Transition System}
\label{ss:elts}
\noi 
\figref{fig:envLTS}
defines a labelled transition relation between 
a triple of environments, 
denoted
$(\Gamma_1, \Lambda_1, \Delta_1) \by{\ell} (\Gamma_2, \Lambda_2, \Delta_2)$.
It extends the LTSs
in \cite{KYHH2015,KY2015} 
to higher-order sessions. 
Notice that due to weakening %of shared environments 
we have 
$(\Gamma', \Lambda_1, \Delta_1) \hby{\ell} (\Gamma', \Lambda_2, \Delta_2)$
if
$(\Gamma, \Lambda_1, \Delta_1) \hby{\ell} (\Gamma', \Lambda_2, \Delta_2)$.



\subparagraph{Input Actions} 
are defined by 
rules~$\eltsrule{SRv}$ and $\eltsrule{ShRv}$.
%describe the input action
In rule~$\eltsrule{SRv}$
%($n$ session or shared channel respectively $\bactinp{n}{V}$). 
the type of value $V$
and the type of the object associated to the session type on $s$ 
should coincide. 
%Moreover, 
The resulting type tuple must contain the environments 
associated to $V$. 
The %condition $\dual{s} \notin \dom{\Delta}$
%rule requires that 
dual endpoint $\dual{s}$ cannot be
present in the session environment: if it were present
the only possible communication would be the interaction
between the two endpoints (cf. rule~$\eltsrule{Tau}$).
Rule~$\eltsrule{ShRv}$ is for shared names and follows similar principles.

\subparagraph{Output Actions} are defined by rules~$\eltsrule{SSnd}$
and $\eltsrule{ShSnd}$.  
Rule $\eltsrule{SSnd}$ states the conditions for observing action
$\news{\widetilde{m}} \bactout{s}{V}$ on a type tuple 
$(\Gamma, \Lambda, \Delta\cdot \AT{s}{S})$. 
The session environment $\Delta$ with $\AT{s}{S}$ 
should include the session environment of the sent value $V$, 
{\em excluding} the session environments of names $m_j$ 
in $\widetilde{m}$ which restrict the scope of value $V$. 
Analogously, the linear variable environment 
$\Lambda'$ of $V$ should be included in $\Lambda$. 
Scope extrusion of session names in $\widetilde{m}$ requires
that the dual endpoints of $\widetilde{m}$ should appear in
the resulting session environment. Similarly for shared 
names in $\widetilde{m}$ that are extruded.  
All free values used for typing $V$ are subtracted from the
resulting type tuple. The prefix of session $s$ is consumed
by the action.
Rule $\eltsrule{ShSnd}$ is for output actions on shared names:
the name must be typed with $\chtype{U}$; conditions on $V$ are identical to those
% the requirements 
on rule~$\eltsrule{SSnd}$.
%\NY{Given a $V$ of type $U$, we sometimes annotate the output action 
%$\news{\widetilde{m}} \bactout{n}{V}$
%%with the type of $V$ 
%as $\news{\widetilde{m}} \bactout{n}{\AT{V}{U}}$.}

\subparagraph{Other Actions}
Rules $\eltsrule{Sel}$ and $\eltsrule{Bra}$ describe actions for
select and branch.
%Both
%rules require the absence of the dual endpoint from the session
%environment.%, and the presence of the action labels in the type.
Rule $\eltsrule{Tau}$ defines
internal transitions: 
it keeps the session environment unchanged or 
reduces it (\defref{d:wtenvred}).

%A second environment LTS, denoted $\hby{\ell}$,
%is defined in the lower part of \figref{fig:envLTS}.
%The definition substitutes rules
%$\eltsrule{SRecv}$ and $\eltsrule{ShRecv}$
%of relation $\by{\ell}$ with rule $\eltsrule{RRcv}$.
%% the corresponding input cases
%%of $\by{\ell}$ with the definitions of $\hby{\ell}$.
%All other cases remain the same as the cases for
%relation $\by{\ell}$.
%Rule $\eltsrule{RRcv}$ restricts the higher-order input
%in relation $\hby{\ell}$;
%only characteristic processes and trigger processes
%are allowed to be received on a higher-order input.
%Names can still be received as in the definition of
%the $\by{\ell}$ relation.
%The conditions for input follow the conditions
%for the $\by{\ell}$ definition.

%%%%%%%%%%%%%%%%%%%% Environment LTS Figure %%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
\[
\begin{array}{c}
\inferrule[\eltsrule{SRv}]{
		\dual{s} \notin \dom{\Delta}
		\quad
		\Gamma; \Lambda'; \Delta' \proves V \hastype U
	}{
		(\Gamma; \Lambda; \Delta \cat s: \btinp{U} S) \by{\bactinp{s}{V}} (\Gamma; \Lambda\cat\Lambda'; \Delta\cat\Delta' \cat s: S)
	}
	%\\[7mm]
	\quad
	\inferrule[\eltsrule{ShRv}]{
		\Gamma; \es; \es \proves a \hastype \chtype{U}
		\quad
		\Gamma; \Lambda'; \Delta' \proves V \hastype U
	}{
		(\Gamma; \Lambda; \Delta) \by{\bactinp{a}{{V}}} (\Gamma; \Lambda\cat\Lambda'; \Delta\cat\Delta')
	}
	\\[6mm]
%%	\eltsrule{SSnd} &
	\inferrule*[left=\eltsrule{SSnd}]{
		\begin{array}{lll}
			\Gamma \cat \Gamma'; \Lambda'; \Delta' \proves V \hastype U
			&				
			\Gamma'; \es; \Delta_j \proves m_j  \hastype U_j
			& 
			\dual{s} \notin \dom{\Delta}
			\\
			\Delta'\backslash \cup_j \Delta_j \subseteq (\Delta \cat s: S)
			& 
			\Gamma'; \es; \Delta_j' \proves \dual{m}_j  \hastype U_j'
			& 
			\Lambda' \subseteq \Lambda
		\end{array}
	}{
		(\Gamma; \Lambda; \Delta \cat s: \btout{U} S)
		\by{\news{\widetilde{m}} \bactout{s}{V}}
		(\Gamma \cat \Gamma'; \Lambda\backslash\Lambda'; (\Delta \cat s: S \cat \cup_j \Delta_j') \backslash \Delta')
	}
	\\[2mm]
	\inferrule*[left=\eltsrule{ShSnd}]{
		\begin{array}{lll}
			\Gamma \cat \Gamma' ; \Lambda'; \Delta' \proves V \hastype U
			&  
			\Gamma'; \es; \Delta_j \proves m_j \hastype U_j
			&
			\Gamma ; \es ; \es \proves a \hastype \chtype{U}
			\\
			\Delta'\backslash \cup_j \Delta_j \subseteq \Delta
			&
			\Gamma'; \es; \Delta_j' \proves \dual{m}_j\hastype U_j'
			& 
			\Lambda' \subseteq \Lambda
		\end{array}
	}{
		(\Gamma ; \Lambda; \Delta) \by{\news{\widetilde{m}}
		\bactout{a}{V}}
		(\Gamma \cat \Gamma'; \Lambda\backslash\Lambda'; (\Delta \cat \cup_j \Delta_j') \backslash \Delta')
	}
	\\[2mm]
	\inferrule*[left=\eltsrule{Sel}]{\dual{s} \notin \dom{\Delta} \quad j \in I}{(\Gamma; \Lambda; \Delta \cat s: \btsel{l_i: S_i}_{i \in I}) \by{\bactsel{s}{l_j}} (\Gamma; \Lambda; \Delta \cat s:S_j)}
%	\eltsrule{Sel}~~
%	\tree{
%		\dual{s} \notin \dom{\Delta} \quad j \in I
%	}{
%		(\Gamma; \Lambda; \Delta \cat s: \btsel{l_i: S_i}_{i \in I}) \by{\bactsel{s}{l_j}} (\Gamma; \Lambda; \Delta \cat s:S_j)
%	}
	\\[2mm]
	\inferrule*[left=\eltsrule{Bra}]{\dual{s} \notin \dom{\Delta} \quad j \in I}{(\Gamma; \Lambda; \Delta \cat s: \btbra{l_i: T_i}_{i \in I}) \by{\bactbra{s}{l_j}} (\Gamma; \Lambda; \Delta \cat s:S_j)}
%	\eltsrule{Bra}~~
%	\tree{
%		\dual{s} \notin \dom{\Delta} \quad j \in I
%	}{
%		(\Gamma; \Lambda; \Delta \cat s: \btbra{l_i: T_i}_{i \in I}) \by{\bactbra{s}{l_j}} (\Gamma; \Lambda; \Delta \cat s:S_j)
%	}
%	\\[7mm]
%	\eltsrule{Tau}~~
%	\tree{
%		\Delta_1 \red \Delta_2 \vee \Delta_1 = \Delta_2
%	}{
%		(\Gamma; \Lambda; \Delta_1) \by{\tau} (\Gamma; \Lambda; \Delta_2)
%	}
\qquad
	\inferrule*[left=\eltsrule{Tau}]{
		\Delta_1 \red \Delta_2 \vee \Delta_1 = \Delta_2
	}{
		(\Gamma; \Lambda; \Delta_1) \by{\tau} (\Gamma; \Lambda; \Delta_2)
	}

\end{array}
\]
%\vspace{-5mm}
\caption{Labelled Transition System for Typed Environments. 
\label{fig:envLTS}}
%\Hlinefig
%\vspace{-2mm}
\end{figure}
%%%%%%%%%%%%%%%%%%%% End Environment LTS Figure %%%%%%%%%%%%%%%%%%%%%%

\begin{example}
	Consider environment %tuple
	$
		(\Gamma; \es; s: \btout{\lhot{\btout{S} \tinact}} \tinact \cat s': S)
	$
	and typed value
	\[
		\Gamma; \es; s': S \cat m: \btinp{\tinact} \tinact \proves V \, \hastype \, 
\lhot{\btout{S} \tinact} \quad \mbox{with} \quad 
V= \abs{x} \bout{x}{s'} \binp{m}{z} \inact
	\]
We illustrate	rule~$\eltsrule{SSnd}$ in \figref{fig:envLTS}.
Let 
$\Delta'_1=\{\overline{m}: \btout{\tinact} \tinact\}$ and 
$U= \lhot{\btout{S} \tinact}$.
	Then we can derive:
	\[
		(\Gamma; \es; s: \btout{\lhot{\btout{S} \tinact}} \tinact \cat s': S) \by{\news{m} \bactout{s}{V}} (\Gamma; \es; s: \tinact)
	\]
\end{example}

\noi
Our typed LTS  combines
the LTSs in \figref{fig:untyped_LTS}
and \figref{fig:envLTS}. 




\begin{definition}[Typed Transition System]\label{d:tlts}\rm
A {\em typed transition relation} is a typed relation
%\begin{enumerate}
%\item 
$\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_2}{P_2}$
%$\Gamma; \emptyset; \Delta_1 \proves P_1 \hastype \Proc \by{\ell} \Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$
	where:
%
(1) $P_1 \by{\ell} P_2$ and (2) 
$(\Gamma, \emptyset, \Delta_1) \by{\ell} (\Gamma, \emptyset, \Delta_2)$ 
with $\Gamma; \emptyset; \Delta_i \proves P_i \hastype \Proc$ 
($i=1,2$).
%\dk{We sometimes annotated the output action with
%the type of value $V$ as in $\widetilde{m} \bactout{n}{V: U}$.}
%
% Efficient 
%\item 
%$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_2}{P_2}$
%whenever: 
%$P_1 \by{\ell} P_2$, 
%$(\Gamma, \emptyset, \Delta_1) \hby{\ell} (\Gamma, \emptyset, \Delta_2)$, 
%and $\Gamma; \emptyset; \Delta_i \proves P_i \hastype \Proc$ 
%($i=1,2$)
%\end{enumerate}
%
We extend to $\By{}$ 
%(resp.\ $\Hby{}$) and  
and $\By{\hat{\ell}}$ 
%(resp.\ $\Hby{\hat{\ell}}$) 
where we write 
$\By{}$ for the reflexive and
transitive closure of $\by{}$, $\By{\ell}$ for the transitions
$\By{}\by{\ell}\By{}$, and $\By{\hat{\ell}}$ for $\By{\ell}$ if
$\ell\not = \tau$ otherwise $\By{}$. 
%We extend to $\By{}$ 
%(resp.\ $\Hby{}$) and  and 
%$\By{\hat{\ell}}$ 
%(resp.\ $\Hby{\hat{\ell}}$) 
%in the standard way.
\end{definition}

\subsection{Reduction-Closed, Barbed Congruence ($\cong$)}
\label{subsec:rc}
\noi We now define \emph{typed relations} and \emph{contextual equivalence} (i.e., barbed congruence).  
%\begin{definition}[Session Environment Confluence]\rm
We first define \emph{confluence}
over session environments $\Delta$:
we denote $\Delta_1 \bistyp \Delta_2$ if there exists $\Delta$ such that
	$\Delta_1 \red^\ast \Delta$ and $\Delta_2 \red^\ast \Delta$
	\jpc{(here we write $\red^\ast$ for the multi-step reduction in \defref{d:wtenvred})}.
%\end{definition}

\begin{definition}\rm %[Typed Relation]\rm
	We say that
	$\Gamma; \emptyset; \Delta_1 \proves P_1 \hastype \Proc\ \Re \ \Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$
	is a {\em typed relation} whenever $P_1$ and $P_2$ are closed;
		$\Delta_1$ and $\Delta_2$ are balanced; and 
		$\Delta_1 \bistyp \Delta_2$.
We write
$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re \ }{\Delta_2}{P_2}$
for the typed relation $\Gamma; \emptyset; \Delta_1 \proves P_1 \hastype \Proc\ \Re \ \Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$.
\end{definition}

\noi Typed relations relate only closed terms whose
session environments %and the two session environments
are balanced  and confluent.
Next we define  {\em barbs}~\cite{MiSa92}
with respect to types. 

%\begin{definition}[Barbs]\rm
%Let $P$ be a closed process. We define:
%\begin{enumerate}
%		\item	(a) $P \barb{n}$ if $P \scong \newsp{\widetilde{m}}{\bout{n}{V} P_2 \Par P_3}, n \notin \widetilde{m}$; %; $P \Barb{n}$ if $P \red^* \barb{n}$. and $\Gamma; \Delta \proves P \barb{n}$ if
%(b)			$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ with $P \barb{n}$ and $\dual{n} \notin \dom{\Delta}$
%\item  
%	$\Gamma; \Delta \proves P \Barb{n}$ if $P \red^* P'$ and
%			$\Gamma; \Delta' \proves P' \barb{n}$.			
%	\end{enumerate}
%\end{definition}

\begin{definition}[Barbs]\rm
	Let $P$ be a closed process. We write
	%\begin{enumerate}
		%\item 
		$P \barb{n}$ if $P \scong \newsp{\tilde{m}}{\bout{n}{V} P_2 \Par P_3}$, with $n \notin \tilde{m}$.
		Also: $P \Barb{n}$ if $P \red^* \barb{n}$.
		%\item 
		Similarly, we write
		$\Gamma; \emptyset; \Delta \proves P \barb{n}$ if
			$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ with $P \barb{n}$ and $\dual{n} \notin \Delta$.
			Also: $\Gamma; \emptyset; \Delta \proves P \Barb{n}$ if $P \red^* P'$ and
			$\Gamma; \emptyset; \Delta' \proves P' \barb{n}$.			
	%\end{enumerate}
\end{definition}

\noi A barb $\barb{n}$ is an observable on an output prefix with subject $n$;
a weak barb $\Barb{n}$ is a barb after a number of reduction steps.
Typed barbs $\barb{n}$ (resp.\ $\Barb{n}$)
occur on typed processes $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$.
When $n$ is a session name we require that its dual endpoint $\dual{n}$ is not %present
in %the session environment 
$\Delta$.

To define a congruence relation, we introduce the family $\C$ of contexts:
\begin{eqnarray*}
	\C & ::= & \hole \bnfbar \bout{u}{V} \C \bnfbar \binp{u}{x} \C \bnfbar \bout{u}{\lambda x.\C} P \bnfbar \news{n} \C
	(\lambda x.\C)u \bnfbar \recp{X}{\C}\\ 
	& \bnfbar & \C \Par P \bnfbar P \Par \C \bnfbar \bsel{u}{l} \C \bnfbar \bbra{u}{l_1:P_1,\cdots,l_i:\C,\cdots,l_n:P_n}
\end{eqnarray*}

Notation $\context{\C}{P}$ denotes the result of substituting 
\jpc{the hole}
$\hole$ in $\C$ with process $P$.
%\end{definition}


\noi The first behavioural relation we define is reduction-closed, barbed congruence \cite{HondaKYoshida95}. 

\begin{definition}[Reduction-Closed, Barbed Congruence]\rm
\label{def:rc}
	Typed relation
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{P_2}$
	is a {\em reduction-closed, barbed congruence} whenever:
	\begin{enumerate}[1)]
		\item	If $P_1 \red P_1'$ then there exist $P_2', \Delta_2'$ such that $P_2 \red^* P_2'$ and
			$\horel{\Gamma}{\Delta_1'}{P_1'}{\ \Re\ }{\Delta_2'}{P_2'}$;%		and its symmetric case;
%		\item	If $P_2 \red P_2'$ then $\exists P_1', P_1 \red^* P_1'$ and
%		$\horel{\Gamma}{\Delta_1'}{P_1'}{\ \Re\ }{\Delta_2'}{P_2'}$
%		\end{itemize}

%		\item
%		\begin{itemize}
			\item	If $\Gamma;\Delta_1 \proves P_1 \barb{n}$ then $\Gamma;\Delta_2 \proves P_2 \Barb{n}$;% and its symmetric case; 

%			\item	If $\Gamma;\emptyset;\Delta \proves P_2 \barb{s}$ then $\Gamma;\emptyset;\Delta \proves P_1 \Barb{s}$.
%		\end{itemize}

%		\item	For all $\C$, there exist $\Delta_1'',\Delta_2''$: $\horel{\Gamma}{\Delta_1''}{\context{\C}{P_1}}{\ \Re\ }{\Delta_2''}{\context{\C}{P_2}}$; 
%		\item	For all $\C$, we have $\horel{\Gamma}{\Delta_1''}{\context{\C}{P_1}}{\ \Re\ }{\Delta_2''}{\context{\C}{P_2}}$, for some $\Delta_1''$,$\Delta_2''$; 
		\item	For all $\C$, $\Delta_1''$, $\Delta_2''$ we have: $\horel{\Gamma}{\Delta_1''}{\context{\C}{P_1}}{\ \Re\ }{\Delta_2''}{\context{\C}{P_2}}$; 

		                      \item	The symmetric cases of 1 and 2.                
	\end{enumerate}
	The largest such relation is denoted with $\cong$.
\end{definition}


\subsection{Context Bisimilarity ($\wbc$)}
\label{subsec:bisimulation}
\noi 
Following Sangiorgi~\cite{San96H}, 
%The first bisimulation that 
we now define 
the standard (weak) context bisimilarity. 
%
\begin{definition}[Context Bisimilarity]\rm
\label{def:wbc}
A typed relation $\Re$ is {\em a context bisimulation} if
for all $\horel{\Gamma}{\Delta_1}{P_1}{\ \Re \ }{\Delta_2}{Q_1}$, 
%\vspace{-3mm}
	\begin{enumerate}[1)] 
	\item Whenever 
$\horel{\Gamma}{\Delta_1}{P_1}
        {\by{\news{\widetilde{m_1}} \bactout{n}{V_1}}}{\Delta_1'}{P_2}$,
there exist 
$Q_2$, $V_2$, $\Delta'_2$
such that 
$\horel{\Gamma}{\Delta_2}{Q_1}{\By{\news{\widetilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}$ and 
for all $R$ with $\fv{R}=x$:
\[\horel{\Gamma}{\Delta_1''}{\newsp{\widetilde{m_1}}{P_2 \Par R\subst{V_1}{x}}}
				{\ \Re\ }
				{\Delta_2''}{\newsp{\widetilde{m_2}}{Q_2 \Par R\subst{V_2}{x}}};\]  
%\item	$\forall \news{\widetilde{m_1}'} \bactout{n}{\widetilde{m_1}}$ such that
%			\[
%				\horel{\Gamma}{\Delta_1}{P_1}{\by{\news{\widetilde{m_1}'} \bactout{n}{\widetilde{m_1}}}}{\Delta_1'}{P_2}
%			\]
%			implies that $\exists Q_2, \widetilde{m_2}$ such that
%			\[
%				\horel{\Gamma}{\Delta_2}{Q_1}{\By{\news{\widetilde{m_2}'} \bactout{n}{\widetilde{m_2}}}}{\Delta_2'}{Q_2}
%			\]
%			and $\forall R$ with $\widetilde{x} = \fn{R}$, 
%			then
%			\[
%				\horel{\Gamma}{\Delta_1''}{\newsp{\widetilde{m_1}'}{P_2 \Par R \subst{\widetilde{m_1}}{\widetilde{x}}}}
%				{\ \Re \ }
%				{\Delta_2''}{\newsp{\widetilde{m_2}'}{Q_2 \Par R \subst{\widetilde{m_2}}{\widetilde{x}}}}
%			\]
		\item	
For all $\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_1'}{P_2}$ such that 
$\ell$ is not an output, 
 there exist $Q_2$, $\Delta'_2$ such that 
$\horel{\Gamma}{\Delta_2}{Q_1}{\By{\hat{\ell}}}{\Delta_2'}{Q_2}$
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re \ }{\Delta_2'}{Q_2}$; and  

                      \item	The symmetric cases of 1 and 2.                
	\end{enumerate}
	The largest such bisimulation is called \emph{context bisimilarity} \jpc{and} denoted by $\wbc$.
\end{definition}

\noi As hinted at in %\secref{subsec:intro:bisimulation}, 
%\secref{sec:overview},
the Introduction,
in the general case,
context bisimilarity 
is hard to compute. Below we introduce 
\emph{characteristic bisimulations}, which are meant to be a \emph{tractable} proof technique over session typed  processes with higher-order communication.
%$\hwb$ and  $\fwb$.
%due to: (1) the universal
%quantification over contexts in the output case;
%and (2) a higher-order input prefix which can observe
%infinitely many different input actions (since
%infinitely many different processes can match
%the session type of an input prefix).

\subsection{%Higher-Order  and  
Characteristic  Bisimilarity ($\fwb$)}\label{ss:hwb}
\noi 
We formalise the ideas given in % \secref{sec:overview}.
the introduction.
%Our main result is \thmref{the:coincidence}.
We define characteristic processes/values:

\begin{definition}[Characteristic Process and Values]\rm
\label{def:char}
%	Let names $\widetilde{k}$ and type $\widetilde{C}$; then we define a {\em characteristic process}:
%	$\map{\widetilde{C}}^{\widetilde{k}}$:
%	\[
%		\map{C_1, \cdots, C_n}^{k_1 \cdots k_n} = \map{C_1}^{k_1} \Par \dots \Par \map{C_n}^{k_n}		
%	\]
%	with 
	Let $u$ and $U$ be a name and a type, respectively.
	\figref{fig:char} defines the {\em characteristic process} 
	$\mapchar{U}{u}$ and the {\em characteristic value} $\omapchar{U}$.
%	For $\omapchar{S}$, $\omapchar{\chtype{S}}$, and $\omapchar{\chtype{L}}$ freshness is assumed with respect to any names in their contexts.
\end{definition}

\begin{proposition}%[Characteristic Processes/Values Inhabit Their Types]
%	\begin{itemize}
		%\item	
		Let $S$ be a session type. Then $\Gamma; \es; \Delta \cat s: S \proves \mapchar{S}{s} \hastype \Proc$.
		%\item	
		Also, let $\chtype{U}$ be a first-order (channel) type. Then $\Gamma \cat a: \chtype{U}; \es; \Delta \proves \mapchar{\chtype{U}}{a} \hastype \Proc$.
%	\end{itemize}
\end{proposition}

%%%%%%%%%%%%%%%%%%%%%%%% Characteristic Process Figure %%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
\[
	\begin{array}{rclcrcl}
		\mapchar{\btinp{U} S}{u}
		&\defeq&
		\binp{u}{x} (\mapchar{S}{u} \Par \mapchar{U}{x})
		&&
		\mapchar{\btout{U} S}{u}
		&\defeq&
		\bout{u}{\omapchar{U}} \mapchar{S}{u} %& & n \textrm{ fresh}
		\\

		\mapchar{\btsel{l : S}}{u}
		& \defeq &
		\bsel{u}{l} \mapchar{S}{u}
		&&
		\mapchar{\btbra{l_i: S_i}_{i \in I}}{u}
		& \defeq &
		\bbra{u}{l_i: \mapchar{S_i}{u}}_{i \in I}
		\\

		\mapchar{\tvar{t}}{u}
		&\defeq&
		\varp{X}_{\vart{t}}
		& & 
		\mapchar{\trec{t}{S}}{u}
		&\defeq&
		\recp{X_{\vart{t}}}{\mapchar{S}{u}}
		\\

		\mapchar{\tinact}{u}
		& \defeq &
		\inact
		& & 
		\mapchar{\chtype{S}}{u} 
		&\defeq&
		\bout{u}{\omapchar{S}} \inact
		\\

		\mapchar{\chtype{L}}{u}
		&\defeq&
		\bout{u}{\omapchar{L}} \inact
		&&
		\mapchar{\shot{U}}{u}
		&\defeq &
		\mapchar{\lhot{U}}{u}
		\, \defeq \,
		\appl{u}{\omapchar{U}}
		\end{array}
		\]
		%\vspace{-3mm}
		\[
		\begin{array}{c}
		\omapchar{S}  \defeq  s ~~ (s \textrm{ fresh})
		\qquad
		\omapchar{\chtype{S}} \defeq \omapchar{\chtype{L}} \defeq a ~~ (a \textrm{ fresh})
		\qquad
		\omapchar{\shot{U}} \defeq \omapchar{\lhot{U}} \,\defeq\, \abs{x}{\mapchar{U}{x}}
	\end{array}
\]
%\vspace{-5mm}
\caption{Characteristic Processes \jpc{(top)} and Values \jpc{(bottom)} as in \defref{def:char}.
For $\omapchar{S}$, $\omapchar{\chtype{S}}$, and $\omapchar{\chtype{L}}$ freshness is assumed with respect to any names in their contexts.
\label{fig:char}}
%\Hlinefig
%\vspace{-3mm}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%% End Characteristic Process Figure %%%%%%%%%%%%%%%%%%%%%




The following example motivates the refined 
LTS explained in %\secref{sec:overview}.
the introduction.


 


\begin{example}[The Need for Refined Typed LTS]
\label{ex:motivation}
We show that observing a characteristic value
input alone is not enough
\dk{to define a sound bisimulation closure}.
Consider   processes % $P_1, P_2$:
%
\begin{eqnarray}
	P_1 = \binp{s}{x} (\appl{x}{s_1} \Par \appl{x}{s_2}) 
	& & 
	P_2 = \binp{s}{x} (\appl{x}{s_1} \Par \binp{s_2}{y} \inact) 
	\label{equ:6}
\end{eqnarray}
%
%We can show that 
where
$\Gamma; \es; \Delta \cat s: \btinp{\shot{(\btinp{C} \tinact)}} \tinact \proves P_i \hastype \Proc$ ($i \in \{1,2\}$).
If $P_1$ and $P_2$ input and substitute over $x$
the characteristic value $\dk{\omapchar{\shot{(\btinp{C} \tinact)}} =} \abs{x}{\binp{x}{y} \inact}$, 
then they evolve into:%(\ref{eq:5}) and (\ref{eq:6}) in become:
\begin{center}
%\begin{tabular}{c}
	$\Gamma; \es; \Delta \proves \binp{s_1}{y} \inact \Par \binp{s_2}{y} \inact \hastype \Proc$
%\end{tabular}
\end{center}
\noi therefore becoming 
context bisimilar.
%after the input of $\abs{x}{\binp{x}{y}} \inact$.
However, the processes in (\ref{equ:6}) 
are clearly {\em not} context bisimilar: many input actions
may be used to distinguish them.
For example, if 
$P_1$ and $P_2$ input 
$\abs{x} \newsp{s}{\bout{a}{s} \binp{x}{y} \inact}$ with
$\Gamma; \es; \Delta \proves s \hastype \tinact$,
then their derivatives are not bisimilar. 

Observing only the characteristic value 
results in an under-discriminating bisimulation.
However, if a trigger value
$\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}$ 
is received on $s$, 
 we can distinguish $P_1$, $P_2$ 
%processes 
in~\eqref{equ:6}:  
%
\begin{eqnarray*}
%	\Gamma; \es; \Delta &\proves& 
	P_1 \By{\ell} \binp{t}{x} (\appl{x}{s_1}) \Par 
\binp{t}{x} (\appl{x}{s_2})
%\hastype \Proc
	\mbox{~and~}
%	\Gamma; \es; \Delta &\proves& 
	P_2 \By{\ell} \binp{t}{x} (\appl{x}{s_1}) \Par \binp{s_2}{y} \inact 
%\hastype \Proc
\quad \text{($\ell = s?\ENCan{\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}}$)}
\end{eqnarray*}
\normalsize
%\noi resulting two distinct processes.  
%
%\noi where 
%$\ell = s?\ENCan{\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}}$.
One question is whether the trigger value is enough
to distinguish two processes (hence no need of 
characteristic values). % as the input. 
This is not the case: the trigger value
alone also results in an under-discriminating bisimulation relation.
In fact, the  trigger value can be observed on any input prefix
of {\em any type}. For example, consider processes
%
\begin{eqnarray}
%	\Gamma; \es; \Delta \proves 
\newsp{s}{\binp{n}{x} (\appl{x}{s}) \Par \bout{\dual{s}}{\abs{x} R_1} \inact} 
%\hastype \Proc
\ \mbox{and}\ 
%	\Gamma; \es; \Delta \proves 
\newsp{s}{\binp{n}{x} (\appl{x}{s}) \Par \bout{\dual{s}}{\abs{x} R_2} \inact} 
%\hastype \Proc
\label{equ:7}\label{equ:8}
\end{eqnarray}
%
\noi If these processes %in \eqref{equ:7}/\eqref{equ:8}
input the trigger value, we obtain: % they evolved to 
\begin{eqnarray*}
%\Gamma; \es; \Delta \proves 
	\newsp{s}{\binp{t}{x} (\appl{x}{s}) \Par \bout{\dual{s}}{\abs{x} R_1} \inact} 
%\hastype \Proc
	\mbox{ and }
%      \\
%\Gamma; \es; \Delta \proves 
	\newsp{s}{\binp{t}{x} (\appl{x}{s}) \Par \bout{\dual{s}}{\abs{x} R_2} \inact}
%\hastype \Proc
\end{eqnarray*}

\noi thus we can easily derive a bisimulation closure if we 
assume a bisimulation definition that allows only trigger value input.
%
%\noi It is easy to obtain a closure if allow only the
%trigger value as the input value. 
But if processes in \eqref{equ:7}
input the characteristic value $\abs{z}{\binp{z}{x} (\appl{x}{m})}$,  
then they would become, under appropriate $\Gamma$ and $\Delta$:
%
\begin{eqnarray*}
	\Gamma; \es; \Delta \proves \newsp{s}{\binp{s}{x} (\appl{x}{m}) \Par \bout{\dual{s}}{\abs{x} R_i} \inact} \wbc \Delta \proves R_i \subst{m}{x}
\quad (i=1,2)
%	\\
%	\Gamma; \es; \Delta \proves \newsp{s}{\binp{s}{x} (\appl{x}{m}) \Par \bout{\dual{s}}{\abs{x} Q} \inact} \wbc \Delta \proves Q \subst{m}{x}
\end{eqnarray*}
\noi which are not bisimilar if $R_1 \subst{m}{x} \not\wbc R_2 \subst{m}{x}$.
%\qed
%In conclusion, these examples explain a need of both 
%trigger and characteristic values 
%as an input observation in the input transition relation (\eltsrule{RRcv})
%which will be defined in Definition~\ref{def:rlts}.  
\end{example}

%\noi We define the \emph{refined} typed LTS. 
\noi As explained in 
%\secref{sec:overview}, 
the introduction,
we define the
\emph{refined} typed LTS
by considering a transition rule for input in which admitted values are
trigger or characteristic values or names:

%\noi We define the \emph{refined} typed LTS. 
%As explained in \secref{subsec:intro:bisimulation}, this new LTS is defined 
%by considering a transition rule for input in which admitted values are
%trigger or characteristic values:
%\dk{(assume extension of the structural
%congruence to acommodate values: i) $\abs{x}{P} \scong \abs{x}{Q}$ if
%$P \scong Q$) and ii) $n \scong m$ if $n = n$)}: 

\begin{definition}[Refined Typed Labelled Transition Relation]
	\label{def:rlts}
	We define the environment transition rule for input actions 
	%restricted environment transition relation using the
	%following rule %using the environment transition relation defined in 
	using the input rules in \figref{fig:envLTS}:
	\[ \!\!\!
	\begin{array}{l}
%			\eltsrule{RRcv}&\tree {
%	\begin{array}{c}
%	(\Gamma_1; \Lambda_1; \Delta_1) \by{\bactinp{n}{V}} (\Gamma_2; \Lambda_2; \Delta_2)
%	\\
%				\begin{array}{lll}
%					V = m \vee V  \scong
%					\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}
%					\vee  V \scong \omapchar{U}%\abs{{x}}{\map{U}^{{x}}}
%					\textrm{ with } t \textrm{ fresh} 
%				\end{array}
%				\end{array}
%			}{
%				(\Gamma_1; \Lambda_1; \Delta_1) \hby{\bactinp{n}{V}} (\Gamma_2; \Lambda_2; \Delta_2)
%			}
			
						\eltsrule{RRcv}\,\tree {
	%\begin{array}{c}
	(\Gamma_1; \Lambda_1; \Delta_1) \by{\bactinp{n}{V}} (\Gamma_2; \Lambda_2; \Delta_2)
	\quad
					V = m 
					\vee  V \scong \omapchar{U}%\abs{{x}}{\map{U}^{{x}}}
										\vee V  \scong \abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}
					\text{ {\small with $t$ fresh}} 
				%\end{array}
			}{
				(\Gamma_1; \Lambda_1; \Delta_1) \hby{\bactinp{n}{V}} (\Gamma_2; \Lambda_2; \Delta_2)
			}
			
			
	\end{array}
	\]
	\noi Rule $\eltsrule{RRcv}$ is defined on top
	of rules $\eltsrule{SRv}$ and $\eltsrule{ShRv}$
	in \figref{fig:envLTS}.
%	uses the environment transition
%	$(\Gamma, \Lambda_1, \Delta_1) \hby{\ell} (\Gamma, \Lambda_2, \Delta_2)$
%	in \figref{fig:envLTS}. 
\dk{	We  use the non-receiving rules in \figref{fig:envLTS}
	together with rule $\eltsrule{RRcv}$
	to define 
	$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_2}{P_2}$
	as in \defref{d:tlts}.}
%	by replacing $\by{\ell}$ by $\hby{\ell}$ in \defref{d:tlts}. 
\end{definition}

\noi Notice that
$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_2}{P_2}$ (refined transition) implies  
$\horel{\Gamma}{\Delta_1}{P_1}{\by{\,\ell\,}}{\Delta_2}{P_2}$ (ordinary transition).
Below we sometimes write  
$\hby{\news{\widetilde{m}} \bactout{n}{\AT{V}{U}}}$
when the type of $V$ is~$U$.

%See \exref{ex:motivation} for the reason why {\em both} 
%the trigger values ($\lambda x.\binp{t}{y} (\appl{y}{{x}})$) 
%and characteristic values ($\lambda x.\map{U}^{{x}}$) are required 
%to define the following two bisimulations. 

 

\subparagraph{Characteristic Bisimulations.} We define 
%\emph{higher-order} and
\emph{characteristic
bisimulations}, 
%two tractable bisimulations for $\HO$ and $\HOp$.
a tractable bisimulation for $\HOp$.
As 
%explained in %\secref{sec:overview},
%the Introduction,
hinted at above, 
%the two bisimulations 
%characteristic bisimulations
their definition
uses trigger processes (cf.~\eqref{eq:4}):
%the key difference between them is in the trigger processes they use:
\begin{eqnarray*}
%\htrigger{t}{V_1}  & \defeq &  \hotrigger{t}{V} \label{eqb:0} \\
	\ftrigger{t}{V}{U} & \defeq &  \fotrigger{t}{x}{s}{\btinp{U} \tinact}{V} 	\label{eqb:4}
\end{eqnarray*}
%\noi
 

\begin{definition}[Characteristic Bisimilarity]\rm
	\label{d:fwb}
A typed relation $\Re$ is a {\em  characteristic bisimulation} if 
for all $\horel{\Gamma}{\Delta_1}{P_1}{\ \Re \ }{\Delta_2}{Q_1}$, 
\begin{enumerate}[1)]
\item 
	Whenever 
	$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\widetilde{m_1}} \bactout{n}{\dk{V_1: U}}}}{\Delta_1'}{P_2}$ %with $\Gamma; \es; \Delta \proves V_1 \hastype U$,  
	then there exist 
	$Q_2$, $V_2$, $\Delta'_2$ such that 
	$\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\widetilde{m_2}}\bactout{n}{\dk{V_2: U}}}}{\Delta_2'}{Q_2}$ %with $\Gamma; \es; \Delta' \proves V_2 \hastype U$,  
	and, for fresh $t$, \\ 
	$%\begin{array}{lrlll}
	\Gamma; \Delta''_1  \proves  {\newsp{\widetilde{m_1}}{P_2 \Par 
	\ftrigger{t}{V_1}{U_1}}}
	  \,\Re\,
	 \Delta''_2 \proves {\newsp{\widetilde{m_2}}{Q_2 \Par \ftrigger{t}{V_2}{U_2}}}
%\end{array}
$
		
\item	
For all $\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}$ such that 
$\ell$ is not an output, 
 there exist $Q_2$, $\Delta'_2$ such that 
$\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\hat{\ell}}}{\Delta_2'}{Q_2}$
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re \ }{\Delta_2'}{Q_2}$; and 

                      \item	The symmetric cases of 1 and 2.                
	\end{enumerate}
	The largest such bisimulation
	is called \emph{characteristic bisimilarity} \jpc{and} denoted by $\fwb$.
\end{definition}

 
\noi Internal transitions associated to session interactions or  
$\beta$-reductions are deterministic.  
		
\begin{definition}[Deterministic Transition]\myrm
\label{def:dettrans}
	Let  $\Gamma; \es; \Delta \proves P \hastype \Proc$ be a balanced \HOp process. 
	Transition $\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ is called
%%\vspace{-2mm}
%	\begin{enumerate}[$-$]
%		\item 
		{\em session transition} whenever the   transition $P \by{\tau} P'$ 
		is derived using 
			rule~$\ltsrule{Tau}$ 
		(where $\subj{\ell_1}$ and $\subj{\ell_2}$ in the premise 
		are dual endpoints), 
		possibly followed by uses of  $\ltsrule{Alpha}$, $\ltsrule{Res}$, $\ltsrule{Rec}$, or $\ltsrule{Par${}_L$}/
		\ltsrule{Par${}_R$}$.
		
		%\item
		Transition $\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ is called
			{\em \betatran}	whenever the   transition $P \by{\tau} P'$
			is derived using rule $\ltsrule{App}$,
			possibly followed by uses of  $\ltsrule{Alpha}$, $\ltsrule{Res}$, $\ltsrule{Rec}$, or $\ltsrule{Par${}_L$}/
		\ltsrule{Par${}_R$}$. \\
%	\end{enumerate}
%
%We write
%$\horel{\Gamma}{\Delta}{P}{\hby{\stau}}{\Delta'}{P'}$
%and 
%$\horel{\Gamma}{\Delta}{P}{\hby{\btau}}{\Delta'}{P'}$
%to denote session and $\beta$-transitions, resp. Also, 
	 $\horel{\Gamma}{\Delta}{P}{\hby{\dtau}}{\Delta'}{P'}$ denotes
	either a session transition or a \betatran.
\end{definition}
%Deterministic transitions imply the $\tau$-inertness property, which
%is a property that ensures behavioural invariance on deterministic
%transitions.

\begin{proposition}[$\tau$-inertness]\myrm
	\label{lem:tau_inert}
Let  $\Gamma; \es; \Delta \proves P \hastype \Proc$ be a balanced \HOp process.
	Then
%	\begin{enumerate}[1.]
%\item	
$\horel{\Gamma}{\Delta}{P}{\hby{\dtau}}{\Delta'}{P'}$ implies
			$\horel{\Gamma}{\Delta}{P}{\fwb}{\Delta'}{P'}$.
%		\item	$\horel{\Gamma}{\Delta}{P}{\Hby{\dtau}}{\Delta'}{P'}$ implies
%			$\horel{\Gamma}{\Delta}{P}{\wb}{\Delta'}{P'}$.
%	\end{enumerate}
\end{proposition}
\noi 
See~\cite{KouzapasPY15} for associated proofs. 
Our main theorem follows: %typed bisimilarities collapse for \HOp processes. 
it allows us to use $\fwb$ as a tractable reasoning %is the most tractable 
technique for higher-order processes with sessions.

%\smallskip 

\begin{theorem}[Coincidence]\rm
%	\label{the:coincidence}
%$\cong$, $\wbc$, $\hwb$ and $\fwb$ coincide in $\CAL\in \{\HOp, \HO\}$
%and 
%$\cong$, $\wbc$ and $\fwb$ coincide in $\CAL\in \{\HOp, \HO, \sessp\}$. 
	\label{the:coincidence}
$\cong$, $\wbc$,  and $\fwb$ coincide in $\HOp$. 
%%\vspace{-1mm}
\end{theorem}
\begin{proof}[Proof (Sketch)]
We use 
\emph{higher-order bisimilarity} ($\hwb$, see \defref{def:bisim}), 
an auxiliary equivalence that
is defined as $\fwb$ but by
using  trigger processes with higher-order communication (cf.~\eqref{equ:2}).
We first show that $\fwb$ and $\hwb$ coincide by using~\propref{lem:tau_inert}; 
then, we show that $\hwb$ coincides with $\wbc$ and $\cong$. 
A key result is a  substitution lemma which simplifies reasoning 
for $\hwb$
by exploiting characteristic processes/values.
See~\cite{KouzapasPY15} for full details.
\end{proof}
Now we prove 
that  processes 
$\Client_1$ and $\Client_2$ 
in Example \ref{exam:proc}
are behaviourally equivalent.

\begin{proposition}\label{p:examp}
	Let
	$S = \btout{\rtype} \btinp{\Quote} \btsel{\accept: \btout{\creditc} \tinact, \reject: \tinact}$ and 
$\Delta = s_1: \btout{\lhot{S}} \tinact \cat s_2: \btout{\lhot{S}} \tinact$. 
Then
	$ \horel
	{\es}{\Delta}{\Client_1}
	{\wbf}
	{\Delta}{\Client_2}$. %and $\Client_1$, $\Client_2$ in Example \ref{exam:proc}. 
%\vspace{-2mm}
\end{proposition}
\begin{proof}[Proof (Sketch)]
	\noi We show a bisimulation closure by following transitions on each $\Client$.
	%We show the initial higher order transitions.
	See~\cite{KouzapasPY15} for details.
	First, the characteristic process is given as:
	$\mapchar{\btinp{\lhot{S}} \tinact}{s} = \binp{s}{x} (\appl{x}{k})$.
We show that the clients can simulate each other on
the first two output transitions, that also generate the trigger
processes:
%
\[
	\begin{array}{lll}
&	\es; \es; \Delta \proves \Client_1
	&
		\by{\bactout{s_1}{\abs{x}{P_{xy} \subst{h_1}{y}}}}
		\by{\bactout{s_2}{\abs{x}{P_{xy} \subst{h_2}{y}}}}
		\\
&		\es; \es; k_1: S \cat k_2: S \proves
		&
		\newsp{h_1, h_2}{\binp{\dual{h_1}}{x} \binp{\dual{h_2}}{y}\\
&		& \If\ x \leq y\ \Then (\bsel{\dual{h_1}}{\accept} \bsel{\dual{h_2}}{\reject} \inact
		\Else \bsel{\dual{h_1}}{\reject} \bsel{\dual{h_2}}{\accept} \inact)\\
&		& \Par \ftrigger{t_1}{\abs{x}{P_{xy} \subst{h_1}{y}}}{\lhot{S}} \Par \ftrigger{t_2}{\abs{x}{P_{xy} \subst{h_2}{y}}}{\lhot{S}}}
%		& \Par \binp{t_1}{x} \newsp{s}{\binp{s}{x} \appl{x}{k_1} \Par \bout{\dual{s}}{\abs{x}{P \subst{h_1}{y}}} \inact }\\
%		& \Par \binp{t_2}{x} \newsp{s}{\mapchar{\btinp{\lhot{S}}}{s} \Par \bout{\dual{s}}{\abs{x}{P \subst{h_2}{y}}} \inact }}
		\\[1mm]
\mbox{and} &
		\es; \es; \Delta \proves \Client_2
		&\by{\bactout{s_1}{\abs{x}{Q_1 \subst{h}{y}}}}
		\by{\bactout{s_2}{\abs{x}{Q_2 \subst{\dual{h}}{y}}}}
		\\
&		\es; \es; k_1: S \cat k_2: S \proves & \newsp{h}{
		\ftrigger{t_1}{\abs{x}{Q_1 \subst{h}{y}}}{\lhot{S}} \Par \ftrigger{t_2}{\abs{x}{Q_2 \subst{\dual{h}}{y}}}{\lhot{S}}}
%		\binp{t_1}{x} \newsp{s}{\binp{s}{x} \appl{x}{k_1} \Par \bout{\dual{s}}{\abs{x}{P_1 \subst{h}{y}}} \inact }\\
%		&\Par \binp{t_2}{x} \newsp{s}{\binp{s}{x} \appl{x}{k_2} \Par \bout{\dual{s}}{\abs{x}{P_2 \subst{\dual{h}}{y}}} \inact }}
	\end{array}
\]
	\noi 
After these transitions, 
we can analyse that 
the resulting processes are behaviourally equivalent
since they have the same visible transitions; the rest 
is internal deterministic transitions. 
\end{proof}

 




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RelWork
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Related Work}
\label{sec:relwork}
%Our work follows the behavioural semantics techniques %for session typed bisimulations
%originally proposed in \cite{KYHH2015,KY2015,DBLP:journals/iandc/PerezCPT14}.
%In \cite{KYHH2015,KY2015} the authors consider the theory (first-order) binary
%and multiparty session types, respectively.
As in this work, the bisimulations in \cite{KYHH2015,KY2015}
(binary and multiparty session types, respectively)
are defined and characterised on
a LTS which is the conjunction of
an untyped LTS for process and a LTS for session type environments.
The work \cite{DBLP:journals/iandc/PerezCPT14} studies typed equivalences
for a 
theory of binary sessions based on linear logic,
without shared names.
%\NY{Our work follows 
%the
%behavioural semantics in 
%\cite{KYHH2015,KY2015,DBLP:journals/iandc/PerezCPT14}
%where a bisimulation is defined on an LTS 
%that assumes a session typed
%observer.
%%The bisimilarity is characterised by the corresponding
%%reduction-closed, barbed congruence using techniques derived from~\cite{Hennessy07}.
%Our theory for higher-order sessions 
%differentiates from 
%the work in~\cite{KYHH2015} and \cite{KY2015}, which 
%considers  (first-order)
%binary and multiparty session types, respectively.
%The work \cite{DBLP:journals/iandc/PerezCPT14} studies typed equivalences
%for a 
%theory of binary sessions based on linear logic,
%without shared names.}
%Determinacy properties (confluence, $\tau$-inertness) are proven.
Our results have important consequences in the relative expressivity
of higher-order sessions; see the  
technical report~\cite{KouzapasPY15} for further applications.


%The theory for higher-order session type quivalences is more challenging than
%their corresponding first-order bisimulation theory.
Our approach %for the higher-order 
to typed equivalences
builds upon techniques developed by Sangiorgi~\cite{SangiorgiD:expmpa,San96H}
and Jeffrey and Rathke~\cite{JeffreyR05}.
%The work %Sangiorgi as part of his Ph.D.~research
%%\cite{San96H,SangiorgiD:expmpa}
%\cite{SangiorgiD:expmpa}
%introduced the first fully-abstract encoding from the higher-order 
%$\pi$-calculus into the $\pi$-calculus. 
%Sangiorgi's encoding is based on the idea of a replicated input-guarded process 
%(a trigger process). 
%%We use a similar  replicated triggered process to encode \HOp into \sessp (\defref{d:enc:hopitopi}).
% Operational correspondence for
%the triggered encoding is shown using a context bisimulation
%with first-order labels.
As we have discussed, although contextual bisimilarity has a satisfactory discriminative power,
its use is hindered by the universal quantification on output.
To deal with this, 
Sangiorgi proposes \emph{normal bisimilarity}, 
a tractable  equivalence without universal quantification. 
To prove that context and normal bisimilarities coincide,~\cite{SangiorgiD:expmpa} uses 
triggered processes.
%The encoding also motivates the definition of a form of
Triggered bisimulation is also defined on first-order labels
where the context bisimulation is restricted to arbitrary
trigger substitution. %rather than arbitrary process substitutions.
This
characterisation of context bisimilarity  was refined in~\cite{JeffreyR05} for
calculi with recursive types, not addressed in~\cite{San96H,SangiorgiD:expmpa} and
quite relevant in %our work (cf. \defref{d:enc:hopitoho}).
session-based concurrency.
The
bisimulation in~\cite{JeffreyR05}
is based on an LTS  extended with trigger meta-notation.
%for a full higher-order $\pi$-calculus that allows
%higher-order applications.
As in~\cite{San96H,SangiorgiD:expmpa}, 
the LTS in~\cite{JeffreyR05}
observes first-order triggered values instead of
higher-order values, offering a more direct characterisation of contextual equivalence
and lifting the restriction to finite types.
We briefly contrast 
the approach in~\cite{JeffreyR05} and ours based on 
%\dk{higher-order ($\hwb$) and} 
characteristic  bisimilarity ($\fwb$):
\begin{enumerate}[$\bullet$]
%\begin{enumerate}[i.]
\item 
The LTS in~\cite{JeffreyR05} is enriched with extra labels for triggers;
an output action transition emits a trigger and introduces a parallel replicated trigger.
Our 
approach retains usual labels/transitions; in  case of output,
%our bisimilarities 
%$\hwb$ and 
$\fwb$
introduces a parallel
\emph{non-replicated} trigger.

\item Higher-order input in~\cite{JeffreyR05} involves 
the input of a trigger which reduces after substitution.
Rather than a trigger name, %our bisimulations  
%$\hwb$ and 
$\fwb$
decrees the input of a trigger value $\abs{z}\binp{t}{x} (\appl{x}{z})$.

\item Unlike~\cite{JeffreyR05}, 
%our 
$\fwb$ treats  
first- and higher-order values uniformly. %In the latter case, 
%Since the 
As the typed LTS distinguishes linear and shared values,
replicated closures are used only for shared values.

\item In~\cite{JeffreyR05}   name matching   is
crucial to prove completeness of bisimilarity.
In our case, \HOp lacks name matching and 
%Contrarily 
%\jpc{In contrast,} 
we use session types: a characteristic value inhabiting a type enables the simplest form of interactions with the environment.

%We use the characteristic process interaction with the environment, exploiting session types.
%, i.e., instead of matching a name, we embed it into a process and then observe its behaviour.

%In~\cite{JeffreyR05}  a matching construct 
%is crucial to prove completeness of bisimilarity.
%Since our language lacks matching,
%we use session type information to obtain the simplest value that 
%enables interaction with the environment.
\end{enumerate}
\noi 
We have compared our approach to that in~\cite{JeffreyR05} 
using a representative example.
We considered the transitions and resulting processes involved in checking bisimilarity of process 
$\bout{n}{\abs{x}{\appl{x}(\abs{y}{\bout{y}{m}} \inact)}} \inact$
with itself.
This comparison, detailed in~\cite{KouzapasPY15}, reveals that our approach 
%based on %even if both techniques require the same number of transitions, 
%a refined LTS and characteristic bisimilarity 
requires less visible transitions and replicated processes. 
Therefore, linearity information does simplify analyses, 
as it enables simpler witnesses in  coinductive proofs.


\emph{Environmental bisimulations}~\cite{DBLP:conf/lics/SangiorgiKS07} 
%which 
%Sangiorgi et al.~\cite{DBLP:conf/lics/SangiorgiKS07}, 
use a higher-order LTS 
to define a bisimulation that stores the observer's knowledge; hence, observed actions are based on this knowledge
at any given time. This approach is enhanced in~\cite{DBLP:journals/cl/KoutavasH12}
with a mapping from constants to higher-order values. This 
allows to observe first-order values instead
of higher-order values. It differs from~\cite{San96H,JeffreyR05} in that 
the mapping between higher- and first-order values is no longer implicit.

\subparagraph{Acknowledgments} This work has been partially sponsored by the
The Doctoral Prize Fellowship, EP/K011715/1, EP/K034413/1,
 and EP/L00058X/1, 
EU project FP7-612985 UpScale,
and EU
COST Action IC1201 BETTY.  
%Behavioural Types for Reliable Large-Scale Software Systems. % (BETTY).
P\'{e}rez is  also affiliated to NOVA  Laboratory for Computer Science and Informatics (NOVA LINCS),  Universidade Nova de Lisboa, Portugal.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\bibliographystyle{IEEEtran}
\bibliographystyle{plain}
%\bibliographystyle{abbrv}% the recommended bibstyle
{\bibliography{session}}




\end{document}
