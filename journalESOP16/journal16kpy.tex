%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Journal Version of ESOP16 Paper
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\documentclass[runningheads]{llncs} 
\documentclass[preprint,11pt]{elsarticle}
\usepackage[dvipsnames]{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{listings}
\usepackage{multirow}
\usepackage{suffix}
\usepackage{url}

%%% Added by Jorge
\usepackage{amsthm}
\usepackage{centernot}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{times}
\usepackage[margin=1.25in]{geometry}
\allowdisplaybreaks

\usepackage{float}
\floatstyle{ruled}
\restylefloat{figure}

%\usepackage{mathptmx}
%\usepackage{mathrsfs}
\usepackage{comment}
\usepackage{enumerate}
%\usepackage{txfonts}
\usepackage{hyperref}
\usepackage{fancybox}
%\usepackage{space}
\usepackage{color}      % use if color is used in text

\usepackage{mathpartir}

\usepackage{tikz}	% for drawing figures
\usetikzlibrary{calc}

\usepackage{caption}	% for subfigures
\usepackage{subcaption}	% for subfigures

\input{macros}
\newtheorem{definition}{Definition}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{remark}{Remark}[section]
\newtheorem{example}{Example}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{property}{Property}[section]


\newcommand{\rtype}{\mathsf{room}}
\newcommand{\Quote}{\mathsf{quote}}
\newcommand{\accept}{\mathsf{accept}}
\newcommand{\reject}{\mathsf{reject}}
\newcommand{\creditc}{\mathsf{credit}}
\newcommand{\Client}{\mathsf{Client}}

\begin{document}
\begin{frontmatter}

\title{On the Relative Expressiveness of
Higher-Order Session Processes
}

\journal{Information and Computation}

\author[gl]{Dimitrios Kouzapas}
\address[gl]{University of Glasgow, UK
}

\author[gr]{Jorge A. P\'{e}rez}
\address[gr]{University of Groningen \& CWI, Amsterdam, The Netherlands\\
}

\author[ic]{Nobuko Yoshida}
\address[ic]{Imperial College London, UK
}


%\author{
%	Dimitrios Kouzapas\inst{1}
%	\and
%	Jorge A. P\'{e}rez\inst{2}
%	\and Nobuko Yoshida\inst{3}
%}
%\authorrunning{Dimitrios Kouzapas, Jorge A. P\'{e}rez, and Nobuko Yoshida}
%\institute{University of Glasgow, UK
% \and University of Groningen and CWI, Amsterdam, The Netherlands 
% \and Imperial College London, UK}
%\maketitle



%\pagestyle{plain}

%\input{abstract}

\begin{abstract}
By integrating
constructs from the $\lambda$-calculus and 
the $\pi$-calculus,
in \emph{higher-order process calculi} exchanged values may contain processes.
This paper studies the relative expressiveness of \HOp, 
the higher-order $\pi$-calculus in
which communications are governed by \emph{session types}. 
Our main discovery is that \HO, a subcalculus of \HOp which lacks name-passing and recursion, 
can serve as a new core calculus for session-typed higher-order
concurrency. %By exploring a new bisimulation for \HO, w
We show that
 \HO can encode \HOp fully abstractly 
(up to typed contextual \newj{equivalence})
more precisely and efficiently than the first-order 
session $\pi$-calculus (\sessp).
Overall, under the discipline of session types, 
$\HOp$, $\HO$, and $\sessp$ 
are equally expressive; \newjb{however},  we show that
$\HOp$ is more tightly related 
to $\HO$
than to $\sessp$.
\end{abstract}

\begin{keyword}
Concurrency
\sep
Process Calculi
\sep
Behavioral Types
\sep
Session Types
\sep
Expressiveness
\end{keyword}

\end{frontmatter}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{sec:intro}
%\input{introesop}


\emph{Type-preserving compilations} are important in the design of
functional and object-oriented languages: type information has been
used to, e.g., justify code optimizations and reason about programs~\cite{DBLP:journals/toplas/MorrisettWCG99,DBLP:conf/pldi/ShaoA95,DBLP:journals/toplas/LeagueST02}.
A vast literature on 
{\em expressiveness} 
in concurrency theory
also studies compilations (or \emph{encodings})~\cite{Palamidessi03,DBLP:journals/iandc/Gorla10,DBLP:journals/tcs/FuL10,DBLP:conf/icalp/LanesePSS10,DBLP:journals/corr/PetersG15}:
they are used to transfer reasoning techniques 
%from one calculus to another, 
across calculi,
and to 
%identify constructs which may be implemented using simpler ones. 
implement programming abstractions using simple process constructs.
%To a large extent, however, this kind of \emph{expressiveness studies} concern only \emph{untyped process languages}.

In this work, we study 
{\em relative expressiveness} 
via \emph{type-preserving encodings} for \HOp, a \emph{higher-order} 
process language that integrates message-passing concurrency (including recursion) with functional features.
We consider source and target calculi coupled with \emph{session types}~\cite{honda.vasconcelos.kubo:language-primitives} denoting interaction protocols. 
Building on untyped frameworks for relative expressiveness
\cite{DBLP:journals/iandc/Gorla10}, 
we propose type preservation as a {new criterion} for \emph{precise encodings}.
We identify \HO, a new core calculus for higher-order session concurrency which lacks
name passing and recursion. 
We show that \HO can encode \HOp precisely and efficiently. 
Requiring  
type preservation makes
this encoding far from trivial: we crucially exploit advances on
session type duality~\cite{TGC14,DBLP:journals/corr/abs-1202-2086} and recent
characterisations of typed contextual equivalence \cite{characteristic_bis,KouzapasPY17}.
We develop a full hierarchy of variants of \HOp based on 
precise encodings: % (see \figref{fig:express}):
our encodings are
type-preserving and fully abstract up to typed
behavioural equalities. 
\newj{\figref{fig:express} illustrates this hierarchy; the variants of \HOp are explained next.}

\begin{figure}[t]
\centering
\includegraphics[scale=1]{./figures/diag.pdf}

	\caption{Encodability in Higher-Order Sessions. 
	Precise encodings are defined in \defref{def:goodenc}.
	\label{fig:express}}
%\vspace{-5mm}
%\Hlinefig
\end{figure}

\paragraph{Context}
In \emph{session-based concurrency}, interactions are organised into \emph{sessions}, basic communication units.
Interaction patterns can then be abstracted as \emph{session types}~\cite{honda.vasconcelos.kubo:language-primitives}, against which  specifications may be checked. 
%These patterns are defined as %(possibly recursive) 
%sequences of communication actions: % (send/receive a value, offer/select a behavior).
%For instance, 
%session type $T_1 = \btinp{\mathsf{str}} \btout{\mathsf{int}}  \tinact$ may be intuitively read as: receive (?) a value of type $\mathsf{str}$,then output (!) a value of type $\mathsf{int}$, finally close the protocol.
The session type $\btinp{U} S$ (resp.  $\btout{U} S$)
describes a protocol that first receives (resp. sends) a value of type $U$ and then continues as protocol $S$.
Also, given an index set $I$, types $\btbra{l_i:S_i}_{i \in I}$ 
and $\btsel{l_i:S_i}_{i \in I}$ 
define, %, respectively,
%a branching and selection constructs for  
\newj{respectively, external and internal choice constructs for}
 a labelled choice mechanism; types 
$\trec{t}{S}$ 
and 
$\tinact$ denote recursive and completed protocols, respectively.
%describes a protocol that offers
%(resp. ) 
%Type $\tinact$ denotes the completed protocol.
In the %(first-order) 
$\pi$-calculus, %~\cite{MilnerR:calmp1}, 
session types describe the intended interactive behaviour of the names %/channels 
in a process~\cite{honda.vasconcelos.kubo:language-primitives}.
%names/channels are endowed with session types (such as $T_1$) representing their intended interactive behavior.

%\end{document}

Session-based concurrency has also been casted in {higher-order} process
calculi which, by combining features from the $\lambda$-calculus and the $\pi$-calculus, 
enable the exchange of values 
that may contain processes~\cite{tlca07,DBLP:journals/jfp/GayV10}. 
%Higher-order calculi with sessions 
%naturally bridges concurrent and functional computation, 
%and enable the specification of protocols involving \emph{code mobility}, 
%commonplace in practice.
%The \HOp calculus enables 
%the specification of protocols involving \emph{code mobility}, 
%and includes
%Higher-order calculi with sessions 
The higher-order calculus with sessions studied here, called \HOp,
can specify protocols involving \emph{code mobility}: it includes
%equiped ping with 
constructs for 
synchronisation along shared names, 
session communication (value passing, labelled choice) along linear names,
recursion, 
 (first-order) abstractions 
 and applications.
 That is, 
 values in communications include names but also (first-order) abstractions---functions from name identifiers to processes. 
 %(In contrast, higher-order abstractions---functions from processes to processes---are disallowed.)
 (In contrast, \HOp lacks \emph{higher-order} abstractions---functions from processes to processes---but these can be encoded, see below.)
Abstractions can be linear or shared; their types are  denoted $\lhot{C}$ and $\shot{C}$, respectively ($C$ 
%is a first-order type $C$ (say, a session name).
denotes a name). 

%In \HOp we may have processes with a 
%session type such as, e.g.,
%%$T_2 = \btbra{upload:\btinp{\lhot{\mathsf{int}}}\tinact ~ , ~ sha:\btinp{\shot{\mathsf{int}}}\tinact}_{}$
%$$S = \btbra{{up}:\btinp{\lhot{C}}\btout{\mathsf{ok}}\tinact ~ , ~ {down}:\btout{\shot{C}}\btout{\mathsf{ok}}\tinact ~ , ~{quit}:\btout{\mathsf{bye}}\tinact}_{}\,.$$
%%that 
%$S$ is the type of 
%a server that offers ($\&$) \newj{three} different behaviours to a client: 
%%  clients to select among distinct  behaviors: %namely, 
%  to \emph{upload} a linear function, % (to be received by the server), 
%  to \emph{download} a shared function, % (to be sent by the server),
%   or to \emph{quit} the protocol. 
%   %Subsequently, 
%   \newj{Following a client's  selection ($\oplus$),}
%  the server sends a message ($\mathsf{ok}$ or $\mathsf{bye}$) before closing the session.





\paragraph{Expressiveness of \HOp}
%In this paper 
We study the type-preserving, 
relative expressivity of \HOp. % in relation. 
%to two 
%sub-calculi
%that distill first- and higher-order session-based concurrency. 
%\begin{enumerate}[-]
%\item 
As expected from 
known literature in the untyped setting \cite{SangiorgiD:expmpa}, 
the first-order session \sessp-calculus~\cite{honda.vasconcelos.kubo:language-primitives} {(here denoted~\sessp)} 
can encode  the higher-order calculus
\HOp preserving session types. 
%(\HOp without
%abstractions and applications) 
%\item 
In this paper, 
our {main discovery} 
concerns the opposite direction: we show 
that 
\HOp 
without
name-passing and recursion
%is a new 
can serve as a 
core calculus    
for higher-order session concurrency.  
We call this core calculus \HO. 
We show that \HO can encode \HOp more efficiently 
than \sessp. In addition, in the higher-order session typed setting, 
\HO offers more tractable bisimulation techniques 
than \sessp (cf. \secref{ss:equiv}).



\paragraph{Challenges and Contributions}

We assess the expressivity  of \HOp, \HO, and \sessp as delineated by session types. 
We introduce the notion of \emph{type-preserving encodings}:
type information is used to define encodings
and to retain the semantics of session protocols. 
Indeed,  not only we require 
well-typed source processes are encoded into 
well-typed target processes: 
we demand that session type constructs (input, output, branching, select) used to type the source process
are preserved by the typing of the target process.
This criterion is included in 
our notion of \emph{precise encoding} (\defref{def:goodenc}), which 
extends encodability criteria for untyped processes with 
\emph{full abstraction}.
{Full abstraction results are stated
up to two
behavioural equalities that characterise barbed congruence:
\emph{characteristic bisimilarity} ($\fwb$, introduced in~\cite{characteristic_bis})
and 
\emph{higher-order bisimilarity} ($\hwb$, introduced in~\cite{DBLP:conf/esop/KouzapasPY16} and  developed in~\cite{KouzapasPY17}).
%It turns out that $\hwb$ offers more direct  reasoning than $\fwb$. }
Using precise encodings we establish strong correspondences between 
\HOp and its variants---see 
%\figref{fig:express}. 
below.


Our contributions can be divided in two parts. 
First, we develop 
a precise encoding of \HOp into \HO (\secref{subsec:HOpi_to_HO}).  
Since \HO lacks 
both name-passing and recursion, this encoding involves two \emph{key challenges}:
\begin{enumerate}[a.]
\item In known (typed) 
encodings of name-passing into process-passing~\cite{SaWabook} %are limited: % in that 
%they come with restrictions on name usages;  
%they 
%work for %name-passing 
%calculi 
%with \emph{capability types} 
%in which 
only the output capability of names can be sent---a received name cannot be used in later inputs.
This is far too limiting in \HOp, where 
 session names %denoting arbitrary protocols 
 may be passed around (\emph{delegation})
and types describe interaction  \emph{structures}, rather than ``loose'' name capabilities. % at a given time.



\item %As mentioned above, recursion % and replication)
%can be encoded in untyped higher-order calculi using process duplication. Unfortunately, this kind of encodings 
Known encodings of recursion in untyped higher-order calculi
do not carry over to session typed calculi such as \HOp,
because linear abstractions cannot be copied/duplicated. Hence, the discipline of session types  limits 
the possibilities for representing infinite behaviours---this holds for even simple forms, such as input-guarded replication.
\end{enumerate}
\noindent Our encoding overcomes these two obstacles, as we discuss in \secref{sec:overview}.


In the second part, we offer additional technical contributions, which include: 
(i)~the encodability of \HO into \sessp (\secref{subsec:HOp_to_sessp}); 
(ii)~extensions of our encodability results to richer settings (\secref{sec:extension});
(iii)~a non encodability result showing that shared names strictly add expressive power to session calculi (\secref{ss:negative}).
In essence, (i) extends known  results for untyped processes~\cite{SangiorgiD:expmpa} to the session typed setting.
Concerning (ii), we develop extensions of our encodings to 
\begin{enumerate}[-]
\item The extension of \HOp with \emph{higher-order} abstractions (\HOpp); 
\item The extension of \HOp with polyadic name passing and abstraction (\PHOp); 
\item The super-calculus of \HOpp and \PHOp (denoted \PHOpp), equivalent to the calculus in~\cite{tlca07}.
\end{enumerate}
%\figref{fig:express} summarises %our expressivity 
%our encodability results. 
%From a global standpoint, our 

\newj{\figref{fig:express} summarises our encodability results: they}
%These encodability results 
connect \HOp with existing higher-order process calculi~\cite{tlca07}, and  
 highlight the status of \HO as the core calculus for session concurrency.
Finally, %although (iii) may be somewhat expected, 
to our knowledge we are the first to prove 
%this separation result, 
the non encodability result (iii),
exploiting session determinacy and typed equivalences.




\paragraph{Outline} 
%This paper  is structured as follows.
%\begin{enumerate}[$\bullet$]
\secref{sec:overview} overviews key ideas of the precise encoding of \HOp into \sessp.
%\item 
\secref{sec:prelim} 
collects background material:
\secref{subsec:syntax}
presents \HOp and its 
subcalculi (\HO and \sessp); %, and extensions (\HOpp and \PHOp).  
\secref{sec:types} summarises their session type system;
\secref{sec:bt}~pres\-ents  behavioural equalities for \HOp from~\cite{characteristic_bis,KouzapasPY17}:
barbed congruence, characteristic bisimilarity, 
and higher-order bisimilarity.
%We show that these three typed relations coincide (\thmref{t:coincide}).
%and states type soundness 
%for \HOp and its variants.
\secref{s:expr} defines \emph{precise %(typed) 
encodings} by extending encodability criteria  for untyped processes. %~(e.g.,~\cite{DBLP:journals/iandc/Gorla10}).
%\item 
\secref{sec:positive} %and \S\,\ref{sec:negative}
gives {precise encodings} of \HOp into \HO and of \HOp into~\sessp (Thms.~\ref{f:enc:hopitoho} and~\ref{f:enc:hotopi}).
Mutual encodings between \sessp and \HO are derivable; 
all these calculi are thus equally expressive.
%By means of 
Via
empirical and formal comparisons between these two precise encodings, in \secref{ss:compare} we establish that
\HOp and \HO are more tightly related than \HOp and \sessp (\thmref{t:tight}).
Moreover, we prove the impossibility of encoding communication along shared names
using linear names (\thmref{t:negative}).
%Exploiting determinacy and typed equivalences,
%\item
In \secref{sec:extension} %studies extensions of \HOp: 
we show 
%that both \HOpp 
%(the extension with higher-order applications) 
%and \PHOp 
%(the extension with polyadicity) 
%are encodable 
encodings of \HOpp and \PHOp 
into \HOp
(Thms.~\ref{f:enc:hoppptohop} and \ref{f:enc:phopiptohopi}).
%This connects our work to the existing higher-order session calculus in~\cite{tlca07} (here denoted  $\PHOpp$).
%\item 
\secref{sec:relwork} reviews related works and 
\secref{sec:concl} concludes.
%The paper is self-contained. 
{Omitted definitions and  proofs are in the Appendix.
% and  in~\cite{KouzapasPY15}.
} 

This paper is an extended and revised version of the homonymous conference paper that appeared in the Proceedings of ESOP'16~\cite{DBLP:conf/esop/KouzapasPY16}.
With respect to~\cite{DBLP:conf/esop/KouzapasPY16}, the current paper 
provides extended discussions, additional examples, and full technical details. 
Moreover, it offers a sharper focus on relative expressiveness:
a detailed treatment of higher-order bisimilarity
(first introduced in~\cite{DBLP:conf/esop/KouzapasPY16}) can now be found in our paper~\cite{KouzapasPY17} (which corresponds to the journal version of~\cite{characteristic_bis}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Overview: Encoding Name Passing Into Process Passing}
\label{sec:overview}
%\input{overviewesop}
\paragraph{A Precise Encoding of Name-Passing into Process-Passing}
As mentioned above, 
our encoding of \HOp into \HO (\secref{subsec:HOpi_to_HO}) should 
%overcome two key challenges. First, it should 
(a)~enable the communication of arbitrary names, as required to represent delegation,
and 
%Second, it should 
(b)~address the fact that linearity as enforced by session types limits the 
possibilities for representing infinite behaviour. 

To illustrate our encoding of name passing into \HO, we informally introduce some process syntax; formal definitions are given in \secref{subsec:syntax}.
Below, 
$a,b$ are names and $s$ and $\dual{s}$ are 
linear session names (\emph{endpoints}).
%$\lambda x.P$ is a name abstraction of $P$; $\appl{x}{a}$ is a name application; 
Processes $\bout{a}{V} P$ and 
$\binp{a}{x} P$ denote output and input at~$a$, respectively;   
abstractions and applications are denoted
$\lambda x.P$ and $(\lambda x.P)a$, respectively. 
Processes %, respectively;
$\newsp{s}P$, $P \Par Q$, and $\inact$ represent usual forms of name restriction/hiding, parallel composition, and inaction. 

In our encoding, 
%to encode name output, 
we ``pack''
the name to be sent into an abstraction; 
upon reception, the receiver ``unpacks'' this object following a precise protocol on a fresh  session:
%More precisely, our encoding \jpc{of name passing} in \HO is given as:
\begin{align*}
  \map{\bout{a}{b} P}	&= \bout{a}{ \abs{z}{\,\binp{z}{x} (\appl{x}{b})} } \map{P} \\
  \map{\binp{a}{x} Q}	&=	 \binp{a}{y} \newsp{s}{\appl{y}{s} \Par \bout{\dual{s}}{\abs{x}{\map{Q}}} \inact}
\end{align*}
%and as a homomorphism for the other operators.
%, respectively.
%Intuitively, the output of a name $b$ along name $a$ is encoded by
%the output of an abstraction containing $b$; the input of a name is encoded 
%by the input of an abstraction
Thus, 
an abstraction containing the name $b$ is first passed around along $a$.
Following this communication, %our encoding features 
a sequence of (deterministic) reductions between  
$s$ and $\dual{s}$ guarantees that $b$ is properly unpacked by means of abstraction passing
and appropriate applications.
Indeed, 
%\HO 
\newjb{the above encoding}
requires %two 
\newjb{three}
extra reduction steps to mimic a single name communication step in \HOp.
Also, notice that an output action in the source process is translated into an output action in the encoded process (and similarly for input).
This is key to ensure the preservation of session type operators mentioned above (cf. \defref{def:tp}).

\newj{As hinted at above, 
a challenge in 
 encoding $\recp{X}{P}$ is  
preserving linearity  of session names.
Intuitively, we encode the recursion body $P$ as an abstraction 
$\abs{\tilde{x}}{\auxmapp{P}{{}}{\sigma}}$
in which each session name of $P$ (included in 
set $\sigma$)
is converted into a name variable in $\tilde{x}$.
Since  
$\abs{\tilde{x}}{\auxmapp{P}{{}}{\sigma}}$
does not mention (linear) session names,
we may embed it into a 
``duplicator'' process
which implements recursion using higher-order communication~\cite{ThomsenB:plachoasgcfhop}. 
The encoding of the recursion variable $X$
invokes this duplicator in a by-need fashion:
it receives 
$\abs{\tilde{x}}{\auxmapp{P}{{}}{\sigma}}$ and uses two copies of it:
one copy allows us to obtain $P$
through the application of the session names of $P$; 
the other allows us
to invoke the duplicator when needed. 
Interestingly, for this encoding to work 
we require non-tail recursive session types; 
this exploits recent advances on the theory of duality for session types~\cite{TGC14,DBLP:journals/corr/abs-1202-2086}.}


%To preserve session linearity, we proceed as follows.
%Given $\recp{X}{P}$, 
%we encode the recursion body $P$ as an abstraction
%in which free names of $P$ are converted into name variables.
%The resulting higher-order value is embedded in an input-guarded 
%``duplicator'' process~\cite{ThomsenB:plachoasgcfhop}.
%The recursion variable $X$ is then encoded 
%in such a way that it
%simulates recursion unfolding by 
%invoking the duplicator in a by-need fashion.
%That is, upon reception, the abstraction representing the 
%recursion body $P$
%is duplicated: 
%one copy is used to reconstitute the original recursion body $P$ (through
%the application of the free names of $P$); 
%another copy is used to re-invoke the duplicator when needed. 
%Interestingly, for this encoding to work 
%we require non-tail recursive session types; to this end, 
%we apply recent advances on the theory of duality for session types~\cite{TGC14,DBLP:journals/corr/abs-1202-2086}.

%To this end, we
%first record a mapping from recursive variable $X$ to process variable $z_X$.
%Then, we encode the recursion body $P$ as a name abstraction
%in which free names of $P$ are converted into name variables, using \defref{d:auxmap}.
%(Notice that $P$ is first encoded into \HO and then transformed using mapping
%$\auxmapp{\cdot}{{}}{\sigma}$.)
%Subsequently, this higher-order value is embedded in an input-guarded 
%``duplicator'' process~\cite{ThomsenB:plachoasgcfhop}. Finally, we define the encoding of $X$ 
%in such a way that it
%simulates recursion unfolding by 
%invoking the duplicator in a by-need fashion.
%That is, upon reception, the \HO abstraction which encodes  the 
%recursion body $P$
%%containing $\auxmapp{P}{{}}{\sigma}$ 
%is duplicated: 
%one copy is used to reconstitute the original recursion body $P$ (through
%the application of $\fn{P}$); another copy is used to re-invoke
%the duplicator when needed. 
%
%We encode recursion with non-tail recursive session types; for this 
%we apply recent advances on the theory of session duality~\cite{TGC14,DBLP:journals/corr/abs-1202-2086}.

\paragraph{A Plausible Encoding That is Not Precise}
Our notion of \emph{precise encoding} (\defref{def:goodenc}) 
requires the translation of both process and types; it  
admits only process mappings that preserve session types
\emph{and} are fully abstract. Thus, our encodings 
not only exhibit  strong behavioural correspondences, but also 
 relate source and target processes with consistent 
communication structures described by session types.
%Moreover, the notion of encoding includes full abstraction as encodability criteria.
These requirements are demanding and make our developments far from trivial.
In particular, requiring type preservation may rule out other plausible encoding strategies.
To illustrate this point,
consider the  following \newjb{alternative} encoding of %$\sessp$ 
name-passing 
into $\HO$:\footnote{This encoding was suggested by a reviewer of a previous version of this paper.} %defined as
\begin{align*}
   \umap{\binp{a}{x} Q} & = \bout{a}{\abs{x}{\umap{Q}}} \inact \\
     \umap{\bout{a}{b} P} 	&= \binp{a}{x}( \appl{x}{b} \Par \umap{P})
\end{align*}
%and as a homomorphism for the other operators.
{Intuitively, 
the encoding of input takes the initiative by sending an abstraction containing the encoding of its continuation $Q$;
the encoding of output applies this received value to name $b$.}
%rather than sending a package with name $b$, this encoding sends the continuation of the input. 
Hence, this mapping entails  a 
``role inversion'': outputs are translated into inputs, and inputs are translated into outputs. 
Although fairly reasonable, we will see that the encoding $\umap{\cdot}$  
%is far from desirable in a session typed setting: 
is \emph{not type preserving}. Consequently, it is also not \emph{precise}.
%Type preservation is intended to preserve the overall semantics of session types:
Since individual prefixes (input, output, branching, select) 
represent actions in a structured communication sequence (i.e., a protocol abstracted by a session type),
the encoding~$\umap{\cdot}$ would simply alter the meaning of the session protocol in the source language.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\input{calculusdk}

%\section{Higher-Order Session $\pi$-Calculi}
\section{Preliminaries}
\label{sec:prelim}

We introduce 
the \emph{higher-order session $\pi$-calculus} (\HOp).
We first define 
syntax, operational semantics, and 
its sub-calculi (\sessp and \HO).
Then, a type system and behavioural equivalences for \HOp are recalled in 
\secref{sec:types} and \secref{sec:bt}. 
\HOp features first-order abstractions and monadic communication; extensions 
with higher-order abstractions and polyadicity (noted \HOpp and \PHOp, respectively) 
are discussed in \secref{sec:extension}.


%We also introduce two subcalculi of \HOp. In particular, we define the 
%core higher-order session
%calculus (\HO), which 
%%. The \HO calculus is  minimal: it 
%includes constructs for shared name synchronisation and 
%%constructs for session establish\-ment/communication and 
%(monadic) name-abstraction, but lacks name-passing and recursion.

%Although minimal, in \secref{s:expr}
%the abstraction-passing capabilities of \HOp will prove 
%expressive enough to capture key features of session communication, 
%such as delegation and recursion.

\subsection{\HOp: Syntax, Operational Semantics, and Subcalculi}
\label{subsec:syntax}

\paragraph{Syntax}
The syntax of \HOp is defined in \figref{fig:syntax}.
\HOp  is a subcalculus of the language studied 
in~\cite{tlca07}. It is also a variant of the language that we investigated in~\cite{characteristic_bis}, 
which includes higher-order value applications. 


\input{figures/syntax}

%\myparagraph{Values}
\emph{Names} $a,b,c, \dots$ (resp.~$s, \dual{s}, \dots$) 
range over shared (resp. session) names. 
Names $m, n, t, \dots$ are session or shared names.
Dual endpoints are $\dual{n}$ with
$\dual{\dual{s}} = s$ and $\dual{a} = a$.
%We define the dual operation over names $n$ as $\dual{n}$ with
%$\dual{\dual{s}} = s$ and $\dual{a} = a$.
%Intuitively, names $s$ and $\dual{s}$ are dual (two) \emph{endpoints} while 
%shared names represent shared (non-deterministic) points. 
Variables are denoted with $x, y, z, \dots$, 
and recursive variables are denoted with $\varp{X}, \varp{Y} \dots$.
An abstraction %(or higher-order value) 
$\abs{x}{P}$ is a process $P$ with name parameter $x$.
%Symbols $u, v, \dots$ range over identifiers; and  $V, W, \dots$ to denote values. 
\emph{Values} $V,W, \ldots$ include 
identifiers $u, v, \ldots$ %(first-order values) 
and 
abstractions $\abs{x}{P}$ (first- and higher-order values, resp.). 

%\myparagraph{Terms} 

Process terms $P, Q, \ldots$ 
include usual %$\pi$-calculus 
prefixes for sending and receiving values $V$.
%Process $\bout{u}{V} P$ denotes the output of value $V$
%over name $u$, with continuation $P$;
%process $\binp{u}{x} P$ denotes the input prefix on name $u$ of a value
%that 
%will substitute variable $x$ in continuation $P$. 
Processes $\bsel{u}{l} P$ and $\bbra{u}{l_i: P_i}_{i \in I}$ are the
usual session processes for selecting and branching~\cite{honda.vasconcelos.kubo:language-primitives}.
Process 
%ny
%$\appl{x}{u}$ 
$\appl{V}{u}$ 
is the application
which substitutes name $u$ on the abstraction~$V$. 
Typing  ensures that $V$ is not a name.
Recursion   $\recp{X}{P}$ binds the recursive variable $\varp{X}$ in   $P$.
%Prefix $\bsel{u}{l} P$ selects label $l$ on name $u$ and then behaves as $P$.
%Given $i \in I$ 
%Process $\bbra{u}{l_i: P_i}_{i \in I}$ offers a choice on labels $l_i$ with
%continuation $P_i$, given that $i \in I$.
%Others are standard c
Constructs for 
inaction $\inact$,  parallel composition $P_1 \Par P_2$, and 
name restriction $\news{n} P$ are standard.
Session name restriction $\news{s} P$ simultaneously binds endpoints $s$ and $\dual{s}$ in $P$.
%A well-formed process relies on assumptions for
%guarded recursive processes.
Functions $\fv{P}$, $\fn{P}$, and $\fs{P}$ denote, respectively, the sets of free 
%\jpc{recursion}
variables, names, and session names in $P$, and are defined as expected.
We assume $V$ in $\bout{u}{V}{P}$ does not include free recursive 
variables $\rvar{X}$.
If $\fv{P} = \emptyset$, we call $P$ {\em closed}.
%; and closed $P$ without 
%free session names a {\em program}. 




%\subsection{Operational Semantics}
%\label{subsec:semantics}


\paragraph{Operational Semantics}
The  operational semantics of \HOp is defined in terms of a \emph{reduction relation}, 
denoted $\red$, whose rules are
given in 
 \figref{fig:reduction} (top).
 We briefly describe the rules. 
Rule $\orule{App}$ defines  name application.
Rule $\orule{Pass}$ defines a shared interaction at $n$ 
(with $\dual{n}=n$) or a session interaction.
Rule $\orule{Sel}$ is the standard rule for labelled choice/selection. %:
%given an index set $I$, 
%a process selects label $l_j$ on name $n$ over a set of
%labels $\set{l_i}_{i \in I}$ offered by a branching 
%on the dual endpoint $\dual{n}$;
Other rules are standard $\pi$-calculus rules.
Reduction is closed under \emph{structural congruence}, 
noted $\scong$ (cf. \figref{fig:reduction}, bottom). 
We assume the expected extension of $\scong$ to values $V$.
We write $\red^\ast$ for a multi-step reduction.

\input{figures/semantics}

\paragraph{Subcalculi}
%\label{subsec:subcalculi}
%\noi 
As motivated in the introduction, 
we define two \emph{subcalculi} of \HOp: 
%We now define several sub-calculi of \HOp. 
\begin{enumerate}[$\bullet$]
	\item	The  
		{\em core higher-order session calculus}, denoted \HO,
		 lacks recursion and name passing; its 
		formal syntax is obtained from \figref{fig:syntax} by excluding 
		constructs in \nonhosyntax{\text{grey}}.

	\item	\newjb{The   
		 {\em session $\pi$-calculus}, 
		denoted $\sessp$, 
		lacks  
		higher-order communication but includes recursion;
		its 
		formal syntax is obtained from \figref{fig:syntax} by excluding 
		constructs in \nonpisyntax{\text{boxes}}}.

%	\item	The third sub-calculus, denoted \haskp, represents cloud Haskell:
%		\[
%			\begin{array}{rclllll}
%				V,W	& ::= &		u \bnfbar  \abs{x}{P}
%				\\
%				P,Q	& ::= &		\bout{u}{m}{P}  \bnfbar  \binp{u}{x}{P} \bnfbar
%							\bsel{u}{l} P \bnfbar \bbra{u}{l_i:P_i}_{i \in I}
%				\\[1mm]
%					& \bnfbar &	\appl{V}{V} \bnfbar P\Par Q \bnfbar \news{n} P \bnfbar \inact
%		\end{array}
%		\]
\end{enumerate}
%
Let $\CAL \in \{\HOp, \HO, \sessp\}$. We write 
$\CAL^{-\mathsf{sh}}$ to denote the calculus $\CAL$ without shared names:
we delete $a,b$ from $n$. 
Thus, languages in $\CAL^{-\mathsf{sh}}$ feature linear, deterministic behaviour only.
In \secref{sec:positive}
we shall demonstrate that 
$\HOp$, $\HO$, and $\sessp$ have the same expressivity,
and that $\CAL$ is strictly more expressive than $\CAL^{-\mathsf{sh}}$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Preliminaries}

\subsection{Session Types for \HOp}
\label{sec:types}

We state key definitions and properties for the session type system for \HOp.
The considered type system,
introduced in~\cite{KouzapasPY17},
 distills the key features of~\cite{tlca07,MostrousY15} and so it is simpler.
 Below we provide essential definitions; see \appref{app:types} for definitions of type equivalence and type duality, and 
for a complete account of the typing rules.


%The system almost identical with the system developed in~\cite{characteristic_bis}
%and we describe it in brief.
%Our system is simpler than that in~\cite{tlca07,MostrousY15}, thus distilling the key
%features of higher-order sessions. %communications. %in a session-typed setting.

%\smallskip 

%\subsection{Types}
%\label{subsec:types}
%\paragraph{Types.}
\begin{figure}[t!]
	\begin{align*}
		U & \bnfis 	\nonhosyntax{C} \bnfbar \nonpisyntax{L}
		\\
		C  & \bnfis		S \bnfbar \chtype{S} \bnfbar \nonpisyntax{\chtype{L}}
\\		
L & \bnfis		\shot{C} \bnfbar \lhot{C}
		\\ 
		S & \bnfis 	\btout{U} S \bnfbar \btinp{U} S \bnfbar \btsel{l_i:S_i}_{i \in I}
%		\\ 
%						& \bnfbar & 
						\bnfbar \btbra{l_i:S_i}_{i \in I} \bnfbar  \trec{t}{S} \bnfbar \vart{t}  \bnfbar \tinact
	\end{align*}
	\caption{Syntax of session types for $\HOp$.\label{f:types}}
\end{figure}

The syntax of types for \HOp is given in \figref{f:types}. We write $\Proc$ to denote the process type.
Value type $U$ includes
  first-order types $C$ and  higher-order
types $L$.
%Note that we dissallow type $\chtype{U}$, thus
%in the type discipline shared names cannot carry shared names.
%In name types, $\chtype{U}$ is shared name types 
%which are sent via shared names. 
Types $\shot{C}$ and $\lhot{C}$ denote
{\em shared} and {\em linear} higher-order 
%\jpc{functional}
types, respectively.
Session types, denoted by $S$, follow the standard binary session type syntax~\cite{honda.vasconcelos.kubo:language-primitives}, with
the extension that carried types $U$ may be higher-order.
Shared channel types are denoted $\chtype{S}$ and $\chtype{L}$.
%,
%used to type abstraction values.
%$\lhot{C}$ \cite{tlca07,mostrous_phd} ensures values which contain free 
%session names used once. 
 %We write $S$ to denote %binary 
%session types.  {\em Output type}
%$\btout{U} S$ %is assigned to a name that 
%first sends a value of
%type $U$ and then follows the type described by $S$.  Dually,
%$\btinp{U} S$ denotes an {\em input type}. The {\em branching type}
%$\btbra{l_i:S_i}_{i \in I}$ and the {\em selection type}
%$\btsel{l_i:S_i}_{i \in I}$ define the labelled choice. 
%We assume the {\em recursive type} $\trec{t}{S}$ is guarded,
%i.e.,  $\trec{t}{\vart{t}}$ is not allowed. 
%%We stress that carried type $U$ in $\btout{U} S$ and
%%$\btinp{U} S$ can contain free type variables, which is crucial
%%to encode $\HOp$ into $\HO$.
%Type $\tinact$ is the termination type. 
\newjb{Types of \HO exclude $\nonhosyntax{C}$ from 
value types $U$; the types of \sessp exclude $\nonpisyntax{L}$ and $\nonpisyntax{\chtype{L}}$.}
From each $\CAL \in \{\HOp, \HO, \pi \}$, $\CAL^{-\mathsf{sh}}$ 
excludes shared name types ($\chtype{S}$ and $\chtype{L}$), 
from name type $C$.

\newj{We write $S \dualof S'$ if $S$ is the \emph{dual} of $S'$.   
Intuitively, session type duality is  obtained by 
dualising $!$ by $?$, $?$ by $!$, $\oplus$ by $\&$, and $\&$ by $\oplus$,  
including the fixed point construction.
We use the \emph{co-inductive} definition of duality given in \cite{TGC14};}
%(see \defref{def:dual} in the Appendix). 
see~\appref{app:duality} for details.


%\smallskip 

%\subsection{Typing System of \HOp}
%\label{subsec:typing}
%\paragraph{Typing Environments / Judgements}
We consider 
\newjb{shared, linear, and session}
\emph{environments}, denoted $\Gamma$, $\Lambda$, and $\Delta$, \newjb{resp.}:
\begin{align*}
		\Gamma  & \bnfis  \emptyset \bnfbar \Gamma \cat \varp{x}: \shot{C} \bnfbar \Gamma \cat u: \chtype{S} \bnfbar \Gamma \cat u: \chtype{L} 
		\bnfbar \Gamma \cat \rvar{X}: \Delta
\\
		\Lambda & \bnfis  \emptyset \bnfbar \Lambda \cat \AT{x}{\lhot{C}}
		 \\
		\Delta   & \bnfis   \emptyset \bnfbar \Delta \cat \AT{u}{S}
\end{align*}
%Environment 
$\Gamma$ maps variables and shared names to value types, and recursive 
variables to session environments; % (see below);  
it admits weakening, contraction, and exchange principles.
$\Lambda$ maps variables to 
%the
linear
%functional 
higher-order
types;   $\Delta$  maps   
session names to session types. 
Both $\Lambda$ and $\Delta$
%behave linearly: they 
are
only subject to exchange.  
Domains of $\Gamma,
\Lambda$ and $\Delta$ are assumed pairwise distinct. 
$\Delta_1\cdot \Delta_2$ is the disjoint union of $\Delta_1$ and $\Delta_2$.  

Given the above intuitions for environments, 
the typing judgements for values $V$ and processes $P$ are self-explanatory.
They are denoted 
$\Gamma; \Lambda; \Delta \proves V \hastype U$ and $\Gamma; \Lambda; \Delta \proves P \hastype \Proc$.
%
%\begin{center}
%	\begin{tabular}{c}
%		$\Gamma; \Lambda; \Delta \proves V \hastype U \qquad \qquad \qquad \qquad \Gamma; \Lambda; \Delta \proves P \hastype \Proc$
%	\end{tabular}
%\end{center}
%%
%\noi The first judgement states that under environments $\Gamma; \Lambda; \Delta$ value $V$
%has type $U$, whereas the second judgement states that under
%environments $\Gamma; \Lambda; \Delta$ process $P$ has the process type~$\Proc$. %
 
%\smallskip

\input{figures/type_system_selected}
%\paragraph{Typing Rules} 

\figref{fig:typerulesmys} gives
selected typing rules; 
see \appref{app:typrules} 
%see \cite{KouzapasPY15} 
for a full account.
%Types for session names/variables $u$ and
%directly derived from the linear part of the typing
%environment, i.e.~type maps $\Delta$ and $\Lambda$.
%Rules $\trule{Sess, Sh, LVar}$ are name and variable introduction rules. 
The shared type $\shot{C}$ %for shared higher order values $V$
is derived using Rule~\textsc{(Prom)} only  
if the value has a linear type with an empty linear
environment.
Rule~\textsc{(EProm)} allows us to freely use a \newj{shared
type variable as linear}.
%
Abstraction values are typed with Rule~\textsc{(Abs)}.
%The key type for an abstraction is the type for
%the bound variables of the abstraction, i.e.~for
%bound variable type $C$ the abstraction
%has type $\lhot{C}$.
Application typing
is governed by Rule~\textsc{(App)}: we expect
the type $C$ of an application name $u$ 
to match the type of the application variable $x$ (i.e., $\lhot{C}$ or $\shot{C}$).
%
%A process prefixed with a session send operator $\bout{k}{V} P$
%is typed using rule $\trule{Send}$.
In Rule~\textsc{(Send)}, 
the type $U$ of value $V$ should appear as a prefix in the session type $\btout{U} S$ of $u$.
Rule~\textsc{(Rcv)} is its dual.  
%defined the typing for the 
%reception of values $\binp{u}{V} P$.
%the type $U$ of a receive value should 
%appear as a prefix on the session type $\btinp{U} S$ of $u$.
Rules~\textsc{(Req)} and~\textsc{(Acc)} type interaction along shared names;
the type of the sent/received object 
($S$ and $L$, resp.) should
match the type of the sent/received subject
($\chtype{S}$ and $\chtype{L}$, resp.).

%\begin{example}
%Recall the session type $S$, given in the introduction:
%$$
%S = \btbra{{up}:\btinp{\lhot{C}}\btout{\mathsf{ok}}\tinact ~ , ~ {down}:\btout{\shot{C}}\btout{\mathsf{ok}}\tinact ~ , ~{quit}:\btout{\mathsf{bye}}\tinact}_{}\,.
%$$
%It is easy to see that, assuming  that $\abs{y}{R}$ is of type $\lhot{{C}}$, 
% the following process $P_s$
%implements $S$:
%\begin{align*}
%P_s = \bbra{s}{~& up: \binp{s}{x}\news{a} ( \appl{x}{a} \Par \bout{s}{\mathsf{ok}} \inact) 
%\\
%& down: \bout{s}{\abs{y}{R}}\news{a} ( \appl{x}{a} \Par \bout{s}{\mathsf{ok}} \inact) 
%\\
%& quit: \bout{s}{\mathsf{bye}} \inact
%~}
%\end{align*}
%The dual of $S$, denoted $\dual{S}$, is as follows:
%$$
%\dual{S} = \btsel{{up}:\btout{\lhot{C}}\btinp{\mathsf{ok}}\tinact ~ , ~ {down}:\btinp{\shot{C}}\btinp{\mathsf{ok}}\tinact ~ , ~{quit}:\btinp{\mathsf{bye}}\tinact}_{}\,.
%$$
%and so the following processes can be seen as two different implementations of $\dual{S}$:
%$$
%Q_s = \bsel{s}{down}\binp{s}{x}(\appl{x}{b} \Par \binp{s}{n}\inact)
%\qquad
%Q'_s = \bsel{s}{up}\bout{s}{\abs{z}{R'}}\binp{s}{n}\inact
%$$
%\qed
%\end{example}

%\noindent 

We close this section  by stating  type soundness for \HOp, as established in~\cite{KouzapasPY17}; it implies 
type soundness for \HO, \sessp, and $\CAL^{-\mathsf{sh}}$. 
We require two auxiliary definitions. First, 
we focus on \emph{balanced} session environments: 
%that contain dual endpoints typed with dual types.
%The following definition ensures two session endpoints 
%are dual each other. 

%\smallskip

\begin{definition}[Balanced Environments]\label{d:wtenv}%\rm
	%Let $\Delta$ be a session environment.
	We say that a session environment $\Delta$ is {\em balanced} if whenever
	$s: S_1, \dual{s}: S_2 \in \Delta$ then $S_1 \dualof S_2$.
\end{definition}

Second, we define a notion of reduction for session environments:

\begin{definition}%[Reduction of Session Environments]%\rm
	\label{def:ses_red}
	We define the relation $\red$ on session environments as:
	\begin{eqnarray*}
			\Delta \cat s: \btout{U} S_1 \cat \dual{s}: \btinp{U} S_2 & \red &
			\Delta \cat s: S_1 \cat \dual{s}: S_2\\%[1mm]
			\Delta \cat s: \btsel{l_i: S_i}_{i \in I} \cat \dual{s}: \btbra{l_i: S_i'}_{i \in I} &\red& 
			 \Delta \cat s: S_k \cat \dual{s}: S_k' \ (k \in I)
		\end{eqnarray*}
	%\end{center}
%\begin{tabular}{rcl}
%	\setlength{\tabcolsep}{0pt}
%	$\Delta \cat s: \btout{U} S_1 \cat \dual{s}: \btinp{U} S_2$ & $\red$ & 
%	$\Delta \cat s: S_1 \cat \dual{s}: S_2$\\[1mm]
%	$\Delta \cat s: \btsel{l_i: S_i}_{i \in I} \cat \dual{s}: \btbra{l_i: S_i'}_{i \in I}$ & $\red$ & $\Delta \cat s: S_k \cat \dual{s}: S_k' \ (k \in I)$
%\end{tabular}
%\[
%\begin{array}{rcl}
%\Delta \cat s: \btout{U} S_1 \cat \dual{s}: \btinp{U} S_2 & \red & 
%\Delta \cat s: S_1 \cat \dual{s}: S_2\\[1mm]
%\Delta \cat s: \btsel{l_i: S_i}_{i \in I} \cat \dual{s}: \btbra{l_i: S_i'}_{i \in I} & \red & \Delta \cat s: S_k \cat \dual{s}: S_k' \ (k \in I)
%\end{array}
%\]
\end{definition}

%\smallskip

%The following result %Theorem 7.3 in M\&Y
%\noi 

%\smallskip

We then have:

\begin{theorem}[Type Soundness~\cite{KouzapasPY17}]\label{t:sr}\rm
%	\begin{enumerate}[1.]
%		\item	(Subject Congruence) Suppose $\Gamma; \es; \Delta \proves P \hastype \Proc$.
%			Then $P \scong P'$ implies $\Gamma; \es; \Delta \proves P' \hastype \Proc$.
%
%		\item
%			(Subject Reduction)
			Suppose $\Gamma; \es; \Delta \proves P \hastype \Proc$
			with
			$\Delta$ balanced. 
			Then $P \red P'$ implies $\Gamma; \es; \Delta'  \proves P' \hastype \Proc$
			and $\Delta = \Delta'$ or $\Delta \red \Delta'$
			with $\Delta'$ balanced. 
%	\end{enumerate}
\end{theorem}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Behavioural Theory for \HOp}\label{sec:bt}
%\input{congruence}

We first define reduction-closed, barbed congruence ($\cong$, \defref{def:rc}) as the
reference equivalence relation for \HOp processes.
We then recall two characterisations of $\cong$:
\emph{characteristic} and
\emph{higher-order bisimilarities}   
 (denoted $\fwb$ and $\hwb$, cf. \defsref{d:fwb} and \ref{d:hbw}). 
 We refer to \appref{app:behavioural} for omitted definitions, 
 and to our previous paper~\cite{KouzapasPY17} for a detailed treatment of these behavioural equivalences. 
%Here we focus on collecting intuitions; omitted details are in the Appendix and in~\cite{KouzapasPY15}.

\subsubsection{Reduction-Closed, Barbed Congruence ($\cong$)}
\label{subsec:rc}
%We first define \emph{confluence} over session environments $\Delta$:

We consider \emph{typed relations} $\Re$ that relate  closed terms whose
session environments %and the two session environments
are balanced  and \emph{confluent}:

\begin{definition}[Session Environment Confluence]
Let $\red^\ast$ denote multi-step reduction as in \defref{def:ses_red}.
	We denote $\Delta_1 \bistyp \Delta_2$ if there exists $\Delta$ such that
	$\Delta_1 \red^\ast \Delta$ and $\Delta_2 \red^\ast \Delta$.
\end{definition}

%\smallskip 
%\noi Reduction-closed, barbed congruence is defined over typed
%processes:


\begin{definition}[Typed Relation]
	We say that
	$\Gamma; \emptyset; \Delta_1 \proves P \hastype \Proc\ \Re \ \Gamma; \emptyset; \Delta_2 \proves Q \hastype \Proc$
	is a {\em typed relation} whenever
	$P$ and $Q$ are closed;
	$\Delta_1$ and $\Delta_2$ are balanced; and 
	$\Delta_1 \bistyp \Delta_2$.
	We write $\horel{\Gamma}{\Delta_1}{P}{\ \Re \ }{\Delta_2}{Q}$
	for the typed relation $\Gamma; \emptyset; \Delta_1 \proves P \hastype \Proc\ \Re \ \Gamma; \emptyset; \Delta_2 \proves Q \hastype \Proc$.
\end{definition}

%\smallskip 

%\noi Next we define  {\em barbs}with respect to types. 
%\noi 
As usual, a \emph{barb} $\barb{n}$ is an observable on an output prefix with subject $n$~\cite{MiSa92}.
Notice that observing output barbs is enough to (indirectly) observe input actions.
A \emph{weak barb} $\Barb{n}$ is a barb after zero or more reduction steps.
Typed barbs $\barb{n}$ (resp.\ $\Barb{n}$)
occur on typed processes $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$.
When $n$ is a session name we require that its dual endpoint $\dual{n}$ is not present
in the session environment $\Delta$:
%\smallskip 

\begin{definition}[Untyped and Typed Barbs]\label{d:barb}%\rm
	Let $P$ be a closed process. We define:
	\begin{enumerate}[1.]
		\item	
		$P \barb{n}$ if $P \scong \newsp{\tilde{m}}{\bout{n}{V} P_2 \Par P_3}, n \notin \tilde{m}$. %; $P \Barb{n}$ if $P \red^* \barb{n}$.

		\item	$\Gamma; \Delta \proves P \barb{n}$ if
			$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ with $P \barb{n}$ and $\dual{n} \notin \dom{\Delta}$.

			$\Gamma; \Delta \proves P \Barb{n}$ if $P \red^* P'$ and
			$\Gamma; \Delta' \proves P' \barb{n}$.			
	\end{enumerate}
\end{definition}

%\smallskip 

%\noi 

To define a congruence relation, we introduce the family $\C$ of process contexts:

\begin{definition}[Context]
	A context $\C$ is defined as:
\begin{eqnarray*}
		\C & \bnfis &  \hole \bnfbar \bout{u}{V} \C \bnfbar \binp{u}{x} \C \bnfbar \bout{u}{\lambda x.\C} P \bnfbar \news{n} \C
		\bnfbar (\lambda x.\C)u \bnfbar \recp{X}{\C}  
		\\
		& \bnfbar &  \C \Par P \bnfbar P \Par \C \bnfbar \bsel{u}{l} \C \bnfbar \bbra{u}{l_1:P_1,\cdots,l_i:\C,\cdots,l_n:P_n} 
	\end{eqnarray*}
	%	\begin{tabular}{rcl}
%		$\C$ & $\bnfis$ & $\hole \bnfbar \bout{u}{V} \C \bnfbar \binp{u}{x} \C \bnfbar \bout{u}{\lambda x.\C} P \bnfbar \news{n} \C
%		\bnfbar (\lambda x.\C)u \bnfbar \recp{X}{\C}$ 
%		\\
%		&$\bnfbar$& $\C \Par P \bnfbar P \Par \C
%		\bnfbar \bsel{u}{l} \C \bnfbar \bbra{u}{l_1:P_1,\cdots,l_i:\C,\cdots,l_n:P_n}$
%	\end{tabular}
%\smallskip 
%\noi 
Notation $\context{\C}{P}$ replaces 
the hole $\hole$ in $\C$ with $P$.
\end{definition}

%\smallskip 

%\noi 
We define reduction-closed, barbed congruence \cite{HondaKYoshida95}. 

%\smallskip 

\begin{definition}[Barbed Congruence]
\label{def:rc}
	Typed relation
	$\horel{\Gamma}{\Delta_1}{P}{\ \Re\ }{\Delta_2}{Q}$
	is a {\em reduction-closed, barbed congruence} whenever:
	\begin{enumerate}[1.]
		\item	If $P \red P'$ then there exist $Q', \Delta_1'$,  $\Delta_2'$ such that $Q \red^* Q'$ and
			$\horel{\Gamma}{\Delta_1'}{P'}{\ \Re\ }{\Delta_2'}{Q'}$; 
			%and its symmetric case;
%		\item	If $Q \red P_2'$ then $\exists P_1', P_1 \red^* P_1'$ and
%		$\horel{\Gamma}{\Delta_1'}{P_1'}{\ \Re\ }{\Delta_2'}{P_2'}$
%		\end{itemize}

%		\item
%		\begin{itemize}
			\item	If $\Gamma;\Delta_1 \proves P \barb{n}$ then $\Gamma;\Delta_2 \proves Q \Barb{n}$; %and its symmetric case; 

%			\item	If $\Gamma;\emptyset;\Delta \proves P_2 \barb{s}$ then $\Gamma;\emptyset;\Delta \proves P_1 \Barb{s}$.
%		\end{itemize}

		\item	For all $\C$, there exist $\Delta_1'',\Delta_2''$ such that  $\horel{\Gamma}{\Delta_1''}{\context{\C}{P}}{\ \Re\ }{\Delta_2''}{\context{\C}{Q}}$;
		                      \item	The symmetric cases of 1 and 2.                
	\end{enumerate}
	The largest such relation is denoted with $\cong$.
\end{definition}

{
\subsubsection{Two Equivalence Relations: $\hwb$ and $\fwb$}\label{ss:equiv}
In~\cite{characteristic_bis,KouzapasPY17} we have characterised
reduction-closed, barbed congruence for \HOp
via two typed relations, called
{\em characteristic bisimilarity}
and 
\emph{higher-order bisimilarity}.
%The definition of characteristic bisimilarity 
Their definition 
uses an early \emph{typed}
labelled transition system (LTS) on processes, informed by session
types. 
The interaction of processes with their environment is defined using action labels:
%
\begin{definition}[Action Labels]\label{d:labels}
The set of action labels for \HOp, ranged over by $\ell, \ell', \ldots$, is defined as follows:
\begin{center}
	\begin{tabular}{l}
		$\ell
			\bnfis  \tau 
			\bnfbar	\news{\widetilde{m}} \bactout{n}{V}
			\bnfbar	\bactinp{n}{V} 
			\bnfbar	\bactsel{n}{l} 
			\bnfbar	\bactbra{n}{l}$
	\end{tabular}
\end{center}
\end{definition}
%
\noi 
Label $\tau$ defines internal actions.
Action
$\news{\widetilde{m}} \bactout{n}{V}$
denotes the sending of value $V$
over channel $n$ with a possible empty set of restricted names
$\widetilde{m}$ 
(we may write $\bactout{n}{V}$ when $\widetilde{m}$ is empty).
Dually, the action for value reception is 
$\bactinp{n}{V}$.
Actions for select and branch on
a label~$l$ are denoted $\bactsel{n}{l}$ and $\bactbra{n}{l}$, respectively.
We write $\fn{\ell}$ and $\bn{\ell}$ to denote the
sets of free/bound names in $\ell$, respectively.
The sets of actions for \HO and \sessp is derived from the above syntax, in line with the syntax of values $V$ in \figref{fig:syntax}.
This way, e.g., $\news{\widetilde{m}} \bactout{n}{\abs{x}{P}}$ is an action label for \HO but not for \sessp;
similarly, $\bactinp{s}{n}$ is an action label for \sessp but not for \HO.

%\end{document}

\paragraph{A Typed Labelled Transition System}
\newjb{Given a label $\ell$, % (a visible action or $\tau$),
we write $\Gamma; \es; \Delta \proves P \hby{\ell} \Delta' \proves P'$ to denote 
a (strong) transition. % in this LTS. 
Weak transitions are as expected: we write $\Hby{}$ for the reflexive,
transitive closure of $\hby{\tau}$,
$\Hby{\ell}$ for %transitions
$\Hby{}\hby{\ell}\Hby{}$, and 
$\Hby{\hat{\ell}}$ for $\Hby{\ell}$ if
$\ell\not = \tau$ and $\Hby{}$ otherwise.
%We thus write $\Gamma; \es; \Delta \proves P \Hby{\hat{\ell}} \Delta' \proves P'$.
}
%The main intuition %for its definition  
Intuitively, the transitions 
of a typed process should be enabled by its associated typing: % environment:
%
%\[
%	\tree {
%		P \hby{\ell} P' \qquad (\Gamma, \Delta) \hby{\ell} (\Gamma, \Delta')
%	}{
%		\Gamma; \es; \Delta \proves P \hby{\ell} \Delta' \proves P' \hastype \Delta'
%	}
%\]
$$
\text{if } P \hby{\ell} P' \text{ and } (\Gamma, \Delta) \hby{\ell} (\Gamma, \Delta') \text{ then }
\Gamma; \es; \Delta \proves P \hby{\ell} \Delta' \proves P'.
$$
%
%\noi 
As an example of how types enable transitions, consider the rule for input:
%
\[
	\tree{
		\dual{s} \notin \dom{\Delta} 
		\quad~~ 
		\Gamma; \Lambda'; \Delta' \proves V \hastype U
		\quad~~
		V = m \vee  V \scong \omapchar{U} \vee V \scong \abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}
					\textrm{ with } t \textrm{ fresh} 
	}{
		(\Gamma; \Lambda; \Delta \cat s: \btinp{U} S) \hby{\bactinp{s}{V}} (\Gamma; \Lambda\cat\Lambda'; \Delta\cat\Delta' \cat s: S)
	}
\]
%\noi
This rule states that a session environment can input a value
if such a value is typed with an input prefix and is either
a name $m$, a \emph{characteristic value} $\omapchar{U}$,  or a \emph{trigger value} (the abstraction
$\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}$). 
A characteristic value
is the {simplest} process that  inhabits a type (here, the
type $U$ carried by the input prefix). The above rule is used to limit
the input actions that can be observed from a session input prefix.
For more details on the typed LTS and the characteristic process definition
see% \appref{app:behavioural} and
~\cite{characteristic_bis,KouzapasPY17}.

\paragraph{Characterising $\cong$}
We now recall the definition of \emph{higher-order bisimilarity} and 
\emph{characteristic bisimilarity}, as jointly introduced in~\cite{KouzapasPY17}.
These bisimilarity relations
use two different \emph{trigger processes}:
%
\begin{eqnarray}
	\htrigger{t}{V}	& \defeq &
	\begin{cases}
		\hotrigger{t}{x}{s}{V} & {\text{if $V$ is a first-order value}}\\
		\binp{t}{x} \newsp{s}{\binp{s}{y} (\appl{y}{x}) \Par \bout{\dual{s}}{V} \inact} & \text{if $V$ is a higher-order value}
		\end{cases}
	\label{eqb:0} \\
	\ftrigger{t}{V}{U}	& \defeq &	\fotrigger{t}{x}{s}{U}{V}	
	\label{eqb:4}
\end{eqnarray}
%
The process in \eqref{eqb:0} is called \emph{higher-order trigger process},
while process in \eqref{eqb:4} is called \emph{characteristic trigger process}.
Notice that while 
in \eqref{eqb:0} there is a higher-order input on $t$, 
in \eqref{eqb:4} the variable $x$ does not play any r\^{o}le.
Process $\mapchar{U}{y}$ is the \emph{characteristic process} of type $U$, implemented along name $y$.
We use higher-order trigger processes to define \emph{higher-order bisimilarity}:

\begin{definition}[Higher-Order Bisimilarity]
	\label{d:hbw}
	A typed relation $\Re$ is a {\em  higher-order bisimulation} if 
	for all $\horel{\Gamma}{\Delta_1}{P_1}{\ \Re \ }{\Delta_2}{Q_1}$ 
%
	\begin{enumerate}[1)]
		\item 
				Whenever 
				$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\widetilde{m_1}} \bactout{n}{V_1}}}{\Delta_1'}{P_2}$, there exist 
				$Q_2$, $V_2$, $\Delta'_2$ such that 
				$\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\widetilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}$ and, for a fresh $t$, 
				\[
					\begin{array}{lrlll}
						\Gamma; \Delta''_1  \proves  {\newsp{\widetilde{m_1}}{P_2 \Par \htrigger{t}{V_1}}}
						\ \Re\ 
						\Delta''_2 \proves {\newsp{\widetilde{m_2}}{Q_2 \Par \htrigger{t}{V_2}}}
					\end{array}
				\]
		\item	
				For all $\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}$ such that 
				$\ell$ is not an output, 
				there exist $Q_2$, $\Delta'_2$ such that 
				$\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\hat{\ell}}}{\Delta_2'}{Q_2}$
				and
				$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re \ }{\Delta_2'}{Q_2}$; and 

		\item	The symmetric cases of 1 and 2.                
	\end{enumerate}
%
	The largest such bisimulation is called \emph{higher-order bisimilarity}, denoted by $\hwb$.
\end{definition}


We exploit characteristic trigger processes to define \emph{characteristic bisimilarity}: 

\begin{definition}[Characteristic Bisimilarity]
\label{d:fwb}
	A typed relation $\Re$ is a {\em  characteristic bisimulation} if 
	for all $\horel{\Gamma}{\Delta_1}{P_1}{\ \Re \ }{\Delta_2}{Q_1}$, 
%
	\begin{enumerate}[1)]
		\item 
				Whenever 
				$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\widetilde{m_1}} \bactout{n}{V_1: U_1}}}{\Delta_1'}{P_2}$ 
				then there exist 
				$Q_2$, $V_2$, $\Delta'_2$ such that 
				$\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\widetilde{m_2}}\bactout{n}{V_2: U_2}}}{\Delta_2'}{Q_2}$
				and, for a fresh $t$,
%
				\[
					\Gamma; \Delta''_1  \proves  {\newsp{\widetilde{m_1}}{P_2 \Par \ftrigger{t}{V_1}{U_1}}}
	 				\ \Re\ 
					\Delta''_2 \proves {\newsp{\widetilde{m_2}}{Q_2 \Par \ftrigger{t}{V_2}{U_2}}}
				\]

		\item	
				For all $\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}$ such that 
				$\ell$ is not an output, there exist $Q_2$, $\Delta'_2$ such that 
				$\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\hat{\ell}}}{\Delta_2'}{Q_2}$
				and
				$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re \ }{\Delta_2'}{Q_2}$; and 

		\item	The symmetric cases of 1 and 2.                
	\end{enumerate}
%
	The largest such bisimulation is called \emph{characteristic bisimilarity}, denoted by $\fwb$.
\end{definition}




We state the following important coincidence result: %, which attests the significance of $\hwb$:
\begin{theorem}[\cite{KouzapasPY17}]\label{t:coincide}
	Typed relations $\cong$, $\hwb$, and $\fwb$ coincide for \HOp processes.
\end{theorem}

%\begin{proof}
%Coincidence of $\cong$ and $\fwb$ was established in~\cite{characteristic_bis}.
%Coincidence of $\hwb$ with $\cong$ and $\fwb$ is a new result: see \cite{KouzapasPY15}
%for details. \qed
%\end{proof}

\begin{remark}[Differences between $\hwb$ and $\fwb$]
Although $\hwb$ and $\fwb$ are conceptually similar, they differ in the kind of 
trigger process considered. Because of the application in 
$\htrigger{t}{V}$ (cf. \eqref{eqb:0}), $\hwb$ cannot be used to reason about first-order session processes (i.e., processes without higher-order features). In contrast, $\fwb$ is more general: it can uniformly input characteristic, first- or higher-order values. 
\end{remark}

%\begin{definition}[Characteristic Bisimilarity]\rm
%	\label{d:fwb}
%
%	A typed relation $\Re$ is a {\em characteristic bisimulation} if 
%	for all $\horel{\Gamma}{\Delta_1}{P_1}{\ \Re \ }{\Delta_2}{Q_1}$ 
%	if whenever:
%	\begin{enumerate}[1)]
%		\item	$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}} \bactout{n}{V_1: U}}}{\Delta_1'}{P_2}$
%				then there exist  $Q_2$, $V_2$, $\Delta'_2$ such that 
%				$\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}}\bactout{n}{V_2: U}}}{\Delta_2'}{Q_2}$
%				and, for fresh $t$,
%				$
%				\begin{array}{lrlll}
%					\Gamma; \Delta''_1 \proves {\newsp{\tilde{m_1}}{P_2 \Par  \ftrigger{t}{V_1}{U_1}}}
%					\ \Re\ \Delta''_2 \proves {\newsp{\tilde{m_2}}{Q_2 \Par \ftrigger{t}{V_2}{U_2}}}
%				\end{array}
%				$
%
%			\item	For all $\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}$ such that 
%					$\ell$ is not an output, there exist $Q_2$, $\Delta'_2$ such that 
%					$\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\hat{\ell}}}{\Delta_2'}{Q_2}$
%					and $\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re \ }{\Delta_2'}{Q_2}$; and 
%
%			\item	The symmetric cases of 1 and 2.
%	\end{enumerate}
%	The largest such bisimulation is called \emph{characteristic bisimilarity} and denoted by $\fwb$.
%\end{definition}


\paragraph{An up-to technique}
As mentioned above, processes that do not use shared names (e.g., those in languages in $\CAL^{-\mathsf{sh}}$) are deterministic. 
Internal transitions associated to session interactions or  
$\beta$-reductions are deterministic.  
To define an auxiliary proof technique that exploits determinacy we require some auxiliary definitions.
Recall that $\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ denotes an internal (typed) transition.
		
%\begin{definition}[Deterministic Transitions]
%\label{def:dettrans}
%	Suppose $\Gamma; \es; \Delta \proves P \hastype \Proc$ \newc{with balanced~$\Delta$}.
%	Transition $\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ is called:
%	\begin{enumerate}[$-$]
%		\item 
%				a {\em \sesstran} whenever transition $P \by{\tau} P'$ 
%				is derived using Rule~$\ltsrule{Tau}$ 
%				(where $\subj{\ell_1}$ and $\subj{\ell_2}$ in the premise are dual endpoints), 
%				possibly followed by uses of Rules~$\ltsrule{Alpha}$, $\ltsrule{Res}$, $\ltsrule{Rec}$, or $\ltsrule{Par${}_L$}/
%				\ltsrule{Par${}_R$}$ (cf. \figref{fig:untyped_LTS}).
%		\item
%				a {\em \betatran} whenever transition $P \by{\tau} P'$
%				is derived using Rule $\ltsrule{App}$,
%				possibly followed by uses of Rules~$\ltsrule{Alpha}$, $\ltsrule{Res}$, $\ltsrule{Rec}$, or $\ltsrule{Par${}_L$}/
%				\ltsrule{Par${}_R$}$ (cf. \figref{fig:untyped_LTS}).
%	\end{enumerate}
%\end{definition}
%


The following up-to technique, based on determinacy properties, will be useful in proofs~(\secref{sec:positive}).

 
 \begin{notation}[Deterministic Transitions]
 \label{not:dettrans}
We distinguish two kinds of  $\tau$-transitions:
\emph{session transitions}, noted 
$\horel{\Gamma}{\Delta}{P}{\hby{\stau}}{\Delta'}{P'}$,
and 
\emph{$\beta$-transitions}, noted $\horel{\Gamma}{\Delta}{P}{\hby{\btau}}{\Delta'}{P'}$.
Intuitively, $\hby{\stau}$  results from a session communication (i.e., synchronization between
two dual endpoints), while 
  $\hby{\btau}$ results from an application. 
 We write  $\horel{\Gamma}{\Delta}{P}{\hby{\dtau}}{\Delta'}{P'}$ to denote
	 a session transition or a $\beta$-transition.
	See~\cite{KouzapasPY17} for formal definitions of $\hby{\btau}$  and $\hby{\stau}$. % rely on an LTS for \HOp;  for details.
 \end{notation}
 
%The auxiliary definition below allows us to distinguish two kinds of  internal transitions:
%\emph{session transitions} and \emph{$\beta$-transitions} (denoted 
%$\horel{\Gamma}{\Delta}{P}{\hby{\stau}}{\Delta'}{P'}$
%and $\horel{\Gamma}{\Delta}{P}{\hby{\btau}}{\Delta'}{P'}$, respectively).
%
%\begin{definition}[Deterministic Transition]
%\label{def:dettrans}
%	Let  $\Gamma; \es; \Delta \proves P \hastype \Proc$ be a balanced \HOp process. 
%	Transition $\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ is called:
%	\begin{enumerate}[$-$]
%		\item	{\em Session transition}
%				whenever the untyped transition $P \by{\tau} P'$ 
%				is derived using  rule~$\ltsrule{Tau}$ 
%				(where $\subj{\ell_1}$ and $\subj{\ell_2}$ in the premise are dual endpoints), 
%				possibly followed by uses of
%				$\ltsrule{Alpha}$, $\ltsrule{Res}$, $\ltsrule{Rec}$, or $\ltsrule{Par${}_L$}/
%				\ltsrule{Par${}_R$}$.
%		
%		\item	{\em $\beta$-transition}
%				whenever the untyped transition $P \by{\tau} P'$
%				is derived using rule $\ltsrule{App}$,
%				possibly followed by uses of  $\ltsrule{Alpha}$, $\ltsrule{Res}$, $\ltsrule{Rec}$, or $\ltsrule{Par${}_L$}/
%				\ltsrule{Par${}_R$}$.
%	\end{enumerate}
%%
%	We write
%	$\horel{\Gamma}{\Delta}{P}{\hby{\stau}}{\Delta'}{P'}$
%	and 
%	$\horel{\Gamma}{\Delta}{P}{\hby{\btau}}{\Delta'}{P'}$
%	to denote session and $\beta$-transitions, resp. Also, 
%	 $\horel{\Gamma}{\Delta}{P}{\hby{\dtau}}{\Delta'}{P'}$ denotes
%	either a session transition or a $\beta$-transition.
%\end{definition}
%
%A transition $\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ is said
%{\em deterministic} if it is derived using~$\ltsrule{App}$ or~$\ltsrule{Tau}$ 
%(where $\subj{\ell_1}$ and $\subj{\ell_2}$ in the premise  are dual endpoints), 
%possibly followed by uses of  $\ltsrule{Alpha}$, $\ltsrule{Res}$, $\ltsrule{Rec}$, or $\ltsrule{Par${}_L$}/\ltsrule{Par${}_R$}$.

We have the following determinacy property:
%see  \appref{app:sub_tau_inert} 
%see~\cite{KouzapasPY15} for details. 


\begin{lemma}[$\tau$-Inertness~\cite{KouzapasPY17}]%\rm
	\label{lem:tau_inert}
		Suppose $\Gamma; \es; \Delta \proves P \hastype \Proc$ \newc{with balanced $\Delta$}.
	%(1)
	\begin{enumerate}[1)]
%		\item
%				Let $\horel{\Gamma}{\Delta}{P}{\hby{\dtau}}{\Delta'}{P'}$ be a deterministic transition,
%				with balanced $\Delta$. Then 
%				$\Gamma; \Delta \proves P \cong \Delta'\proves P'$ 
%				with $\Delta \red^\ast \Delta'$ balanced.
		\item	If	$\horel{\Gamma}{\Delta}{P}{\hby{\dtau}}{\Delta'}{P'}$ then
				$\horel{\Gamma}{\Delta}{P}{\hwb}{\Delta'}{P'}$, with $\Delta \red^\ast \Delta'$. 
%		\item 
%				%(2) 
%				Let $P$ be an $\HOp^{-\mathsf{sh}}$ process. 
%				Assume $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$. Then 
%				$P \red^\ast P'$ implies $\Gamma; \Delta \proves 
%				P \cong \Delta'\proves P'$ with $\Delta \red^\ast \Delta'$. 
		\item 
				%(2) 
				If $P$ is an $\HOp^{-\mathsf{sh}}$ process, and 
%				Assume $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$. Then 
				$P \red^\ast P'$ then 
				$\Gamma; \Delta \proves P \cong \Delta'\proves P'$, with $\Delta \red^\ast \Delta'$. 
	\end{enumerate}
\end{lemma}


%\begin{proof}[Sketch]
%	The proof uses the fact that processes of the
%	form $$\Gamma; \es; \Delta \proves_s \bout{s}{V} P_1 \Par \binp{k}{x} P_2$$
%	cannot have any typed transition observables and the fact
%	that bisimulation is a congruence.
%	See  \appref{app:sub_tau_inert} for details.
%	The proof for Part 2 follows from Part 1.
%	\qed
%\end{proof}

\newj{We use 
\lemref{lem:tau_inert}
to prove \thmref{t:negative}, the negative result stated in
\secref{ss:negative}.
This property also enables us to define the following up-to technique, useful in full abstraction proofs.
We write $\Hby{\dtau}$ to denote a (possibly empty) sequence of deterministic steps 
$\hby{\dtau}$.}
We can finally state:

\begin{lemma}[Up-to Deterministic Transition~\cite{KouzapasPY17}]%\myrm
	\label{lem:up_to_deterministic_transition}
	Let $\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{Q_1}$ such
	that if whenever:
%
	\begin{enumerate}[1.]
		\item	$\forall \news{\tilde{m_1}} \bactout{n}{V_1}$ such that
			$
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}} \bactout{n}{V_1}}}{\Delta_3}{P_3}
			$
			implies that $\exists Q_2, V_2$ such that
			$
				\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}
			$
			and
			$
				\horel{\Gamma}{\Delta_3}{P_3}{\Hby{\dtau}}{\Delta_1'}{P_2}
			$
			and for fresh $t$:\\
			$
				\horel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \htrigger{t}{V_1}}}
				{\ \Re\ }
				{\Delta_2''}{}{\newsp{\tilde{m_2}}{Q_2 \Par \htrigger{t}{V_2}}}
%				\mhorel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par \hotrigger{t}{x}{s}{V_1}}}
%				{\ \Re\ }
%				{\Delta_2''}{}{\newsp{\tilde{m_2}}{Q_2 \Par \hotrigger{t}{x}{s}{V_2}}}
			$.
%
		\item	$\forall \ell \not= \news{\tilde{m}} \bactout{n}{V}$ such that
			$
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_3}{P_3}
			$
			implies that $\exists Q_2$  \\ such that 
			$
				\horel{\Gamma}{\Delta_1}{Q_1}{\hat{\Hby{\ell}}}{\Delta_2'}{Q_2}
			$
			and
			$
				\horel{\Gamma}{\Delta_3}{P_3}{\Hby{\dtau}}{\Delta_1'}{P_2}
			$
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re\ }{\Delta_2'}{Q_2}$.

		\item	The symmetric cases of 1 and 2.
	\end{enumerate}
	Then $\Re\ \subseteq\ \hwb$.
\end{lemma}


%\begin{proof}
%	The proof is easy by considering the closure
%	\[
%		\Re^{\Hby{\dtau}} = \set{ \horel{\Gamma}{\Delta_1'}{P_2}{,}{\Delta_2'}{Q_1} \setbar \horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2'}{Q_1},
%		\horel{\Gamma}{\Delta_1}{P_1}{\Hby{\dtau}}{\Delta_1'}{P_2} }
%	\]
%	We verify that $\Re^{\Hby{\dtau}}$ is a bisimulation with
%	the use of \propref{lem:tau_inert}.
%	\qed
%\end{proof}

%\begin{example}[Up-to Deterministic Transition]
%	Typed processes:
%	\begin{eqnarray*}
%		\Gamma; \es; \Delta, s': \tinact \proves P &=& \binp{n}{z_1} \newsp{s}{\binp{s}{x} \appl{(\abs{y}{\bout{n}{z_1} \inact})}{m} \Par \bout{\dual{s}}{s'} \inact} \hastype \Proc
%		\\
%		\Gamma; \es; \Delta \proves Q &=& \binp{n}{z_1} \binp{n}{z_2} \inact \hastype \Proc
%	\end{eqnarray*}
%	are bisimilar up-to deterministic transition because
%	we can observe:
%	\begin{eqnarray*}
%		\Gamma; \Delta, s': \tinact \proves P &\hby{\bactinp{n}{m_1}}& \Delta', s: \tinact \proves \newsp{s}{\binp{s}{x} \appl{(\abs{y}{\bout{n}{z_2} \inact})}{m} \Par \bout{\dual{s}}{s'} \inact} \Hby{\dtau} \Delta' \proves \binp{n}{z_2} \inact
%		\\
%		\text{and}
%		\\
%		\Gamma; \es; \Delta \proves Q &\hby{\bactinp{n}{m_1}}& \Delta' \proves \binp{n}{z_2} \inact
%	\end{eqnarray*}
%
%
%	Relation 
%	\[
%		\Re = \set{(\Gamma; \Delta, s': \tinact \proves P , \Delta \proves Q), (\Gamma; \Delta' \proves \binp{n}{z_2}, \Delta' \proves  \binp{n}{z_2})}
%	\]
%	is bisimulation up-to deterministic transition because
%	\begin{eqnarray*}
%		\Gamma; \Delta, s': \tinact \proves P &\hby{\bactinp{n}{s_1}}& \Delta', s: \tinact \proves \newsp{s}{\binp{s}{x} \appl{(\abs{y}{\bout{n}{y} \inact})}{s_1} \Par \bout{\dual{s}}{s'} \inact}
%		\\
%		\text{implies}&
%		\\
%		\Gamma; \es; \Delta \proves Q &\hby{\bactinp{n}{x}}& \Delta' \proves \binp{n}{z_2} \inact
%		\\
%		\text{and}&
%		\\
%		\Delta', s: \tinact \proves \newsp{s}{\binp{s}{x} \appl{(\abs{y}{\bout{n}{y} \inact})}{s_1} \Par \bout{\dual{s}}{s'} \inact}  \in \Re
%	\end{eqnarray*}
%\end{example}
%
%\noi Precise encodings offer more detailed criteria and used for positive 
%encodability results (\secref{sec:positive}).
%In contrast, minimal encodings contains only 
%some of the criteria of precise encodings:    
%this reduced notion will be used 
%for the negative result in \secref{sec:negative}.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Example (Tentative)}
We recall the case study that we gave in our previous paper.

The scenario involves a $\Client$ process that wants to book
a hotel room. % for her holidays. % in a remote island
%The Client 
$\Client$
narrows the choice down to two hotels, and requires 
 a quote from the two in order to
decide. The round-trip time (RTT) required for
taking quotes from the two hotels in not optimal, % (cf.~\cite{MostrousY15}),
so the client sends mobile processes to both hotels
to automatically negotiate and book a room. 

We now present two \HOp implementations of this scenario.
For convenience, we write $\If e\ \Then (P_1\ \Else \ P_2)$ 
to denote a conditional process that executes $P_1$ or $P_2$ depending on boolean expression $e$ (encodable using labelled choice).
The \emph{first implementation} is  as follows:
%
%\[
	\begin{eqnarray*}%{rcl}
		 \Client_1   & \defeq  &  \newsp{h_1, h_2}{\bout{s_1}{\abs{x}{P_{xy} \subst{h_1}{y}}} \bout{s_2}{\abs{x}{P_{xy} \subst{h_2}{y}}} \inact \Par  \\
		& & 
		\qquad \qquad\binp{\dual{h_1}}{x} \binp{\dual{h_2}}{y}  \If x \leq y\   \Then\\
		& & \qquad\qquad \qquad \qquad (\bsel{\dual{h_1}}{\accept} \bsel{\dual{h_2}}{\reject} \inact \ \Else \ \bsel{\dual{h_1}}{\reject} \bsel{\dual{h_2}}{\accept} \inact )
		}
		\\
				 P_{xy}    & \defeq &    \bout{x}{\rtype} \binp{x}{\Quote} \bout{y}{\Quote}
		y \triangleright \left\{
				\begin{array}{l}
					\accept: \bsel{x}{\accept} \bout{x}{\creditc} \inact~,\\
					\reject: \bsel{x}{\reject} \inact
				\end{array}
				\right\}
	\end{eqnarray*}
%\]
%
Process $\Client_1$ sends two abstractions with body $P_{xy}$, one to each hotel, 
		using sessions $s_1$ and $s_2$.
		That is, $P_{xy}$ is the mobile code with free names $x, y$:
	while
		name $x$ is meant to be instantiated by the hotel as the negotiating
		endpoint, name $y$ is used to interact with $\Client_1$.	
		Intuitively, process $P_{xy}$:
		\begin{enumerate}[(i)]
		 \item sends the room requirements to the hotel;
		\item  receives a quote from the hotel;
		\item  sends the quote to  $\Client_1$;
		\item expects a choice from   $\Client_1$ whether to accept or reject the offer;
		\item if the choice is $\accept$ then it informs the hotel and performs the booking;
		otherwise, if the choice is $\reject$ then it informs the hotel and ends the session.
		\end{enumerate}
				$\Client_1$ instantiates two copies of  $P_{xy}$ as abstractions
		on session $x$. It uses two
		fresh endpoints $h_1, h_2$ to substitute channel $y$
		in $P_{xy}$. This enables communication with the mobile code(s).
		In fact, 
		$\Client_1$ uses the dual endpoints $\dual{h_1}$ and $\dual{h_2}$
		to receive the negotiation
		result from the two remote instances of $P$ and then inform the two
		processes for the final booking decision.
%Notice that	the above implementation does not affect the time needed for the whole protocol to execute, since the two remote processes are used to send/receive data to $\Client_1$.

We present now a \emph{second  implementation}
%of the same scenario, 
in which the two mobile processes reach an agreement
by interacting with each other (rather than with the client):
%
\[
	\begin{array}{rcl}
		\Client_2 &\defeq& \newsp{h}{\bout{s_1}{\abs{x}{Q_1 \subst{h}{y}}} \bout{s_2}{\abs{x}{Q_2 \subst{\dual{h}}{y}}} \inact}
\\
		Q_1 &\defeq&	\bout{x}{\rtype} \binp{x}{\Quote_1} \bout{y}{\Quote_1} \binp{y}{\Quote_2} R_x \\
		Q_2 &\defeq&	\bout{x}{\rtype} \binp{x}{\Quote_1} \binp{y}{\Quote_2} \bout{y}{\Quote_1} R_x \\
			    R_x & \defeq & \If\ \Quote_1 \leq \Quote_2 \, \Then  (\bsel{x}{\accept} \bout{x}{\creditc} \inact \  \Else \ \bsel{x}{\reject} \inact)
	\end{array}
\]
%\end{example}
Processes $Q_1$ and $Q_2$  negotiate a quote from the
		hotel in the same fashion as process $P_{xy}$ in $\Client_1$.
		The key difference with respect to $P_{xy}$ is that $y$ is used for
		interaction between process $Q_1$ and $Q_2$. Both processes send
		their quotes to each other and then internally follow the same
		logic to reach to a decision.
		Process  $\Client_2$ then uses sessions $s_1$ and $s_2$ to send the two
		instances of $Q_1$ and $Q_2$ to the two hotels, using them 
	 as abstractions
		on name $x$. It further substitutes
		the two endpoints of a fresh channel $h$ to channels $y$ respectively,
		in order for the two instances to communicate with each other.




\begin{figure}
\input{./figures/hoteldiag}
\caption{Sequence diagrams for $\Client_1$ and $\Client_2$\label{fig:exam}.}
\end{figure}

 
The different protocols implemented by $\Client_1$ and $\Client_2$ can be represented by the sequence diagrams of \figref{fig:exam}. 


\begin{example}[The Hotel Booking Example, Revisited]\label{exam:type}
We give types to the client
processes. % of~\secref{exam:proc}.
Assume 
\begin{eqnarray*}
S & = & \btout{\Quote} \btbra{\accept: \tinact, \reject: \tinact} \\
U & = & \btout{\rtype} \btinp{\Quote} \btsel{\accept: \btout{\creditc} \tinact, \reject: \tinact }
\end{eqnarray*}
While the typing for $\abs{x}{P_{xy}}$ is $\es; \es; y: S \proves \abs{x}{P_{xy}} \hastype \lhot{U}$,
the typing for $\Client_1$ is
$~~
	\es; \es; s_1: \btout{\lhot{U}} \tinact \cat s_2: \btout{\lhot{U}} \tinact \proves \Client_1 \hastype \Proc
$.


The typings for $Q_1$ and $Q_2$ are
$	\es; \es; y: \btout{\Quote} \btinp{\Quote} \tinact \proves \abs{x}{Q_i} \hastype \lhot{U}
$ ($i=1,2$)
and the type for $\Client_2$ is
$~~
	\es; \es; s_1: \btout{\lhot{U}} \tinact \cat s_2: \btout{\lhot{U}} \tinact \proves \Client_2 \hastype \Proc
$.
\end{example}


\begin{proposition}\label{p:examp}
	Let
	$S = \btout{\rtype} \btinp{\Quote} \btsel{\accept: \btout{\creditc} \tinact, \reject: \tinact}$
	and
	$\Delta = s_1: \btout{\lhot{S}} \tinact \cat s_2: \btout{\lhot{S}} \tinact$.
%	\begin{eqnarray*}
%		S &=& \btout{\rtype} \btinp{\Quote} \btsel{\accept: \btout{\creditc} \tinact, \reject: \tinact}\\
%		\Delta &=& s_1: \btout{\lhot{S}} \tinact \cat s_2: \btout{\lhot{S}} \tinact
%	\end{eqnarray*}
	Then
	$\horel{\es}{\Delta}{\Client_1}
	{\fwb}
	{\Delta}{\Client_2}$, where $\Client_1$ and $\Client_2$ are as above.
	%in \secref{exam:proc}. 
\end{proposition}

\section{Correctness Criteria for Typed Encodings}
\label{s:expr}
%\input{encoding}
We define the formal notion of \emph{encoding} by 
extending to a typed setting existing criteria for untyped processes, as put forward in, e.g.,
\cite{Nestmann00,Palamidessi03,DBLP:conf/lics/PalamidessiSVV06,DBLP:journals/iandc/Gorla10,DBLP:conf/icalp/LanesePSS10,DBLP:journals/tcs/FuL10,DBLP:journals/corr/abs-1208-2750,DBLP:conf/esop/PetersNG13}. 
We first define a typed calculus parametrised by a syntax, an operational semantics, and a type system.
Based on this definition, in  
\secref{sec:positive} and \secref{sec:extension}
we define concrete instances of (higher-order) typed calculi.

%\smallskip 

\begin{definition}[Typed Calculus]\label{d:tcalculus}%\rm
	A \emph{typed calculus} $\tyl{L}$ is a tuple
	$\calc{\CAL}{\cal{T}}{\hby{~}}{\wb}{\proves}$
	where $\CAL$ and $\cal{T}$ are sets of processes and types, 
	respectively; also, $\hby{}$, $\wb$, and $\proves$ 
	denote a transition system (over an underlying set of actions, denoted $\cal{A}$), a typed equivalence,
	and a typing system for $\CAL$, respectively. 
\end{definition}

%\smallskip 
%
%\begin{definition}[Typed Calculus]\label{d:tcalculus}\rm
%A \emph{typed calculus} $\tyl{L}$ is a tuple
%          $\calc{\CAL}{\cal{T}}{\cal{A}}{\wb}{\proves}$
%	where $\CAL$,  $\cal{T}$, $\cal{A}$ are sets of processes, types, and action labels (of an underlying transition system),
%respectively; and $\wb$ and $\proves$ 
%	denote %a transition system (with set of labels $\mathcal{A}$), 
%	a typed equivalence and type system for~$\CAL$. 
%\end{definition}
%
%
%\smallskip 
%
%\begin{definition}[Typed Calculus]\label{d:tcalculus}\rm
%A \emph{typed calculus} $\tyl{L}$ is a tuple
%          $\calc{\CAL}{\cal{T}}{\hby{\ell}}{\wb}{\proves}$
%	where $\CAL$ and $\cal{T}$ are sets of processes and types, 
%respectively; and $\hby{\mathcal{A}}$, $\wb$, and $\proves$ 
%	denote a transition system (with set of labels $\mathcal{A}$), 
%	a typed equivalence, and type system for $\CAL$, resp. 
%	We write $\mathcal{A}$ is t`he set of labels used in relation $\hby{\ell}$.
%\end{definition}

%\smallskip 
%\noi 

Most elements of the formal notion of typed calculus are self-explanatory. 
Concerning the operational semantics, we shall assume a notion of transition system in which transitions are labelled with 
elements from a finite set of actions $\cal{A}$, which contains at least the unobservable action $\tau$. 
We will often be interested in $\tau$-transitions, denoted $\hby{\tau}$, which characterise reductions. 
Nevertheless, to state more precise forms of operational correspondence, we 
will sometimes find it convenient to use transitions of 
the form $\hby{\ell}$,
where $\ell \in \cal{A}$ and $\ell \neq \tau$ (i.e., visible transitions). 

Our notion of encoding considers mappings on both processes 
and types; these are denoted $\map{\cdot}$ and $\mapt{\cdot}$, respectively: %, and transition labels: 

\begin{definition}[Typed Encoding]%\rm
\label{def:tenc}
        Consider two typed calculi
        $\tyl{L}_1=\!\calc{\CAL_1}{{\cal{T}}_1}{\hby{~}_1}{\wb_1}{\proves_1}$
        and
        $\tyl{L}_2=\calc{\CAL_2}{{\cal{T}}_2}{\hby{~}_2}{\wb_2}{\proves_2}$.
        %Let $\mathcal{A}_{i}$ be the set of labels in $\hby{\ell}_i$ ($i=1,2$).
	Given mappings $\map{\cdot}: \CAL_1 \to \CAL_2$ and
	$\mapt{\cdot}: {\cal{T}}_1 \to {\cal{T}}_2$, 
%	and $\mapa{\cdot}: \mathcal{A}_1 \to \mathcal{A}_2$, 
	we write 
%	$\enco{\map{\cdot}, \mapt{\cdot}, \mapa{\cdot}} : 
		$\enco{\map{\cdot}, \mapt{\cdot}} : 
	\tyl{L}_1 \to \tyl{L}_2$ to denote the \emph{typed encoding} of $\tyl{L}_1$ (the \emph{source calculus}) into $\tyl{L}_2$ (the \emph{target  calculus}).
\end{definition}

%\smallskip 

%\noi 
Mapping $\mapt{\cdot}$ extends to typing
environments in the expected way; for instance, $\mapt{\Delta \cat u:S} = \mapt{\Delta} \cat u:\mapt{S}$.
When considering forms of operational correspondence with visible actions, 
our notion of typed encoding shall include mappings $\map{\cdot}$ and $\mapt{\cdot}$, but also
a  mapping  $\mapa{\cdot}:\mathcal{A}_1 \to \mathcal{A}_2$ 
describing how visible actions in the source calculus $\tyl{L}_1$ are mapped in the target typed calculus $\tyl{L}_2$.


We now introduce syntactic criteria for typed encodings.
Let $\sigma$ denote a substitution of names for names (a renaming, as usual). Given environments $\Delta$ and $\Gamma$,
we write $\sigma(\Delta)$ and $\sigma(\Gamma)$ to denote the effect of applying $\sigma$ on the 
domains of $\Delta$ and $\Gamma$.
In the case of \HOp and its variants,  $\sigma(\Gamma)$ clearly concerns only shared names in $\Gamma$: process and recursive variables in $\Gamma$ are not affected by $\sigma$. 

%\smallskip 

\begin{definition}[Syntax Preservation]%\rm
	\label{def:sep}
	We say that the
	typed encoding 
	$\enco{\map{\cdot}, \mapt{\cdot}}: \tyl{L}_1 \to \tyl{L}_2$ is \emph{syntax preserving}
	if it is:
	
	\begin{enumerate}[1.]
		\item	\emph{Homomorphic wrt parallel},   if 
		$\mapt{\Gamma}; \emptyset; \mapt{\Delta_1 \cat \Delta_2} \proves_2 \map{P_1 \Par P_2} \hastype \Proc$ \\
		then 
		$\mapt{\Gamma}; \emptyset; \mapt{\Delta_1} \cat \mapt{\Delta_2} \proves_2 \map{P_1} \Par \map{P_2} \hastype \Proc$.

		\item	\emph{Compositional wrt restriction},  if 
		$\mapt{\Gamma}; \emptyset; \mapt{\Delta} \proves_2 \map{\news{n}P} \hastype \Proc$ \\
		then 
		$\mapt{\Gamma}; \emptyset; \mapt{\Delta} \proves_2 \news{n}\map{P} \hastype \Proc$.
		
		\item \emph{Name invariant},   if
		$\mapt{\sigma(\Gamma)}; \emptyset; \mapt{\sigma(\Delta)} \proves_2 \map{\sigma(P)} \hastype \Proc$
		then \\
		$\sigma(\mapt{\Gamma}); \emptyset; \sigma(\mapt{\Delta}) \proves_2 \sigma(\map{P}) \hastype \Proc$, 
		for any injective renaming  of names $\sigma$.
	\end{enumerate}
\end{definition}

%\smallskip 

%\noi 
Homomorphism wrt parallel (used in, e.g.,~\cite{Palamidessi03,DBLP:conf/lics/PalamidessiSVV06})
expresses that encodings should preserve the distributed topology of source processes. This criterion
 is appropriate for both encodability and non encodability results; in our setting, it is
%it admits an elegant formulation, also 
induced by the typing rules for parallel composition.
Compositionality wrt restriction 
is also supported by typing and is 
useful in our encodability results~(\secref{sec:positive}).
The name invariance criterion follows \cite{DBLP:journals/iandc/Gorla10,DBLP:conf/icalp/LanesePSS10}. 

\newj{We now state \emph{type preservation}, a static criterion on the mapping 
$\mapt{\cdot}: {\cal{T}}_1 \to {\cal{T}}_2$: % of our typed encodings. 
it ensures that 
%Type preservation enables us to focus on 
%mappings $\mapt{\cdot}$ that 
a typed operator is 
always translated into itself. 
The source and target calculi that we consider here share
five (session) type operators: input, output, recursion (binary operators); selection and 
branching ($n$-ary operators). 
As such, type preservation is key to retain the meaning of structured protocols:
as session types operators abstract communication behaviour,
type preserving encodings help us maintain behaviour %in maintaining behaviour%those abstractions
across translations.}

\begin{definition}[Type Preservation]
	\label{def:tp}
	The typed encoding 
	$\enco{\map{\cdot}, \mapt{\cdot}}: \tyl{L}_1 \to \tyl{L}_2$ is \emph{type preserving}
	if for every $k$-ary type operator $\mathtt{op}$ in ${\cal{T}}_1$ it holds that 
	 $$\mapt{\mathtt{op}(T_1, \cdots, T_k)} = \mathtt{op}(\mapt{T_1}, \cdots, \mapt{T_k})$$
	\end{definition}


\begin{example}
\newj{
Following the discussion in \secref{sec:overview}, let 
$\mapt{\cdot}_u$ 
be a mapping on session types 
such that 
\begin{align*}
\mapt{\btout{U} S}_u  = & \btinp{\mapt{U}_u} \mapt{S}_u
\\
\mapt{\btinp{U} S}_u   = &\btout{\mapt{U}_u} \mapt{S}_u 
\end{align*}
and other type operators are translated homomorphically.
Since 
$\mapt{\cdot}_u$  translates the output type operator into an input type operator (and viceversa), 
%exchanges (inverts) input and output session type operators. % in \defref{def:tp}.
we conclude that $\mapt{\cdot}_u$ does not satisfy  type preservation. 
}
\end{example}

Next we define semantic criteria for typed encodings:

%\smallskip 

\begin{definition}[Semantic Preservation]%\rm
\label{def:ep}
       Consider typed calculi %$\tyl{L}_1$ and  $\tyl{L}_2$, defined as 
        $\tyl{L}_1=\calc{\CAL_1}{{\cal{T}}_1}{\hby{~}_1}{\wb_1}{\proves_1}$
       and $\tyl{L}_2=\calc{\CAL_2}{{\cal{T}}_2}{\hby{~}_2}{\wb_2}{\proves_2}$.
%       ($i=1,2$) be typed calculi. 
We say that the typed encoding $\enco{\map{\cdot}, \mapt{\cdot}}: \tyl{L}_1 \to \tyl{L}_2$ is \emph{semantic preserving}
if it satisfies the properties below.
%Given a label $\ell \neq \tau$, we write 
%$\mathsf{sub}(\ell)$
%to denote the \emph{subject} of the action.
	
	\begin{enumerate}[1.]
		\item \emph{Type Soundness}:
	if
	$\Gamma; \emptyset; \Delta \proves_1 P \hastype \Proc$ then 
	$\mapt{\Gamma}; \emptyset; \mapt{\Delta} \proves_2 \map{P} \hastype \Proc$.
%	for any   $P$ in $\CAL_1$.
			%\item \emph{Subject preserving}: if $\subj{\ell} = u$ then $\subj{\mapa{\ell}} =u$.

			\item \emph{Barb Preserving}: if $\Gamma; \Delta \proves_1 P \barb{n}$
		then $\mapt{\Gamma}; \mapt{\Delta} \proves_2 \map{P} \Barb{n}$.

	\item \emph{Operational Correspondence}: If $\Gamma; \emptyset; \Delta \proves_1 P \hastype \Proc$ then
		\begin{enumerate}
			\item	\NY{Completeness: 
			   If  
$\stytraargi{\Gamma}{\tau}{\Delta}{P}{\Delta'}{P'}{1}{1}$
			   then  $\exists Q, \Delta''$ s.t. \\
 (i)~$\wtytraargi{\mapt{\Gamma}}{}{\mapt{\Delta}}{\map{P}}{\mapt{\Delta''}}{Q}{2}{2}$
			    %(ii)~$\ell_2 = \mapa{\ell_1}$, 
			    and 
				(ii)~${\mapt{\Gamma}};{\mapt{\Delta'}}\proves_2 {P'}{\,\wb_2\,}
{\mapt{\Delta''}}\proves_2 {\map{Q}}$.}
				
			\item	Soundness:   
				If  $\wtytraargi{\mapt{\Gamma}}{}{\mapt{\Delta}}{\map{P}}{\mapt{\Delta'}}{Q}{2}{2}$
				then  $\exists P', \Delta''$ s.t.  \\
				(i)~$\stytraargi{\Gamma}{\tau}{\Delta}{P}{\Delta''}{P'}{1}{1}$
				%(ii)~$\ell_2 = \mapa{\ell_1}$, 
				and 
				(ii)~
${\mapt{\Gamma}};{\mapt{\Delta''}}\proves_2 {\map{P'}}{\,\wb_2\,}
{\mapt{\Delta'}}\proves_2 {Q}$.

		\end{enumerate}
		
		\item \emph{Full Abstraction:} 
		\wbbarg{\Gamma}{}{\Delta}{P}{\Delta'}{Q}{1}
		if and only if 
		\wbbarg{\mapt{\Gamma}}{}{\mapt{\Delta}}{\map{P}}{\mapt{\Delta'}}{\map{Q}}{2}.
		
	\end{enumerate}
\end{definition}

%\smallskip 

%\noi 
Together with type preservation (\defref{def:tp}), type soundness is a distinguishing encodability criterion.
% it enables us to focus on encodings which retain the communication structures denoted by session types.
%The other semantic
%criteria build upon analogous definitions in the untyped setting, as we explain now. 
\newj{Barb preservation, related to success sensitiveness 
%(as defined in~\cite{DBLP:journals/iandc/Gorla10}), 
in~\cite{DBLP:journals/iandc/Gorla10}, is convenient in our developments as all considered calculi have the same notion of barb.}
Operational correspondence, standardly divided into completeness and soundness, is also based
%in the formulation given i
on~\cite{DBLP:journals/iandc/Gorla10};
it relies on 
%the typed LTS of \defref{def:rlts}, 
%labelled transitions rather than on 
$\tau$-transitions (reductions).
Completeness ensures that a step of the source process is mimicked
by a step of its associated encoding; soundness is its converse.
%Soundness ensures that the source process is mimicked 
%by its associated encoding; completeness is its converse.
%Completeness and soundness rely on 
%the typed LTS of \defref{def:rlts}, 
%rather than on reductions;
%Labels are considered up to  mapping $\mapa{\cdot}$, which offers flexibility when comparing different calculi. We require that $\mapa{\cdot}$ preserves  subjects, in accordance with the criteria in~\cite{DBLP:conf/icalp/LanesePSS10}.
{Above, operational correspondence is stated in generic terms.}
It is worth stressing that 
the operational correspondence statements 
%given in \secref{sec:positive} 
for our encodings 
 are tailored to the specifics of each encoding, and so they
 are actually stronger than the criteria given above
 {(see \propsref{prop:op_corr_HOp_to_HO}, \ref{prop:op_corr_HOp_to_p}, \ref{prop:op_corr_HOpp_to_HOp}, \ref{prop:op_corr_pHOp_to_HOp}
 and~\cite{KouzapasPY15} for details).}
 In particular, in some cases we will consider forms of operational correspondence based on visible actions, relying on 
 mapping $\mapa{\cdot}$ as already explained.
Finally, following~\cite{SangiorgiD:expmpa,DBLP:conf/lics/PalamidessiSVV06,Yoshida96},
we consider full abstraction as an encodability criterion: this leads to 
stronger encodability results. 
%The completeness direction of full abstraction is dropped when we prove the negative result. 
%From the criteria in \defref{def:sep} and~\ref{def:ep}
%we have the following derived criterion: 

%\begin{proposition}[Barb Preservation]
%\label{p:barbpres}
%Let
%	$\enco{\map{\cdot}, \mapt{\cdot}, \mapa{\cdot}}: \tyl{L}_1 \to \tyl{L}_2$
%	be a typed encoding.
%	Suppose the encoding is both
% operationally complete (cf.~\defref{def:ep}-3(a)) 
% and subject preserving (cf.~\defref{def:ep}-2).
% Then, it is also \emph{barb preserving}, i.e., 
%$\Gamma; \Delta \proves_1 P \barb{n}$
%implies
%$\mapt{\Gamma}; \mapt{\Delta} \proves_2 \map{P} \Barb{n}$.
%\end{proposition}
%
%%\smallskip 
%
%\begin{proof}
%The proof
%follows from the definition of barbs, operational completeness, and subject preservation.
%\qed
%\end{proof}

We may now introduce 
\emph{precise} and \emph{minimal}
 encodings.
While we state strong positive encodability results % in \secref{sec:positive}, 
in terms of {\em precise} encodings,
to prove the non-encodability result in \secref{ss:negative}, 
we appeal to the weaker {\em minimal} encodings.  
%Building upon precise encodings in \defref{def:lopco} we define \emph{tight} encodings.

\begin{definition}[Typed Encodings: Precise and Minimal]%\rm
\label{def:goodenc}
We say that 
	the typed encoding 
	$\enco{\map{\cdot}, \mapt{\cdot} %, \mapa{\cdot}
	}: \tyl{L}_1 \to \tyl{L}_2$ is 
	%\begin{enumerate}[$\bullet$]
	%\item 
	\emph{precise}, if it is syntax, type, and semantic preserving (\defsref{def:sep}, \ref{def:tp}, \ref{def:ep}).
	%\item 
	We say that the encoding is
	\emph{minimal}, if it is syntax preserving 
	(\defref{def:sep}),
	barb preserving (\defref{def:ep}-2), 
	and operationally complete (\defref{def:ep}-3(a)).
%	\end{enumerate}
\end{definition}

%\smallskip 

%\noi %As explained earlier, o
%Our encodability results %presented next 
%rely on precise encodings; 
%our non encodability result %, presented in \secref{sec:negative}, 
%uses minimal encodings.
%Further we have:

%\smallskip 

The following property will come in handy in \secref{sec:extension}:

\begin{proposition}%[Composability of Precise Encodings]%\rm
	\label{pro:composition}
	Let %encodings 
	$\enco{\map{\cdot}^{1}, \mapt{\cdot}^{1}%, \mapa{\cdot}^{1}
	}: \tyl{L}_1 \to \tyl{L}_2$
	and 
	$\enco{\map{\cdot}^{2}, \mapt{\cdot}^{2}%, \mapa{\cdot}^{2}
	}: \tyl{L}_2 \to \tyl{L}_3$
	be two precise %typed 
	encodings.
	Then their composition, denoted 
	$\enco{\map{\cdot}^{2} \circ \map{\cdot}^{1}, \mapt{\cdot}^{2} \circ \mapt{\cdot}^{1} %, \mapa{\cdot}^{2}\circ \mapa{\cdot}^{1}
	}: \tyl{L}_1 \to \tyl{L}_3$,
	is precise. 
\end{proposition}

\begin{proof}
This follows directly from the definitions.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Expressiveness Results for \HOp, \HO, and \sessp}
\label{sec:positive}
%\input{positive}
 We first present two %encodability results:
 precise encodings: 
(1)~higher-order communication with recursion and name-passing   (\HOp) into 
higher-order communication without name-passing nor recursion (\HO) (\secref{subsec:HOpi_to_HO}); and 
(2)~\HOp into the first-order calculus with name-passing  
with recursion (\sessp) (\secref{subsec:HOp_to_sessp}).
We then compare these  encodings (\secref{ss:compare}). 
Moreover, in \secref{ss:negative} we state our impossibility result for shared/linear names.
We consider the typed calculi (cf.~\defref{d:tcalculus}):
%\begin{enumerate}[-]
%	\item
%	$\tyl{L}_{\HOp}=\calc{\HOp}{{\cal{T}}_1}{\hby{\tau}}{\hwb}{\proves}$,
%	\item
%	$\tyl{L}_{\HO}=\calc{\HO}{{\cal{T}}_2}{\hby{\tau}}{\hwb}{\proves}$,
%	\item
%	$\tyl{L}_{\sessp}=\calc{\sessp}{{\cal{T}}_3}{\hby{\tau}}{\fwb}{\proves}$ 
%\end{enumerate}
\begin{align*}
	\tyl{L}_{\HOp} & =\calc{\HOp}{{\cal{T}}_1}{\hby{~}}{\hwb}{\proves}
	\\
	\tyl{L}_{\HO} & =\calc{\HO}{{\cal{T}}_2}{\hby{~}}{\hwb}{\proves}
	\\
	\tyl{L}_{\sessp} & =\calc{\sessp}{{\cal{T}}_3}{\hby{~}}{\fwb}{\proves}
\end{align*}
where: 
${\cal{T}}_1$, ${\cal{T}}_2$, 
and ${\cal{T}}_3$
are sets of types of $\HOp$, $\HO$, and $\sessp$, respectively. 
The typing $\proves$ is defined in 
%\figref{fig:typerulesmy}.
\secref{sec:types}.
The LTSs follow the intuitions given in \secref{ss:equiv}.
The set of actions $\mathcal{A}_{\HOp}$ is as in \defref{d:labels}; the sets of actions $\mathcal{A}_\HO$ and $\mathcal{A}_\sessp$ 
are obtained from $\mathcal{A}_{\HOp}$ 
as expected.
%are as in \defref{def:rlts}, 
Moreover, 
$\hwb$ is as in \defref{d:hbw}, and 
$\fwb$ is as in \defref{d:fwb}.

\begin{remark}[Type Annotations]\label{r:types}
In our encodings, we sometimes type-annotate
bound variables in order to distinguish first- and higher-order values and processes.
This way, e.g., 
we may write $\binp{u}{\AT{x}{C}} P$
and 
$\binp{u}{\AT{x}{L}} P$ to denote first- and higher-order input prefixed processes, respectively.
\end{remark}

\begin{comment}
\dk{
We further prove that the two encodings are precise.
An important issue to adress on the precissenes of
the encoding is that of type preservation. In the
context of types it is not enough to check that
the reduction semantics and the behavioural equivalences
correspond. Type preservation gives a corresponding result on the
type derivation of the encoded process, thus we can
see that the encoding is preserving a specific type
behaviour. For example consider the followin encoding
of first-order passing into higher-order passing:
\[
	\begin{array}{rcl}
		\map{\bout{n}{m} P} &=& \binp{n}{x} (\map{P} \Par \appl{x}{m})\\
		\map{\binp{n}{x} P} &=& \bout{n}{\abs{x} P} \inact
	\end{array}
\]
%
Using the above encoding we could simulate name passing, e.g:
\[
	\begin{array}{rcl}
		\bout{n}{m} P \Par \binp{\dual{n}}{x} Q &\red& P \Par Q \subst{m}{x}\\
		\map{\bout{n}{m} P \Par \binp{\dual{n}}{x} Q} &=&\\
		\binp{n}{x} (\map{P} \Par \appl{x}{m}) \Par \bout{\dual{n}}{\abs{x} \map{Q}} \inact &\red&
		\map{P} \Par \appl{\abs{x}{\map{Q}}}{m}\\
		&\red&
		\map{P} \Par \map{Q}\subst{m}{x}
	\end{array}
\]
The distinctive characteristic of this encoding is that
it encodes the output prefix into an input prefix, and the
input prefix into an output prefix which in turn has
an impact on the relation on the session type of the encoding.
The interaction structure of the session is not preserved by the
above encoding.
The mapping on types gives an insight on the behaviour of processes.
}
\end{comment}


\subsection{Precise Encoding of $\HOp$ into $\HO$}
\label{subsec:HOpi_to_HO}
$\HO$ is expressive enough to
precisely encode \HOp.
%the full \HOp-calculus.
As discussed above, the main challenges are to encode (1) name passing 
and (2) recursion, 
for which 
we only use  abstraction passing. 
 As explained in \secref{sec:overview}, for (1), we pass  
an % simple 
abstraction which enables to use the name upon application. 
For~(2), we 
copy a process upon reception; passing around linear abstractions
%presents a limitation 
is \NY{delicate} 
because 
they cannot be copied.
To handle linearity, we define the following auxiliary 
%a preliminary tool which is a mapping from
 mapping 
$\auxmapp{\cdot}{{}}{\sigma}$
from processes with free names to processes without free
names (but with free variables instead):
%from processes \jpc{with free names} to processes without free names (but with free variables) (\defref{d:auxmap}). 
%We require two auxiliary definitions.

%\smallskip 

%\begin{definition}\rm 
%%\label{def:hop_to_ho}
%	Let $\vmap{\cdot}: 2^{\mathcal{N}} \longrightarrow \mathcal{V}^\omega$
%	be a map of sequences of lexicographically ordered names to sequences of variables, defined
%	inductively as: 
%	$\vmap{\epsilon} = \epsilon$ and $\vmap{n \cat \tilde{m}} = x_n \cat \vmap{\tilde{m}}$. 
%\end{definition}
%
%\smallskip 

%\noi The following auxiliary mapping transforms processes
%with free names into abstractions and it is
%used in \defref{d:enc:hopitoho}.
%
%\smallskip 




\begin{definition}[Auxiliary Mapping] \label{d:trabs}\label{d:auxmap}
	Let $\vmap{\cdot}: 2^{\mathcal{N}} \longrightarrow \mathcal{V}^\omega$
	denote a map of sequences of lexicographically ordered names to sequences of variables, defined
	inductively 
	as: 
	\begin{align*}
	\vmap{\epsilon} & = \epsilon 
	\\
	\vmap{n \cat \tilde{m}} & = x_n \cat \vmap{\tilde{m}}
	\end{align*}
	Also, let $\sigma$ be a set of session names.
	Then, the auxiliary mapping
	$\auxmapp{\cdot}{{}}{\sigma}: \HO \to \HO$
	is as in \figref{f:auxmap}.
\end{definition}
\input{figures/aux_map}
%

\newj{Let $P$ be an \HOp process with $\fn{P} = \{n_1, \cdots, n_k\}$.
Intuitively, 
our encoding 
$\pmapp{\cdot}{1}{f}$ %: \HOp \to \HO$
%of \HOp into \HO %, givenin \figref{f:enc:hopi_to_ho}, 
%exploits 
% we are interested in 
%$P$ into \HO we 
exploits  
  the %\HO 
 abstraction
%defined as
$\abs{x_1,\cdots, x_k}{\auxmapp{\pmapp{P}{1}{f}}{{}}{\emptyset} }$, where $\vmap{n_j} = x_j$, for all $j \in \{1, \ldots, k\}$: }
%In the following we make this intuition precise.

%This transformation from processes into abstractions can be reverted by
%using abstraction and application with an appropriate sequence of session names:
%%
%\begin{proposition}\rm
%	Let $P$ be a \HOp process and 
%	suppose $\tilde{x} = \vmap{\tilde{n}}$ where 
%$\tilde{n} = \fn{P}$.
%	Then $P \scong \appl{(\abs{\tilde{x}}{\auxmapp{P}{{}}{\emptyset}})}{\tilde{n}}$.
%%	$\appl{X}{\smap{\fn{P}}} \subst{(\vmap{\fn{P}}) \map{P}^{\emptyset}}{X} \scong P$
%\end{proposition}



%\smallskip 

\begin{definition}[Typed Encoding of \HOp into \HO]
\label{d:enc:hopitoho}
Let $f$ be a map from process variables to sequences of name variables.
%
%Let $\tyl{L}_{\HOp}=\calc{\HOp}{{\cal{T}}_1}{\hby{\ell}}{\wb_H}{\proves}$
%and 
%$\tyl{L}_{\HO}=\calc{\HO}{{\cal{T}}_2}{\hby{\ell}}{\wb_H}{\proves}$. 
%where 
%${\cal{T}}_1$ and ${\cal{T}}_2$ are sets of types of $\HOp$ 
%and $\HO$, respectively, 
%the typing $\proves$ is defined in 
%\figref{fig:typerulesmy} 
%and $\hwb$ is defined in \defref{d:hbw}. 
The typed encoding 
$\enco{\map{\cdot}^{1}_f, \mapt{\cdot}^{1} %, \mapa{\cdot}^{1}
}: \tyl{L}_{\HOp} \to \tyl{L}_{\HO}$ is given in 
\figref{f:enc:hopi_to_ho}. 
Mapping $\mapt{\cdot}^{1}$ on types homomorphically extends to 
environments $\Delta$
and
$\Gamma$, with
$$
\tmap{\Gamma \cat \varp{X}:\Delta_1}{1}  =  \tmap{\Gamma}{1} \cat z_X:\shot{(S_1,\ldots,S_m,S^*)}
$$ 
%\[
%	\begin{array}{l}
%%	    \mapt{\Delta \cat s: S}^{1} & =  & \mapt{\Delta}^{1} \cat s:\mapt{S}^{1} & \\
%%		\mapt{\Gamma \cat u: \chtype{S}}^{1} & =  & \mapt{\Gamma}^{1} \cat u:\chtype{\mapt{S}^{1}} & \\
%%		\mapt{\Gamma \cat u: \chtype{L}}^{1} & = &  \mapt{\Gamma}^{1} \cat u:\chtype{\mapt{L}^{1}} & \\
%		\tmap{\Gamma \cat \varp{X}:\Delta}{1}  =  \tmap{\Gamma}{1} \cat z_X:\shot{(S_1,\ldots,S_m,S^*)} \ 
%	\end{array}
%\]
where  
$S^*$ is defined as $\trec{t}{\btinp{\shot{(S_1,\ldots,S_m,\vart{t})}} \tinact}$
provided that $\Delta_1 = \{n_i:S_i\}_{1\leq i\leq m}$.
%and $\Delta = \{n_1:S_1, \ldots, n_m:S_m\}$. 
\end{definition}

\input{figures/HOp_to_HO}

%\noi 
Note that $\Delta$ in $\varp{X}:\Delta$ is mapped to a non-tail
recursive session type with variable $z_X$. % (see \figref{f:enc:hopi_to_ho}).
Non-tail
recursive session types {were} studied in~\cite{DBLP:journals/corr/abs-1202-2086,TGC14};
{to our knowledge,}
this is the first application in the
context of higher-order session types.
%which carries type variable as the last argument.  
For convenience,  % of the presentation, %we use the polyadic name abstraction and passing.
we use polyadic name abstractions.
A precise encoding of polyadicity into \HO is given in~\secref{sec:extension}.

{Key elements in 
\figref{f:enc:hopi_to_ho} are encodings of 
{\em name passing} ($\pmapp{\bout{u}{w} P}{1}{f}$ and $\pmapp{\binp{u}{x} P}{1}{f}$)  and  
{\em recursion} ($\pmapp{\recp{X}{P}}{1}{f}$ and $\pmapp{\rvar{X}}{1}{f}$).
As motivated in \secref{sec:overview}, % we encode passing of name $w$  
a name $w$ is passed as an input-guarded abstraction;
on the receiver side,
the encoding %realises a mechanism that 
i) receives
the abstraction; ii) applies to it a fresh  endpoint $s$;
iii)~uses the dual endpoint $\dual{s}$ to send the continuation $P$ as an abstraction.
%$\abs{x}{P}$. 
Thus, name substitution is achieved via name application.
As for recursion, to encode $\recp{X}{P}$ we
first record a mapping from recursive variable $X$ to process variable $z_X$.
Then, using the auxiliary mapping
$\auxmapp{\cdot}{{}}{\sigma}$ in 
\defref{d:auxmap}, we encode the recursion body $P$ as a name abstraction
in which free names of $P$ are converted into name variables.
(Notice that $P$ is first encoded into \HO and then transformed using mapping
$\auxmapp{\cdot}{{}}{\sigma}$.)
Subsequently, this higher-order value is embedded in an input-guarded 
``duplicator'' process. We encode $X$ 
in such a way that it
simulates recursion unfolding by 
invoking the duplicator in a by-need fashion.
That is, upon reception, the \HO abstraction encoding  
%recursion body 
$P$
%containing $\auxmapp{P}{{}}{\sigma}$ 
is duplicated: 
one copy is used to reconstitute the original recursion body $P$ (through
the application of $\fn{P}$); another copy is used to re-invoke
the duplicator when needed. % to simulate recursion unfolding.
%An example of this typed encoding is detailed in~\cite{KouzapasPY15}.
We illustrate the encoding by means of an example.}
%\end{description}


 


%\input{encoding_example}
\begin{example}[The Encoding 
$\pmapp{\cdot}{1}{f}$ At Work]
Let $P = \recp{X}{\bout{a}{m} \varp{X}}$ be an \HOp process.
Its encoding into \HO is given next; notice that $f = \emptyset$ and $f' = \varp{X} \rightarrow x_ax_m$.
\begin{eqnarray*}
	\pmapp{P}{1}{f} &=&
	\newsp{s_1}{ \binp{s_1}{x} \pmapp{\bout{a}{m} \varp{X}}{1}{{f'}} \Par \bout{\dual{s_1}}{ \abs{(x_a, x_m, z)} \binp{z}{x} \auxmapp{\pmapp{\bout{a}{m} \varp{X}}{1}{{f'}}}{{}}{\es} } \inact} \\
%	&&\bout{\dual{s_1}}{ \abs{(x_a, x_m, z)} \binp{z}{x} \auxmapp{\pmapp{\bout{a}{m} \varp{X}}{1}{{\varp{X} \rightarrow x_ax_m}}}{{}}{\es} } \inact}
%\end{eqnarray*}
%\begin{eqnarray*}	
\pmapp{\bout{a}{m} \varp{X}}{1}{{ f'}} &=&
%	\bout{a}{\abs{z}{\binp{z}{x} (\appl{x}{m})}} \pmapp{\varp{X}}{1}{{f'}}
%	\\
%	&=& 
	\bout{a}{\abs{z}{\binp{z}{x} (\appl{x}{m})}} \newsp{s_2}{\appl{x}{(a,m, s_2)}  \Par \bout{\dual{s_2}}{\abs{(x_a, x_m, z)}{\appl{x}{(x_a, x_m, z)}}} \inact} \\
	\auxmapp{\pmapp{\bout{a}{m} \varp{X}}{1}{{f'}}}{{}}{\es}
	  & = & 
%	  \auxmapp{\bout{a}{\abs{z}{\binp{z}{x} (\appl{x}{m})}} \newsp{s_2}{\appl{x}{(a,m, s_2)}  \Par \bout{\dual{s_2}}{\abs{(x_a, x_m, z)}{\appl{x}{(x_a, x_m, z)}}} \inact}}{{}}{\es}
%	\\
%	 & = & 
%	 \bout{x_a}{\abs{z}{\binp{z}{x} (\appl{x}{x_m})}} \auxmapp{\newsp{s_2}{\appl{x}{(a,m, s_2)}  \Par \bout{\dual{s_2}}{\abs{(x_a, x_m, z)}{\appl{x}{(x_a, x_m, z)}}} \inact}}{{}}{\es}
%	\\
%	& = & 
	\bout{x_a}{\abs{z}{\binp{z}{x} (\appl{x}{x_m})}} \newsp{s_2}{\appl{x}{(x_a,x_m, s_2)}  \Par \\
	& & \qquad \qquad \qquad \qquad \qquad \qquad \qquad \bout{\dual{s_2}}{\abs{(x_a, x_m, z)}{\appl{x}{(x_a, x_m, z)}}} \inact}
\end{eqnarray*}
That is, by writing $V$ to denote the process
$$
\abs{(x_a, x_m, z)} \binp{z}{x} \bout{x_a}{\abs{z}{\binp{z}{x} (\appl{x}{x_m})}} \newsp{s_2}{\appl{x}{(x_a,x_m, s_2)}  \!\Par\! \bout{\dual{s_2}}{\abs{(x_a, x_m, z)}{\appl{x}{(x_a, x_m, z)}}} \inact}
$$
we would have %that $P = \recp{X}{\bout{a}{m} \varp{X}}$ is mapped into the \HO process
\begin{align*}
\pmapp{P}{1}{f} & =  \newsp{s_1}{\binp{s_1}{x}  \bout{a}{\abs{z}{\binp{z}{x} (\appl{x}{m})}} \newsp{s_2}{\appl{x}{(a,m, s_2)}  \Par \\
 & \qquad \qquad \qquad \bout{\dual{s_2}}{\abs{(x_a, x_m, z)}{\appl{x}{(x_a, x_m, z)}}} \inact}\Par \bout{\dual{s_1}}{V} \inact}
\end{align*}
Next we illustrate the behaviour of $\pmapp{P}{1}{f}$; below $\ell$ stands for $\bactout{a}{\abs{z}{\binp{z}{x} (\appl{x}{m})}}$.
\begin{align*}
\pmapp{P}{1}{f} & \scong  \newsp{s_1}{\bout{\dual{s_1}}{V} \inact \Par \binp{s_1}{x} \bout{a}{\abs{z}{\binp{z}{x} (\appl{x}{m})}} \newsp{s_2}{\bout{\dual{s_2}}{\abs{(x_a, x_m, z)}{\\
&  \qquad \qquad \qquad \qquad \quad \quad  \appl{x}{(x_a, x_m, z)}}} \inact} 
\Par \appl{x}{(a,m, s_2)}} \\
& \hby{\tau}  \bout{a}{\abs{z}{\binp{z}{x} (\appl{x}{m})}} \newsp{s_2}{\bout{\dual{s_2}}{V} \inact \Par \binp{s_2}{x} \bout{a}{\abs{z}{\binp{z}{x} (\appl{x}{m})}} \\
&  \qquad \qquad \quad \qquad \qquad \quad \newsp{s_3}{\bout{\dual{s_3}}{\abs{(x_a, x_m, z)}{\appl{x}{(x_a, x_m, z)}}} \inact} \Par \appl{x}{(a,m, s_3)}} \\
& \scong_{\alpha}  \bout{a}{\abs{z}{\binp{z}{x} (\appl{x}{m})}} \newsp{s_1}{\bout{\dual{s_1}}{V} \inact \Par \binp{s_1}{x} \bout{a}{\abs{z}{\binp{z}{x} (\appl{x}{m})}} \\
&  \qquad \qquad \qquad \qquad \quad \quad \newsp{s_2}{\bout{\dual{s_2}}{\abs{(x_a, x_m, z)}{\appl{x}{(x_a, x_m, z)}}} \inact} \Par \appl{x}{(a,m, s_2)}} \\
& \scong  
		\bout{a}{\abs{z}{\binp{z}{x} (\appl{x}{m})}} \pmapp{\recp{X}{\bout{a}{m} \varp{X}}}{1}{f} \hby{\ell} 
		\pmapp{\recp{X}{\bout{a}{m} \varp{X}}}{1}{f}.
%& \by{\lambda} & 
%		\pmapp{\recp{X}{\bout{a}{m} \varp{X}}}{1}{f}
\end{align*}
\end{example}


We now describe the properties of the encoding. 
{Directly from \figref{f:enc:hopi_to_ho} we may state:

\begin{proposition}[\HOp into \HO: Type Preservation]
\label{prop:typepres_HOp_to_HO}
The encoding from $\tyl{L}_{\HOp}$ into $\tyl{L}_{\HO}$ (cf.~\defref{d:enc:hopitoho})
is type preserving.
\end{proposition}}

\begin{proof}
By induction on the inference of $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$.
See \propref{app:prop:typepres_HOp_to_HO} in \appref{app:enc_HOp_to_HO}.
\end{proof}

%Now, we state operational correspondence with respect to reductions; the full statement (and proof) can be found in~\cite{KouzapasPY15}.
We now state a generalised form of operational correspondence, which includes $\tau$-labeled transitions (reductions) but also other transitions labelled with visible actions.
%Before we prove operational correspondence we
To this end, we define a mapping  on action labels: 
%\mathcal{A} \to \mathcal{A}$, where $\mathcal{A}$ denotes the set of labels of the relation$\hby{~}$:
\begin{definition}\rm
 The mapping on actions $\mapa{\cdot}^{1}: \mathcal{A}_{\HOp} \to \mathcal{A}_{\HO}$
	is defined as follows:
	\begin{align*}
		\mapa{(\nu \tilde{m})\bactout{n}{m}}^{1}
		& \defeq
		(\nu \tilde{m})\bactout{n}{\abs{z}{\,\binp{z}{x} (\appl{x}{m})} }
		\\
		\mapa{\bactinp{n}{m}}^{1}
		& \defeq
		\bactinp{n}{\abs{z}{\,\binp{z}{x} (\appl{x}{m})} }
		\\
		\mapa{(\nu \tilde{m})\bactout{n}{\abs{{x}}{P}}}^{1}
		& \defeq
		(\nu \tilde{m})\bactout{n}{\abs{{x}}{\pmapp{P}{1}{\es}}}
		\\ 
		\mapa{\bactinp{n}{\abs{{x}}{P}}}^{1}
		& \defeq
		\bactinp{n}{\abs{{x}}{\pmapp{P}{1}{\es}}}
%		\\
%		\mapa{\bactsel{n}{l} }^{1} & \defeq \bactsel{n}{l} 
%		\\
%		\mapa{\bactbra{n}{l} }^{1} & \defeq \bactbra{n}{l} 
%		\\
%		\mapa{\tau}^{1} & \defeq \tau
	\end{align*}
	and as an homomorphism for other actions $\ell \in \mathcal{A}_{\HOp}$.
	\end{definition}
	
	%We may now state a form of operational correspondence that covers both $\tau$-labeled and visible actions:
	We then have:

%Recall that $\hby{\stau}$ and $\hby{\btau}$ were defined in \notref{not:dettrans}.

%\begin{proposition}[\HOp into \HO: Operational Correspondence - Excerpt]%\myrm
%	\label{prop:op_corr_HOp_to_HO}
%	Let $P$ be an \HOp process such that $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$.
%	\begin{enumerate}[1.]
%		\item Completeness: 
%			Suppose $\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$. Then we have:
%%
%			\begin{enumerate}[a)]
%				\item
%					If  $P' \scong \newsp{\tilde{m}}{P_1 \Par P_2\subst{m}{x}}$
%					then $\exists R$ s.t. \\
%					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\tau}}{\mapt{\Delta}^{1}}{\newsp{\tilde{m}}{\pmapp{P_1}{1}{f} \Par R}}$,
%					and\\ 
%					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\newsp{\tilde{m}}{\pmapp{P_1}{1}{f} \Par R}}{\hby{\btau} \hby{\stau} \hby{\btau}}
%					{\mapt{\Delta}^{1}}{\newsp{\tilde{m}}{\pmapp{P_1}{1}{f} \Par \pmapp{P_2}{1}{f}\subst{m}{x}}}$.
%			
%				\item
%					If  $P' \scong \newsp{\tilde{m}}{P_1 \Par P_2 \subst{\abs{y}Q}{x}}$
%					then \\
%					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\tau}}
%					{\tmap{\Delta_1}{1}}{\newsp{\tilde{m}}{\pmapp{P_1}{1}{f}\Par \pmapp{P_2}{1}{f}\subst{\abs{y}\pmapp{Q}{1}{\emptyset}}{x}}}$.
%			
%				\item
%					If   $P' \not\scong \newsp{\tilde{m}}{P_1 \Par P_2 \subst{m}{x}} \land P' \not\scong \newsp{\tilde{m}}{P_1 \Par P_2\subst{\abs{y}Q}{x}}$
%					then \\
%					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\tau}}{\tmap{\Delta'_1}{1}}{ \pmapp{P'}{1}{f}}$.
%			\end{enumerate}
%			
%		\item Soundness:	Suppose $\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\tau}}{\tmap{\Delta'}{1}}{Q}$.
%			Then $\Delta' = \Delta$ and 
%					either
%%
%					\begin{enumerate}[a)]
%						\item	$\exists P'$ s.t. 
%							$\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta}{P'}$,
%							and $Q = \map{P'}^{1}_f$.	
%
%						\item
%							$\exists P_1, P_2, x, m, Q'$ s.t. 
%							$\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta}{\newsp{\tilde{m}}{P_1 \Par P_2\subst{m}{x}} }$, and\\
%							$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{Q}{\hby{\btau} \hby{\stau} \hby{\btau}}{\tmap{\Delta}{1}}{\pmapp{P_1}{1}{f} \Par \pmapp{P_2\subst{m}{x}}{1}{f}}$ 
%%							$Q = \map{P_1}^{1}_f \Par Q'$, where $Q'  \Hby{} $.
%
%%						\item $\exists P_1, P_2, x, R$ s.t. 
%%						$\stytra{ \Gamma }{\tau}{ \Delta }{ P}{ \Delta}{ \news{\tilde{m}}(P_1 \Par P_2\subst{\abs{y}R}{x}) }$, and 
%%						$Q = \map{\news{\tilde{m}}(P_1 \Par P_2\subst{\abs{y}R}{x})}^{1}_f$.
%			\end{enumerate}
%		    %\end{enumerate}
%		    
%%		\item   
%%			If  $\wtytra{\mapt{\Gamma}^{1}}{\ell_2}{\mapt{\Delta}^{1}}{\pmapp{P}{1}{f}}{\mapt{\Delta'}^{1}}{Q}$
%%			then $\exists \ell_1, P'$ s.t.  \\
%%			(i)~$\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$,
%%			(ii)~$\ell_2 = \mapa{\ell_1}^{1}$, 
%%			(iii)~$\wbb{\mapt{\Gamma}^{1}}{\ell}{\mapt{\Delta'}^{1}}{\pmapp{P'}{1}{f}}{\mapt{\Delta'}^{1}}{Q}$.
%	\end{enumerate}
%\end{proposition}


\begin{proposition}[Operational Correspondence, \HOp into \HO]\rm
	\label{prop:op_corr_HOp_to_HO}
	Let $P$ be a \HOp process.
	If $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then:
%
	\begin{enumerate}[1.]
		\item
			Suppose $\horel{\Gamma}{\Delta}{P}{\hby{\ell_1}}{\Delta'}{P'}$. Then we have:
%
			\begin{enumerate}[a)]
				\item
					If $\ell_1 \in \set{\news{\tilde{m}}\bactout{n}{m}, \,\news{\tilde{m}}\bactout{n}{\abs{x}Q}, \,\bactsel{s}{l}, \,\bactbra{s}{l}}$
					then $\exists \ell_2$ s.t. \\
					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\ell_2}}{\tmap{\Delta'}{1}}{\pmapp{P'}{1}{f}}$
					and $\ell_2 = \mapa{\ell_1}^{1}$.
			
				\item
					If $\ell_1 = \bactinp{n}{\abs{y}Q}$ and
					$P' = P_0 \subst{\abs{y}Q}{x}$
					then $\exists \ell_2$ s.t. \\
					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\ell_2}}{\tmap{\Delta'}{1}}{\pmapp{P_0}{1}{f}\subst{\abs{y}\pmapp{Q}{1}{\emptyset}}{x}}$
					and $\ell_2 = \mapa{\ell_1}^{1}$.
			
				\item
					If $\ell_1 = \bactinp{n}{m}$
					and 
					$P' = P_0 \subst{m}{x}$
					then $\exists \ell_2$, $R$ s.t. \\
					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\ell_2}}{\tmap{\Delta'}{1}}{R}$,
					with $\ell_2 = \mapa{\ell_1}^{1}$, \\
					and
					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta'}{1}}{R}{\hby{\stau} \hby{\btau} \hby{\btau}}
					{\tmap{\Delta'}{1}}{\pmapp{P_0}{1}{f}\subst{m}{x}}$.
						
				\item
					If $\ell_1 = \tau$
					and $P' \scong \newsp{\tilde{m}}{P_1 \Par P_2\subst{m}{x}}$
					then $\exists R$ s.t. \\
					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\tau}}{\mapt{\Delta}^{1}}{\newsp{\tilde{m}}{\pmapp{P_1}{1}{f} \Par R}}$,
					and\\ 
					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\newsp{\tilde{m}}{\pmapp{P_1}{1}{f} \Par R}}{\hby{\stau} \hby{\btau} \hby{\btau}}
					{\mapt{\Delta}^{1}}{\newsp{\tilde{m}}{\pmapp{P_1}{1}{f} \Par \pmapp{P_2}{1}{f}\subst{m}{x}}}$.
			
				\item
					If $\ell_1 = \tau$
					and $P' \scong \newsp{\tilde{m}}{P_1 \Par P_2 \subst{\abs{y}Q}{x}}$
					then \\
					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\tau}}
					{\tmap{\Delta_1}{1}}{\newsp{\tilde{m}}{\pmapp{P_1}{1}{f}\Par \pmapp{P_2}{1}{f}\subst{\abs{y}\pmapp{Q}{1}{\emptyset}}{x}}}$.
			
				\item
					If $\ell_1 = \tau$
					and $P' \not\scong \newsp{\tilde{m}}{P_1 \Par P_2 \subst{m}{x}} \land P' \not\scong \newsp{\tilde{m}}{P_1 \Par P_2\subst{\abs{y}Q}{x}}$
					then \\
					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\tau}}{\tmap{\Delta'_1}{1}}{ \pmapp{P'}{1}{f}}$.
			\end{enumerate}
			
		\item	Suppose $\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\ell_2}}{\tmap{\Delta'}{1}}{Q}$.
			Then we have:
%
			\begin{enumerate}[a)]
				\item 
					If $\ell_2 \in
					\set{\news{\tilde{m}}\bactout{n}{\abs{z}{\,\binp{z}{x} (\appl{x}{m})}}, \,\news{\tilde{m}} \bactout{n}{\abs{x}{R}}, \,\bactsel{s}{l}, \,\bactbra{s}{l}}$
					then $\exists \ell_1, P'$ s.t. \\
					$\horel{\Gamma}{\Delta}{P}{\hby{\ell_1}}{\Delta'}{P'}$, 
					$\ell_1 = \mapa{\ell_2}^{1}$, 
					and
					$Q = \pmapp{P'}{1}{f}$.
			
				\item 
					If $\ell_2 = \bactinp{n}{\abs{y} R}$ %(with $R \neq \binp{y}{x} \appl{x}{m}$)
					then either:
%
					\begin{enumerate}[(i)]
						\item	$\exists \ell_1, x, P', P''$ s.t. \\
							$\horel{\Gamma}{\Delta}{P}{\hby{\ell_1}}{\Delta'}{P' \subst{\abs{y}P''}{x}}$, 
							$\ell_1 = \mapa{\ell_2}^{1}$, $\pmapp{P''}{1}{\es} = R$, and $Q = \pmapp{P'}{1}{f}$.

						\item	$R \scong \binp{y}{x} (\appl{x}{m})$ and 
							$\exists \ell_1, z, P'$ s.t. \\
							$\horel{\Gamma}{\Delta}{P}{\hby{\ell_1}}{\Delta'}{P' \subst{m}{z}}$, 
							$\ell_1 = \mapa{\ell_2}^{1}$,
							and\\
							$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta'}{1}}{Q}{\hby{\stau} \hby{\btau} \hby{\btau}}{\tmap{\Delta''}{1}}{\pmapp{P'\subst{m}{z}}{1}{f}}$
					\end{enumerate}
			
				\item 
					If $\ell_2 = \tau$ 
					then $\Delta' = \Delta$ and 
					either
%
					\begin{enumerate}[(i)]
						\item	$\exists P'$ s.t. 
							$\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta}{P'}$,
							and $Q = \map{P'}^{1}_f$.	

						\item
							$\exists P_1, P_2, x, m, Q'$ s.t. 
							$\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta}{\newsp{\tilde{m}}{P_1 \Par P_2\subst{m}{x}} }$, and\\
							$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{Q}{\hby{\stau} \hby{\btau} \hby{\btau}}{\tmap{\Delta}{1}}{\pmapp{P_1}{1}{f} \Par \pmapp{P_2\subst{m}{x}}{1}{f}}$ 
%							$Q = \map{P_1}^{1}_f \Par Q'$, where $Q'  \Hby{} $.

%						\item $\exists P_1, P_2, x, R$ s.t. 
%						$\stytra{ \Gamma }{\tau}{ \Delta }{ P}{ \Delta}{ \news{\tilde{m}}(P_1 \Par P_2\subst{\abs{y}R}{x}) }$, and 
%						$Q = \map{\news{\tilde{m}}(P_1 \Par P_2\subst{\abs{y}R}{x})}^{1}_f$.
			\end{enumerate}
		    \end{enumerate}
		    
%		\item   
%			If  $\wtytra{\mapt{\Gamma}^{1}}{\ell_2}{\mapt{\Delta}^{1}}{\pmapp{P}{1}{f}}{\mapt{\Delta'}^{1}}{Q}$
%			then $\exists \ell_1, P'$ s.t.  \\
%			(i)~$\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$,
%			(ii)~$\ell_2 = \mapa{\ell_1}^{1}$, 
%			(iii)~$\wbb{\mapt{\Gamma}^{1}}{\ell}{\mapt{\Delta'}^{1}}{\pmapp{P'}{1}{f}}{\mapt{\Delta'}^{1}}{Q}$.
	\end{enumerate}
\end{proposition}


\begin{proof}
By transition induction. See \propref{app:prop:op_corr_HOp_to_HO} in \appref{app:enc_HOp_to_HO}.
 %\qed
\end{proof}

%\noi 
In the above proposition, it is worth
observing how we can explicitly distinguish the role of finite, deterministic reductions 
($\hby{\stau}$ and $\hby{\btau}$, cf. \notref{not:dettrans}) in both soundness and completeness statements.

%Using operational correspondence, we can show \emph{full abstraction}:
\newj{The typed operational correspondence given above is an important component in the 
proof of \emph{full abstraction}, which we state next.}
\begin{proposition}[\HOp into \HO: Full Abstraction]%\myrm
	\label{prop:fulla_HOp_to_HO}
	Let $P_1, Q_1$ be \HOp processes. \\
	$\horel{\Gamma}{\Delta_1}{P_1}{\hwb}{\Delta_2}{Q_1}$
	if and only if
	$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta_1}{1}}{\pmapp{P_1}{1}{f}}{\hwb}{\tmap{\Delta_2}{1}}{\pmapp{Q_1}{1}{f}}$.
\end{proposition}

\begin{proof}
The proof of both soundness and completeness directions proceeds coinductively.
See \propref{app:prop:fulla_HOp_to_HO} in \appref{app:enc_HOp_to_HO}.
 %\qed
\end{proof}


%Based on these propositions, w
We may state the main result of this section: % See~\cite{KouzapasPY15} for details. 

\begin{theorem}[Precise Encoding of \HOp into \HO]
\label{f:enc:hopitoho}
The encoding from $\tyl{L}_{\HOp}$ into $\tyl{L}_{\HO}$ (cf.~\defref{d:enc:hopitoho})
is precise. 
\end{theorem}

\begin{proof}
According to \defref{def:goodenc}, preciseness includes syntax-, type-, and semantics-preservation. 
Syntax preservation follows immediately from the definition of the encoding. 
Type preservation follows from \propref{prop:typepres_HOp_to_HO}.
Semantics-preservation follows from 	\propref{prop:op_corr_HOp_to_HO} and \propref{prop:fulla_HOp_to_HO}.
 %\qed
\end{proof}

\subsection{Precise Encoding of $\HOp$ into $\sessp$}
\label{subsec:HOp_to_sessp}
\newj{We now discuss the precise encodability of  $\HOp$ into $\sessp$;
the non trivial issue is encoding higher-order communication, which is present in $\HOp$ but not in 
$\sessp$.}
We closely follow Sangiorgi's encoding~\cite{San92,SaWabook}, which represents 
%Intuitively, such an encoding  represents 
the exchange of a process/abstraction by passing around a fresh \emph{trigger name}. 
Trigger names may then be used to activate copies of the abstraction, which becomes a persistent resource represented by an input-guarded replication.

%Consider the following (naive) adaptation of \cite{San92,SaWabook} 
%in which session names are used are triggers and 
%exchanged processes would be have to used exactly once:
%%
%\[
%\begin{array}{l}
%		\pmap{\bout{u}{\abs{x}{Q}} P}{n}  \defeq   \newsp{s}{\bout{u}{s} (\pmap{P}{n} \Par \binp{\dual{s}}{x} \pmap{Q}{n})} \\
%		\pmap{\binp{u}{x} P}{n}  \defeq \binp{u}{x} \pmap{P}{n}
%		\quad 
%		\pmap{\appl{x}{u}}{n}  \defeq  \bout{x}{u} \inact
%	\end{array}
%\]
%%
%with the remaining \HOp constructs being mapped homomorphically.
%Although $\pmap{\cdot}{n}$ captures the correct semantics when
%dealing with systems that allow only linear abstractions,
%it suffers from untypability in the presence
%of shared abstractions. For instance,
%mapping for $P = \bout{n}{\abs{x}{\bout{x}{m}\inact}} \inact \Par \binp{\dual{n}}{x} (\appl{x}{s_1} \Par \appl{x}{s_2})$
%would be:
%%
%\[
%	\pmap{P}{n} \defeq
%	\newsp{s}{\bout{n}{s} \binp{\dual{s}}{x} \bout{x}{m} \inact \Par \binp{\dual{n}}{x} (\bout{x}{s_1} \inact \Par \bout{x}{s_2} \inact)}
%\]
%%
%The above process is untypable since processes $(\bout{x}{s_1} \inact$ and $\bout{x}{s_2} \inact)$
%cannot be put in parallel because they do not have disjoint session environments.

The process mapping $\pmap{\cdot}{2}$, which we now informally discuss,
casts this strategy in the setting of session-typed communications. 
In the presence of session names (which are linear  and cannot be replicated),
%The correct 
our
approach %would be to 
 uses replicated names
as triggers for shared resources and non-replicated names
for linear resources. The encoding of abstraction sending therefore distinguishes two cases:
$$
	\pmap{\bout{u}{\abs{x}{Q}} P}{2}  \defeq  
	\begin{cases}
		\newsp{a}{\bout{u}{a} (\pmap{P}{2} \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{2})\,}\quad
		& \text{if $\fs{Q} = \emptyset$}
		\\
		\newsp{a}{\bout{u}{a} (\pmap{P}{2} \Par \binp{a}{y} \binp{y}{x} \pmap{Q}{2})\,}\quad
		& \text{otherwise} %\dk{Q \textrm{ linear}} \\
	\end{cases}
	$$
	where  $\repl{} P$ stands for $\recp{X}{(P \Par \rvar{X})}$.
	In the first case, if the abstraction body does not contain (linear) session names then it can be safely 
	represented as a persistent server accessible via a (fresh) trigger name $a$, which is sent in place of the abstraction. The second case covers the case in which the abstraction to be passed around 
	is linear: the server should be invoked exactly once, and cannot be persistent.
	In this scheme, the encoding of abstraction reception simply expects the trigger name $a$:
   $$
   \pmap{\binp{u}{x} P}{2} \defeq  \binp{u}{x} \pmap{P}{2}
   $$
	The mechanism for representing abstraction passing with name passing is completed in the encoding of name application. There are two cases:
	\begin{align*}
		\pmap{\appl{x}{u}}{2} &\defeq \newsp{s}{\bout{x}{s} \bout{\dual{s}}{u} \inact}
	\\
	\pmap{\appl{(\abs{x}{P})}{u}}{2} & \defeq  %\newsp{s}{\bout{a}{s} \bout{\dual{s}}{u} \inact} \\
	\newsp{s}{\binp{s}{x} \pmap{P}{2} \Par \bout{\dual{s}}{u} \inact}
\end{align*}
Thus,   in both cases we first establish a fresh session $s$   with the server representing the abstraction body;
the name to be applied ($u$) is then passed around using $s$.
%(cf. $\pmap{\bout{u}{\abs{x}{Q}} P}{2}$).
%as triggers instead of session names, when dealing with shared abstractions. 
%\noi 
%Notice that $\mapa{\bactinp{n}{\abs{ x}{P}} }^2$ involves a fresh trigger name (linear or shared),  which denotes the location of $\pmap{P}{2}$. 
%(a $\sessp$ process).
Observe how %$\pmap{\appl{(\abs{x}{P})}{u}}{2}$ 
this encoding
naturally induces the name substitution expected from a name application.
We may now define:


%\smallskip 

\begin{definition}[Typed Encoding of \HOp into \sessp]
\label{d:enc:hopitopi}
%Let $\tyl{L}_{\sessp}=\calc{\sessp}{{\cal{T}}_3}{\hby{\ell}}{\fwb}{\proves}$ 
%where the typing is defined in 
%\figref{fig:typerulesmy} 
%and the equivalence $\fwb$ is defined in \defref{d:fwb}.
%${\cal{T}}_3$ is a set of types of $\sessp$.  
%%
The typed encoding 
$\enco{\map{\cdot}^{2}, \mapt{\cdot}^{2} %, \mapa{\cdot}^{2}
}: \tyl{L}_{\HOp} \to \tyl{L}_{\sessp}$  
%We define the mappings $\map{\cdot}^{2}$, $\mapt{\cdot}^{2}$, $\mapa{\cdot}^{2}$
is defined
in \figref{f:enc:ho_to_sessp}. 
\end{definition}

%\smallskip 
\input{figures/HOp_to_pi}

We describe key properties of this encoding. First, type preservation and operational correspondence, which requires a mapping on action labels.

\begin{proposition}[\HOp into \sessp: Type Preservation]
\label{prop:typepres_HOp_to_p}
The encoding from $\tyl{L}_{\HOp}$ into $\tyl{L}_{\sessp}$ (cf.~\defref{d:enc:hopitopi})
is type preserving.
\end{proposition}

\begin{proof}
	By induction on the inference $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$.
	See \propref{app:prop:typepres_HOp_to_p} in 
	\appref{app:enc:HOp_to_sessp}.
	 %\qed
\end{proof}

%To state operational correspondence we
%define a mapping on action labels:
%from $\mapa{\cdot}^{2}: \mathcal{A} \to \mathcal{A}$ 
%where $\mathcal{A}$ is the set of labels of the relation $\hby{\ell}$:
\begin{definition}%\rm
The mapping on actions $\mapa{\cdot}^{2}: \mathcal{A}_{\HOp} \to \mathcal{A}_{\sessp}$ is defined as follows:
	\begin{align*}
		\mapa{(\nu \tilde{m})\bactout{n}{\abs{ x}{P}} }^{2} & \defeq \news{m} \bactout{n}{m}
		\\
		\mapa{\bactinp{n}{\abs{ x}{P}} }^{2} & \defeq \bactinp{n}{m} \quad \quad m \text{ fresh}
	\end{align*}
	and as an homomorphism for other actions $\ell \in \mathcal{A}_{\HOp}$.
\end{definition}

We now state operational correspondence, covering both internal and visible actions:
%in \defref{app:def:opc_strong}.

\begin{proposition}[Operational Correspondence, \HOp into \sessp]\myrm
	\label{prop:op_corr_HOp_to_p}
	Let $P$ be an  $\HOp$ process such that  $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$.
	
	\begin{enumerate}[1.]
		\item Suppose $\horel{\Gamma}{\Delta}{P}{\hby{\ell_1}}{\Delta'}{P'}$.
		Then we have:
		\begin{enumerate}[a)]
			\item
				If  $\ell_1 = \news{\tilde{m}}\bactout{n}{\abs{x}Q}$,
				then $\exists \Gamma', \Delta''$ where either:
				\begin{enumerate}[-]
					\item 
						$\tmap{\Gamma}{2};\, \tmap{\Delta}{2} \proves  \pmap{P}{2} 
						\hby{\mapa{\ell_1}^{2}}
						\Gamma' \cdot \tmap{\Gamma}{2};\, \tmap{\Delta'}{2} \proves \pmap{P'}{2} \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{2}$
					\item 
						$\tmap{\Gamma}{2};\, \tmap{\Delta}{2} \proves \pmap{P}{2} 
						\hby{\mapa{\ell_1}^{2}}
						\tmap{\Gamma}{2};\, \Delta'' \proves \pmap{P'}{2} \Par \binp{s}{y} \binp{y}{x} \pmap{Q}{2}$
				\end{enumerate}

			\item
				If   
				$\ell_1 = \bactinp{n}{\abs{y}Q}$
				then $\exists R$ where
				either
				\begin{enumerate}[-]
					\item 
						$\tmap{\Gamma}{2};\, \tmap{\Delta}{2} \proves \pmap{P}{2} 
						\hby{\mapa{\ell_1}^{2}}
						\Gamma';\, \tmap{\Delta''}{2} \proves  R$, for some $ \Gamma'$
						and \\ 
						$\horel{\tmap{\Gamma}{2}}{\tmap{\Delta'}{2}}{\pmap{P'}{2}}{\wb}{\tmap{\Delta''}{2}}{\newsp{a}{R \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{2}}}$
					\item 
						$\tmap{\Gamma}{2};\, \tmap{\Delta}{2} \proves \pmap{P}{2}
						\hby{\mapa{\ell_1}^{2}}
						\tmap{\Gamma}{2};\, \tmap{\Delta''}{2} \proves R$, 
						and \\ 
						$\horel{\tmap{\Gamma}{2}}{\tmap{\Delta'}{2}}{\pmap{P'}{2}}{\wb}{\tmap{\Delta''}{2}}{\newsp{s}{R \Par \binp{s}{y} \binp{y}{x} \pmap{Q}{2}}}$  		
				\end{enumerate}

			\item	If
				$\ell_1 = \tau$ then either:

				\begin{enumerate}[-]
					\item	%$\exists R$ such that
						$
						\horel{\tmap{\Gamma}{2}}{\tmap{\Delta}{2}}{\pmap{P}{2}}
						{\hby{\tau}}
						{\tmap{\Delta'}{2}}{}{\newsp{\tilde{m}}{\pmap{P_1}{2} \Par \newsp{a}
						{\pmap{P_2}{2}\subst{a}{x} \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{2}}}}
						$, for some $P_1$, $P_2$, $Q$;

					\item	%$\exists R$ such that
						$
						\horel{\tmap{\Gamma}{2}}{\tmap{\Delta}{2}}{\pmap{P}{2}}
						{\hby{\tau}}
						{\tmap{\Delta'}{2}}{}{\newsp{\tilde{m}}{\pmap{P_1}{2} \Par \newsp{s}
						{\pmap{P_2}{2}\subst{\dual{s}}{x} \Par \binp{s}{y} \binp{y}{x} \pmap{Q}{2}}}}
						$, for some $P_1$, $P_2$, $Q$;

					\item	%$\ell_1 = \btau$ and
						$\tmap{\Gamma}{2};\, \tmap{\Delta}{2} \proves \pmap{P}{2}
						\hby{\tau}
						\tmap{\Gamma}{2};\, \tmap{\Delta'}{2} \proves \pmap{P'}{2}$


				\end{enumerate}
				
				\item	If $\ell_1 = \btau$ then
						$\tmap{\Gamma}{2};\, \tmap{\Delta}{2} \proves \pmap{P}{2}
						\hby{\stau}
						\tmap{\Gamma}{2};\, \tmap{\Delta'}{2} \proves \pmap{P'}{2}$

%			\item	 
%				If  
%				%$\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P_1 \Par P_2\subst{\abs{x}Q}{X}}$
%				$\ell_1 = \tau$ and $P' 	\not \scong \news{\tilde{m}}(P_1 \Par P_2\subst{\abs{x}Q}{X})$
%				then \\
%				$\mapt{\Gamma}^{2};\, \mapt{\Delta}^{2} \proves  \map{P}^{2}
%				\hby{\tau}
%				\mapt{\Gamma}^{2};\, \mapt{\Delta'}^{2} \proves  \map{P'}^{2}$.
				   			   
%			   then  $\exists \ell_2$ s.t. 
%			    $\wtytra{\mapt{\Gamma}^{3}}{\ell_2}{\mapt{\Delta}^{3}}{\map{P}^{3}}{\mapt{\Delta'}^{3}}{\map{P'}^{3}}$
%			    and $\ell_2 = \mapa{\ell_1}^{3}$.

			\item	 
				If  
				$\ell_1 \in \set{\bactsel{n}{l}, \bactbra{n}{l}}$
				%\not\in \set{\tau,\, \news{\tilde{m}}\bactout{n}{\abs{x}Q}, \, \bactinp{n}{\abs{x}Q}}$ 
				 then \\
				$\exists \ell_2 = \mapa{\ell_1}^{2}$ such that 
				$\mapt{\Gamma}^{2};\, \mapt{\Delta}^{2} \proves  \map{P}^{2}
				\hby{\ell_2}
				\mapt{\Gamma}^{2};\, \mapt{\Delta'}^{2} \proves  \map{P'}^{2}$.			
		\end{enumerate}
		
		%%%%%%% SOUNDNESSS
		\item Suppose 
		$\stytra{\mapt{\Gamma}^{2}}{\ell_2}{\mapt{\Delta}^{2}}{\map{P}^{2}}{\mapt{\Delta'}^{2}}{R}$.
			\begin{enumerate}[a)]
				\item %% soutput
					%\footnote{$\mapt{\Gamma}^{2}$ in the following three items need adjustments.}
					If  
					$\ell_2 = \news{m}\bactout{n}{m}$
					%$\stytra{\mapt{\Gamma}^{2}}{\news{m}\bactout{n}{m}}{\mapt{\Delta}^{2}}{\map{P}^{2}}{\mapt{\Delta'}^{2}}{R}$
					then 
					either 
					\begin{enumerate}[-]
					\item	$\exists P'$ such that $P \hby{\news{m} \bactout{n}{m}} P'$
						and $R = \pmap{P'}{2}$.

					\item	$\exists Q, P'$ such that $P \hby{\bactout{n}{\abs{x}Q}} P'$
						and $R = \map{P'}^{2} \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{2}$

					\item	$\exists Q, P'$ such that $P \hby{\bactout{n}{\abs{x}Q}} P'$
						and $R = \map{P'}^{2} \Par \binp{s}{y} \binp{y}{x} \pmap{Q}{2}$
					\end{enumerate}

				\item   %% sinput
					If  $\ell_2 = \bactinp{n}{m}$ 
					%$\stytra{\mapt{\Gamma}^{2}}{\bactinp{n}{m}}{\mapt{\Delta}^{2}}{\map{P}^{2}}{\mapt{\Delta'}^{2}}{R}$
					then either
					\begin{enumerate}[-]
					\item	$\exists P'$ such that $P \hby{\bactinp{n}{m}} P'$
						and $R = \pmap{P'}{2}$.

					\item	$\exists Q, P'$ such that
						$P \hby{\bactinp{n}{\abs{x}Q}} P'$\\
						and $\horel{\mapt{\Gamma}^{2}}{\mapt{\Delta'}^{2}}{\map{P'}^{2}}{\wb}{\mapt{\Delta'}^{2}}{\news{a}(R \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{2})}$
					\item	$\exists Q, P'$ such that
						$P \hby{\bactinp{n}{\abs{x}Q}} P'$\\
						and $\horel{\mapt{\Gamma}^{2}}{\mapt{\Delta'}^{2}}{\map{P'}^{2}}{\wb}{\mapt{\Delta'}^{2}}{\news{s}(R \Par \binp{s}{y} \binp{y}{x} \pmap{Q}{2})}$  
					\end{enumerate}
		
				\item   
					If  %$\stytra{\mapt{\Gamma}^{2}}{\tau}{\mapt{\Delta}^{2}}{\map{P}^{2}}{\mapt{\Delta'}^{2}}{R}$
					$\ell_2 = \tau$ 
					then $\exists P'$ such that
					$P \hby{\tau} P'$
					and $\horel{\mapt{\Gamma}^{2}}{\mapt{\Delta'}^{2}}{\map{P'}^{2}}{\hwb}{\mapt{\Delta'}^{2}}{R}$.
				\item	 
					If  
					$\ell_2 \not\in \set{\bactout{n}{m}, \bactsel{n}{l}, \bactbra{n}{l}}$ 
					 then 
					$\exists \ell_1$ such that 
					$\ell_1 = \mapa{\ell_2}^{2}$ and \\
					$ \Gamma ;\, \Delta  \proves   P
					\hby{\ell_1}
					\Gamma ;\, \Delta  \proves   P'$.
		\end{enumerate}
	\end{enumerate}
\end{proposition}

\begin{proof}
	\noi The proof is by transition induction.
	See \propref{app:prop:op_corr_HOp_to_p} in 
	\appref{app:enc:HOp_to_sessp}.
	 %\qed
\end{proof}

Some comments on the completeness properties given by \propref{prop:op_corr_HOp_to_p} are in order. Items 1(a), 1(b), and 1(e) describe the way in which 
the encoding mimicks source visible transitions (output, input, and labelled choice/selection, respectively). 
As discussed above, the encoding of output 
sets up a potentially persistent server to represent the body of the abstraction being exchanged. 
The statement in 1(a) formalises the fact that 
after an output transition in the source process this server has not been yet invoked/used on the target side, and so it appears as a
residual context ($\repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{2}$ or $\binp{s}{y} \binp{y}{x} \pmap{Q}{2}$)
in parallel to the encoding of the continuation of the output ($\pmap{P'}{2}$).
Similarly, the statement in 1(b) formalises the fact that after an input transition the resulting process $R$ should be 
placed in an appropriate context containing the server representing the abstraction body. 
Together, $R$ and its server are behaviorally equivalent to $\pmap{P'}{2}$.
Items 1(c) and 1(d) state correspondences for internal actions, in the sense of \defref{def:ep}.
In particular, the first two sub-items in 1(c) describe the way in which a source reduction due to abstraction passing is matched: in our encoding
this is mimicked by exchanging the trigger names; the third sub-item covers other possibilities for source reductions. 

%\begin{proposition}[\HOp into \sessp: Operational Correspondence - Excerpt]%\myrm
%	\label{prop:op_corr_HOp_to_p}
%	Let $P$ be an  $\HOp$ process such that  $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$.
%	
%\begin{enumerate}[1.]
%\item Completeness: Suppose $\horel{\Gamma}{\Delta}{P}{\hby{\ell}}{\Delta'}{P'}$. Then either:
%				\begin{enumerate}[a)]
%				\item If $\ell = \tau$ then one of the following holds:
%				\begin{enumerate}[-]
%					\item	 %such that
%						$
%						\horel{\tmap{\Gamma}{2}}{\tmap{\Delta}{2}}{\pmap{P}{2}}
%						{\hby{\tau}} \\
%						{\tmap{\Delta'}{2}}{}{\newsp{\tilde{m}}{\pmap{P_1}{2} \!\Par\! \newsp{a}
%						{\pmap{P_2}{2}\subst{a}{x} \!\Par\!\! \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{2}}}}
%						$, for some  $P_1, P_2, Q$;
%
%					\item	%$\exists R$ such that
%						$
%						\horel{\tmap{\Gamma}{2}}{\tmap{\Delta}{2}}{\pmap{P}{2}}
%						{\hby{\tau}}
%						{\tmap{\Delta'}{2}}{}{\newsp{\tilde{m}}{\pmap{P_1}{2} \Par \newsp{s}
%						{\pmap{P_2}{2}\subst{\dual{s}}{x} \!\Par\! \binp{s}{y} \binp{y}{x} \pmap{Q}{2}}}}
%						$, for some  $P_1, P_2, Q$;
%
%					\item	%$\ell_1 = \btau$ and
%						$\horel{\tmap{\Gamma}{2}}{\tmap{\Delta}{2}}{\pmap{P}{2}}
%						{\hby{\tau}}
%						{\tmap{\Delta'}{2}}{}{{\pmap{P'}{2} }}
%						$
%
%				\end{enumerate}
%				\item 	If $\ell = \btau$ then 
%						$\horel{\tmap{\Gamma}{2}}{\tmap{\Delta}{2}}{\pmap{P}{2}}
%						{\hby{\stau}}
%						{\tmap{\Delta'}{2}}{}{{\pmap{P'}{2} }}
%						$.
%				\end{enumerate}
%		
%		%%%%%%% SOUNDNESSS
%		\item Suppose 
%		$\stytra{\mapt{\Gamma}^{2}}{\tau}{\mapt{\Delta}^{2}}{\map{P}^{2}}{\mapt{\Delta'}^{2}}{R}$.  \\
%		Then $\exists P'$ such that
%					$P \hby{\tau} P'$
%					and $\horel{\mapt{\Gamma}^{2}}{\mapt{\Delta'}^{2}}{\map{P'}^{2}}{\hwb}{\mapt{\Delta'}^{2}}{R}$.
%	\end{enumerate}
%\end{proposition}

\newj{Exploiting the above properties (type preservation, typed operational correspondence), 
we can show that our typed encoding is fully abstract  and precise. }

\begin{proposition}[\HOp to \sessp: Full Abstraction]%\myrm
	\label{prop:fulla_HOp_to_p}
	Let $P_1, Q_1$ be \HOp processes.
	$\horel{\Gamma}{\Delta_1}{P_1}{\hwb}{\Delta_2}{Q_1}$
	if and only if
	$\horel{\tmap{\Gamma}{2}}{\tmap{\Delta_1}{2}}{\pmap{P_1}{2}}{\fwb}{\tmap{\Delta_2}{2}}{\pmap{Q_1}{2}}$.
\end{proposition}

\begin{proof}
The proof of both soundness and completeness directions proceeds coinductively.
See \propref{app:prop:fulla_HOp_to_p} in \appref{app:enc:HOp_to_sessp}.
 %\qed
\end{proof}

We may now finally state:


\begin{theorem}[Precise Encoding of \HOp into \sessp]
\label{f:enc:hotopi}
The encoding from $\tyl{L}_{\HOp}$ into $\tyl{L}_{\sessp}$ (cf.~\defref{d:enc:hopitopi})
is precise. 
\end{theorem}

\begin{proof}
According to \defref{def:goodenc}, preciseness includes syntax-, type-, and semantics-preservation. 
Syntax preservation follows immediately from the definition of the encoding. 
Type preservation follows from 
\propref{prop:typepres_HOp_to_p}.
Semantics-preservation follows from 	
\propref{prop:op_corr_HOp_to_p} and 
\propref{prop:fulla_HOp_to_p}.
 %\qed
\end{proof}

%\smallskip 
%
%\begin{remark}
%As stated in  \cite[Lem.\,5.2.2]{SangiorgiD:expmpa}, 
%due to the replicated trigger,  
%operational correspondence in \defref{def:ep} is refined to prove  
%full abstraction: 
%e.g., completeness of the case $\ell_1 \neq \tau$, is changed as follows.
%Suppose   
%$\stytraarg{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}{}$:
%if $\ell_1 = (\nu \tilde{m})\bactout{n}{\abs{ x}{R}}$, 
%then %$\exists \ell_2, Q$ s.t. 
%$\stytraarg{\mapt{\Gamma}^2}{\ell_2}{\mapt{\Delta}^2}{\map{P}^2}{\mapt{\Delta'}^2}{Q}{}$,
%where 
%$\ell_2 = (\nu a)\bactout{n}{a}$ and
%$Q = \pmap{P' \Par  \repl{} \binp{a}{y} \binp{y}{x} R}{2}$.
%Similarly,
%if  
%%$\stytraarg{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}{}$
%%with 
%$\ell_1 = \bactinp{n}{\abs{ x}{R}}$, 
%then %$\exists \ell_2, Q$ s.t. 
%$\stytraarg{\mapt{\Gamma}^2}{\ell_2}{\mapt{\Delta}^2}{\map{P}^2}{\mapt{\Delta'}^2}{Q}{}$,
%where 
%$\ell_2 = \bactout{n}{a}$ and
%$\pmap{P'}{2} \wb \news{a}(Q \Par  \repl{} \binp{a}{y} \binp{y}{x} \pmap{R}{2})$.
%Soundness is stated in a symmetric way; see \cite{KouzapasPY15}. 
%%Operational correspondence for the encoding in~\defref{d:enc:hopitopi}
%%is different from that in~\defref{def:ep}, due to triggers. 
%%In particular,  completeness differs when $\ell_1 \neq \tau$.
%%This way, e.g., if  
%%$\stytraarg{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}{}$
%%with $\ell_1 = (\nu \tilde{m})\bactout{n}{\abs{ x}{R}}$, 
%%then %$\exists \ell_2, Q$ s.t. 
%%$\stytraarg{\mapt{\Gamma}^2}{\ell_2}{\mapt{\Delta}^2}{\map{P}^2}{\mapt{\Delta'}^2}{Q}{}$,
%%where 
%%$\ell_2 = (\nu a)\bactout{n}{a}$ and
%%$Q = \pmap{P' \Par  \repl{} \binp{a}{y} \binp{y}{x} R}{2}$.
%%This 
%%statement, essential in proofs of full abstraction,
%%is the same given by Sangiorgi~\cite{SangiorgiD:expmpa}.
%%Completeness is as in~\defref{def:ep} when  $\ell_1 = \tau$.
%%See~\cite{KouzapasPY15} for details.
%\end{remark}


%\input{HO_Vs_p}

\subsection{Comparing Precise Encodings}\label{ss:compare}
The precise encodings  in  \secref{subsec:HOpi_to_HO} and \secref{subsec:HOp_to_sessp}
confirm that \HO and \sessp constitute two important sources of expressiveness in \HOp.
This naturally begs the question: which of the two sub-calculi is more tightly related to \HOp?
We argue, both empirically and formally, that when compared to \sessp, \HO   is more economical and satisfies tighter correspondences.

\paragraph{Empirical Comparison: Reduction Steps}
We first contrast the way in which 
%\begin{enumerate}[a)]
%\item 
(a)~the encoding from \HOp to \HO (\secref{subsec:HOpi_to_HO}) translates processes with name passing;
%\item 
(b)~the encoding from \HOp to \sessp (\secref{subsec:HOp_to_sessp}) translates processes with abstraction passing.
%\end{enumerate}
Consider the \HOp processes:
\begin{align*}
P_1 & =  \bout{s}{a} \inact \Par \binp{\dual{s}}{x} (\bout{x}{s_1} \inact \Par \dots \Par \bout{x}{s_n} \inact) 
\\
P_2 & =  \bout{s}{\abs{x}{P}} \inact \Par \binp{\dual{s}}{x} (\appl{x}{s_1} \Par \dots \Par \appl{x}{s_n})
\end{align*}

%\begin{eqnarray*}
%P_1 & = & \bout{s}{a} \inact \Par \binp{\dual{s}}{x} (\bout{x}{s_1} \inact \Par \dots \Par \bout{x}{s_n} \inact) \\
%P_2 & = & \bout{s}{\abs{x}{P}} \inact \Par \binp{\dual{s}}{x} (\appl{x}{s_1} \Par \dots \Par \appl{x}{s_n})
%\end{eqnarray*}
%\noi 
 $P_1$ features \emph{pure} name passing (no abstraction-passing), whereas 
$P_2$ involves \emph{pure} abstraction passing (no name passing). Intuitively, 
$P_1$ and $P_2$ have a similar purpose:
in both cases, 
the intended communication on $s$ leads to $n$ usages of the communication object (name $a$ in $P_1$, abstraction $\abs{x}{P}$ in $P_2$).
Consider now the reduction steps from $P_1$ and $P_2$:
\begin{eqnarray*}
P_1 & \hby{\tau} & \bout{a}{s_1} \inact \Par \dots \Par \bout{a}{s_n} \inact \\
P_2 & \hby{\tau}& \appl{(\abs{x}{P})}{s_1} \Par \dots \Par \appl{(\abs{x}{P})}{s_n} \quad 
\underbrace{\hby{\btau}\hby{\btau} \cdots \hby{\btau}}_{n} 
%\hby{}}^{n}
%\stackrel{\btau}{\longmapsto^n}
\quad P \subst{s_1}{x} \Par \dots \Par P \subst{s_n}{x} 
\end{eqnarray*}

%Let reduction on \sessp process:
%\begin{eqnarray*}
%	\bout{s}{a} \inact \Par \binp{\dual{s}}{x} (\bout{x}{s_1} \inact \Par \dots \Par \bout{x}{s_n} \inact)
%	\hby{\tau}
%	\bout{a}{s_1} \inact \Par \dots \Par \bout{a}{s_n} \inact
%\end{eqnarray*}
%and \HO process
%\begin{eqnarray*}
%	\bout{s}{\abs{x}{P}} \inact \Par \binp{\dual{s}}{x} (\appl{x}{s_1} \Par \dots \Par \appl{x}{s_n})
%	&\hby{\tau}&
%	\appl{(\abs{x}{P})}{s_1} \Par \dots \Par \appl{(\abs{x}{P})}{s_n}\\
%	&\Hby{\tau}_{n}&
%	P \subst{s_1}{x} \Par \dots \Par P \subst{s_1}{x}
%\end{eqnarray*}
%\noi 
%$P_1$ and $P_2$ follow the same communication pattern; they both
%reduce on a message passing action, with the
%message being substituted $n$ times on the receing side.
%Both $P_1$ and $P_2$ are \HOp processes.
We encode $P_1$ into \HO and $P_2$ into \sessp and contrast the results. 
First, by considering the encoding of $P_1$ into \HO  (following \figref{f:enc:hopi_to_ho})
we obtain:
\begin{eqnarray*}
\map{P_1}^{1}_f & = &  	\bout{s}{\abs{z}{\binp{z}{y} \appl{y}{a}}} \inact \Par \\
& & \quad  \binp{\dual{s}}{x} \newsp{t}{\appl{x}{t} \Par \bout{\dual{t}}{\abs{x}{(\bout{x}{\abs{z}{\binp{z}{y} \appl{y}{s_1}}} \inact \Par \dots \Par \bout{x}{\abs{z}{\binp{z}{y} \appl{y}{s_n}}} \inact)}} \inact}\\
	& \hby{\stau} \hby{\btau} & 
%	\newsp{t}{\appl{(\abs{z}{\binp{z}{y} \appl{y}{a}})}{t} \Par \bout{\dual{t}}{\abs{x}{(\bout{x}{\abs{z}{\binp{z}{y} \appl{y}{s_1}}} \inact \Par \dots \Par \bout{x}{\abs{z}{\binp{z}{y} \appl{y}{s_n}}} \inact)}} \inact}\\
%	& \hby{\btau} & 
	\newsp{t}{\binp{t}{y} \appl{y}{a} \Par \bout{\dual{t}}{\abs{x}{(\bout{x}{\abs{z}{\binp{z}{y} \appl{y}{s_1}}} \inact \Par \dots \Par \bout{x}{\abs{z}{\binp{z}{y} \appl{y}{s_n}}} \inact)}} \inact}\\
	& \hby{\stau}\hby{\btau}  & 
%	\appl{\abs{x}{(\bout{x}{\abs{z}{\binp{z}{y} \appl{y}{s_1}}} \inact \Par \dots \Par \bout{x}{\abs{z}{\binp{z}{y} \appl{y}{s_n}}} \inact)}}{a}
%	\\
%	& \hby{\btau} & 
	\bout{a}{\abs{z}{\binp{z}{y} \appl{y}{s_1}}} \inact \Par \dots \Par \bout{a}{\abs{z}{\binp{z}{y} \appl{y}{s_n}}} \inact
\end{eqnarray*}
Now, we encode $P_2$ into \sessp (following \figref{f:enc:ho_to_sessp}):
\begin{eqnarray*}
\pmap{P_2}{2} & = & 	\newsp{b}{\bout{s}{b} \inact \Par \repl \binp{b}{y} \binp{y}{x} P} \Par \\
& & \qquad \qquad \binp{\dual{s}}{x} (\newsp{s}{\bout{x}{s} \bout{\dual{s}}{s_1} \inact} \Par \dots \Par \newsp{s}{\bout{x}{s} \bout{\dual{s}}{s_n}\inact})
	\\
%	& \hby{\stau} & 
%	\newsp{b}{\repl \binp{b}{y} \binp{y}{x} P \Par \newsp{s}{\bout{b}{s} \bout{\dual{s}}{s_1} \inact} \Par \dots \Par \newsp{s}{\bout{b}{s} \bout{\dual{s}}{s_n} \inact}}
%	\\
	& \hby{\stau}  \hby{\stau} \hby{\stau} & 
%	\newsp{b}{\repl \binp{b}{y} \binp{y}{x} P \Par \newsp{s}{\binp{s}{x} P \Par \bout{\dual{s}}{s_1} \inact} \Par \dots \Par \newsp{s}{\bout{b}{s} \bout{\dual{s}}{s_n} \inact}}
%	\\
%	& \hby{\stau} & 
	\newsp{b}{\repl \binp{b}{y} \binp{y}{x} P \Par P\subst{s_1}{x} \Par \dots \Par \newsp{s}{\bout{b}{s} \bout{\dual{s}}{s_n} \inact}}
	\\
	& \Hby{}_{2*(n - 1)} & 
	\newsp{b}{\repl \binp{b}{y} \binp{y}{x} P \Par P\subst{s_1}{x} \Par \dots \Par P\subst{s_n}{x}}
%	\red
%	\appl{V}{s_1} \Par \dots \Par \appl{V}{s_n}
\end{eqnarray*}
%\noi 
Clearly, encoding $P_1$ into \HO is more economical than 
encoding $P_2$ into \sessp. Not only moving to a pure higher-order setting requires less reduction steps than in the first-order concurrency of \sessp; in the presence of shared names, moving to a first-order setting brings the need of setting up and handling replicated processes which will eventually lead to garbage (stuck) processes (cf. $\repl \binp{b}{y} \binp{y}{x} P$ above). In contrast, the mechanism present in \HO works efficiently regardless of the linear or shared properties of the name that is ``packed'' into the abstraction. 
The use of $\beta$-transitions guarantees local synchronizations, which are arguably more economical than point-to-point, session synchronizations.

It is useful to move our comparison 
to a purely linear setting. % and to see what occurs. 
Consider processes $Q_1$ and $Q_2$:
%In the case of linear values we have:
\begin{align*}
	Q_1  & =  \bout{s'}{s} \inact \Par \binp{\dual{s'}}{x} \bout{x}{a} \inact
	\hby{\tau}
	\bout{s}{a} \inact 
	\\
	Q_2 & =  \bout{s}{\abs{x}{P}} \inact \Par \binp{\dual{s}}{x} \appl{x}{a}
	\hby{\tau}
%	\appl{(\abs{x}{P})}{a}
	\hby{\tau}
	P \subst{a}{x}
\end{align*}
$Q_1$ is a \sessp process and $Q_2$ is an \HO processs.
If we consider the encoding of $Q_1$ into \HO and of $Q_2$ into \sessp 
we obtain:
\begin{eqnarray*}
	\map{Q_1}_f^{1} & = & \bout{s'}{\abs{z}{\binp{z}{y} \appl{y}{s}}} \inact \Par \binp{\dual{s'}}{x} \newsp{t}{\appl{x}{t} \Par \bout{\dual{t}}{\abs{x}{\bout{x}{\abs{z}{\binp{z}{y} \appl{y}{a}}} \inact}} \inact}\\
	& \hby{\stau} \hby{\btau}& 
%	\newsp{t}{\appl{(\abs{z}{\binp{z}{y} \appl{y}{s}})}{t} \Par \bout{\dual{t}}{\abs{x}{\bout{x}{\abs{z}{\binp{z}{y} \appl{y}{a}}} \inact)}} \inact}\\
%	& \hby{\btau} & 
	\newsp{t}{\binp{t}{y} \appl{y}{s} \Par \bout{\dual{t}}{\abs{x}{\bout{x}{\abs{z}{\binp{z}{y} \appl{y}{a}}} \inact}} \inact}\\
	& \hby{\stau} & 
	\appl{\abs{x}{\bout{x}{\abs{z}{\binp{z}{y} \appl{y}{a}}} \inact}}{s}
	~~\hby{\btau}~~
	\bout{s}{\abs{z}{\binp{z}{y} \appl{y}{a}}} \inact \\
%\end{eqnarray*}
%\begin{eqnarray*}
	\pmap{Q_2}{2} & = & \newsp{t}{\bout{s}{t} \inact \Par \binp{\dual{t}}{y} \binp{y}{x} P} \Par \binp{\dual{s}}{x} \newsp{s}{\bout{x}{s} \bout{\dual{s}}{a} \inact}
	\\
	& \hby{\stau} \hby{\stau} & 
%	\newsp{t}{\binp{\dual{t}}{y} \binp{y}{x} P \Par \newsp{s}{\bout{t}{s} \bout{\dual{s}}{a} \inact}}
%	\\
%	& \hby{\stau} & 
	\newsp{s}{\binp{s}{x} P \Par \bout{\dual{s}}{a} \inact}
	~~
	\hby{\stau} ~~
	P\subst{a}{x}
\end{eqnarray*}
%\noi 
In this case, the encoding $\pmap{\cdot}{2}$ is more efficient: it induces less reduction steps.
Therefore, considering a fragment of \HOp without shared communications (linearity only)
has consequences in terms of reduction steps. 
These apparent benefits of encoding  $\pmap{\cdot}{2}$ over 
encoding  $\pmap{\cdot}{1}$ in the presence of linearity should, however, be considered in a broader setting, for 
in \secref{ss:negative} we prove that linear resources do 
not suffice to encode shared communications.
Therefore, in the general case featuring linear and shared communication not only the benefits of  $\pmap{\cdot}{2}$ over  $\pmap{\cdot}{1}$ could not be obtained,
but the drawbacks mentioned in the comparison between $\pmap{P_1}{1}$ and $\pmap{P_2}{2}$ (i.e., the garbage processes 
generated by $\pmap{\cdot}{2}$) 
could well be more prominent. This observation may be used to informally argue that $\pmap{\cdot}{1}$ is ``better than'' $\pmap{\cdot}{2}$ (or, alternatively, that \HOp is closer to \HO than to \sessp);
next, we explore a formal argument to substantiate this claim.

\paragraph{Formal Comparison: Labelled Transition Correspondence}
%In addition to preciseness we can develop one more encodability
%result for the translation of \HOp into \HO, which is
%the correspondence of the labelled transition reduction
%system. As we will show such a correspondence does not
%hold for the \HOp to \sessp translation.
To formally  distiguish between $\map{\cdot}_f^1$ and $\pmap{\cdot}{2}$
we introduce an extra encodability criterion: a form of operational correspondence 
for \emph{visible actions}. 
As already motivated above, 
we write $\ell_1, \ell_2$ to denote  
actions different from $\tau$,
and  $\hby{\ell}$ (resp. $\Hby{\ell}$) to denote a (weak) visible transition;
%with both visible and observable actions, denoted. % and $\hby{}_2$.
recall that $\mapa{\cdot}$ stands for a mapping 
on action labels.

\begin{definition}[Labelled Correspondence / Tight Encodings]%\rm
\label{def:lopco}
       Consider typed calculi $\tyl{L}_1$ and  $\tyl{L}_2$, defined as 
        $\tyl{L}_1=\calc{\CAL_1}{{\cal{T}}_1}{\hby{{~}}_1}{\wb_1}{\proves_1}$
       and $\tyl{L}_2=\calc{\CAL_2}{{\cal{T}}_2}{\hby{{~}}_2}{\wb_2}{\proves_2}$.
%       ($i=1,2$) be typed calculi. 
The encoding $\enco{\map{\cdot}, \mapt{\cdot}}: \tyl{L}_1 \to \tyl{L}_2$ satisfies
\emph{labelled operational correspondence}
if it satisfies:
	\begin{enumerate}[1.]
			\item
					If		$\stytraargi{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}{1}{1}$
					then	$\exists Q$, $\Delta''$, $\ell_2$ s.t. 
							(i)~$\wtytraargi{\mapt{\Gamma}}{\ell_2}{\mapt{\Delta}}{\map{P}}{\mapt{\Delta''}}{Q}{2}{2}$;  \\
							(ii)~$\ell_2 = \mapa{\ell_1}$; 
							(iii)~${\mapt{\Gamma}};{\mapt{\Delta''}}\proves_2 {Q}{\wb_2}{\mapt{\Delta'}}\proves_2 {\map{P'}}$.
				
			\item
					If		$\wtytraargi{\mapt{\Gamma}}{\ell_2}{\mapt{\Delta}}{\map{P}}{\mapt{\Delta'}}{Q}{2}{2}$
					then	$\exists P'$, $\Delta''$, $\ell_1$ s.t. 
							(i)~$\stytraargi{\Gamma}{\ell_1}{\Delta}{P}{\Delta''}{P'}{1}{1}$;
							(ii)~$\ell_2 = \mapa{\ell_1}$;
							(iii)~${\mapt{\Gamma}};{\mapt{\Delta''}}\proves_2 {\map{P'}}{\wb_2}{\mapt{\Delta'}}\proves_2 {Q}$.
	\end{enumerate}
A \emph{tight encoding} is a typed 
encoding 
which is precise (\defref{def:goodenc}) and that also satisfies 
labelled operational correspondence as above.
\end{definition}

This way, 
the notion of labelled correspondence complements/generalizes the notion of operational soundness and completeness 
given in \defref{def:ep}, which restricts to $\tau$-labelled transitions.
We may formally state that 
\HOp and \HO are more closely related than \HOp and~\sessp:
\begin{theorem}[\HO Tightly Encodes \HOp]\label{t:tight}
While the encoding of \HOp into \HO (\defref{d:enc:hopitoho}) is tight, the encoding of \HOp into \sessp (\defref{d:enc:hopitopi}) is not tight.
\end{theorem}

\begin{proof}[Proof (Sketch)]
The proof proceeds by showing that the encoding $\map{\cdot}^1_f$ enjoys 
labelled operational correspondence, whereas $\pmap{\cdot}{2}$ does not. 
Recall that a labeled operational correspondence for  $\pmap{\cdot}{1}$  has been
already 
stated in 
\propref{prop:op_corr_HOp_to_HO}.
The analog of \propref{prop:op_corr_HOp_to_HO} does not hold for the encoding  $\pmap{\cdot}{1}$  of \HOp into \sessp.
Consider the \HOp process:
\[
	\Gamma; \es; \Delta \proves \bout{s}{\abs{x}{P}} \inact \hastype \Proc \hby{\bactout{s}{\abs{x} P}} \es \proves \inact \not \hby{}
\]
with $\abs{x}{P}$ being a linear value.
We translate it into a \sessp process:
\[\tmap{\Gamma}{2}; \es; \tmap{\Delta}{2} \proves \newsp{a}{\bout{s}{a} \inact \Par \binp{a}{y} \binp{y}{x} P} \hastype \Proc
	 \hby{\bactout{s}{a}} \Delta' \proves \binp{a}{y} \binp{y}{x} P \hastype \Proc
\hby{\bactinp{a}{V}} \dots
\]
The resulting processes have a mismatch both in the typing
environment ($\Delta' \not= \tmap{\es}{2}$)
and in the actions that they can %the two processes can
subsequently observe: the first process
cannot perform any action, while the second process
can perform actions of the encoding of $\abs{x}{P}$.
 %\qed
\end{proof}

%Consider the following mapping:
%\[
%	\begin{array}{rclcrcl}
%		\mapa{\news{\tilde{m_1}}\bactout{n}{m}}^{1}	&\defeq&	\news{\tilde{m_1}}\bactout{n}{\abs{z}{\,\binp{z}{x} \appl{x}{m}} }
%		& &
%		\mapa{\bactinp{n}{m}}^{1}			&\defeq&	\bactinp{n}{\abs{z}{\,\binp{z}{x} \appl{x}{m}} }
%		\\
%		\mapa{\news{\tilde{m}}\bactout{n}{\abs{x}{P}}}^{1} &\defeq& \news{\tilde{m}}\bactout{n}{\abs{x}{\pmapp{P}{1}{\es}}}
%		& &
%		\mapa{\bactinp{n}{\abs{x}{P}}}^{1} &\defeq& \bactinp{n}{\abs{x}{\pmapp{P}{1}{\es}}}
%		\\
%		\mapa{\bactsel{n}{l} }^{1} &\defeq& \bactsel{n}{l} 
%		& &
%		\mapa{\bactbra{n}{l} }^{1} &\defeq& \bactbra{n}{l} 
%%		\\
%%		\mapa{\tau}^{1} &\defeq& \tau
%	\end{array}
%\]
%
%
%
%Then the following result, a complement of \propref{prop:op_corr_HOp_to_HO}, holds:
%
%\begin{proposition}[Labelled Transition Correspondence, \HOp into \HO]
%	\label{prop:lts_corr_HOp_to_HO}
%	Let $P$ be an \HOp process.
%	If $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then:
%%
%	\begin{enumerate}[1.]
%		\item
%			Suppose $\horel{\Gamma}{\Delta}{P}{\hby{\ell_1}}{\Delta'}{P'}$. Then we have:
%%
%			\begin{enumerate}[a)]
%				\item
%					If $\ell_1 \in \set{\news{\tilde{m}}\bactout{n}{m}, \,\news{\tilde{m}}\bactout{n}{\abs{x}Q}, \,\bactsel{s}{l}, \,\bactbra{s}{l}}$
%					then $\exists \ell_2$ s.t. \\
%					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\ell_2}}{\tmap{\Delta'}{1}}{\pmapp{P'}{1}{f}}$
%					and $\ell_2 = \mapa{\ell_1}^{1}$.
%			
%				\item
%					If $\ell_1 = \bactinp{n}{\abs{y}Q}$ and
%					$P' = P_0 \subst{\abs{y}Q}{x}$
%					then $\exists \ell_2$ s.t. \\
%					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\ell_2}}{\tmap{\Delta'}{1}}{\pmapp{P_0}{1}{f}\subst{\abs{y}\pmapp{Q}{1}{\emptyset}}{x}}$
%					and $\ell_2 = \mapa{\ell_1}^{1}$.
%			
%				\item
%					If $\ell_1 = \bactinp{n}{m}$
%					and 
%					$P' = P_0 \subst{m}{x}$
%					then $\exists \ell_2$, $R$ s.t. 
%					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\ell_2}}{\tmap{\Delta'}{1}}{R}$, \\
%					with $\ell_2 = \mapa{\ell_1}^{1}$, 
%					and
%					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta'}{1}}{R}{\hby{\btau} \hby{\stau} \hby{\btau}}
%					{\tmap{\Delta'}{1}}{\pmapp{P_0}{1}{f}\subst{m}{x}}$.
%						
%%				\item
%%					If $\ell_1 = \tau$
%%					and $P' \scong \newsp{\tilde{m}}{P_1 \Par P_2\subst{m}{x}}$
%%					then $\exists R$ s.t. \\
%%					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\tau}}{\mapt{\Delta}^{1}}{\newsp{\tilde{m}}{\pmapp{P_1}{1}{f} \Par R}}$,
%%					and\\ 
%%					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\newsp{\tilde{m}}{\pmapp{P_1}{1}{f} \Par R}}{\hby{\btau} \hby{\stau} \hby{\btau}}
%%					{\mapt{\Delta}^{1}}{\newsp{\tilde{m}}{\pmapp{P_1}{1}{f} \Par \pmapp{P_2}{1}{f}\subst{m}{x}}}$.
%%			
%%				\item
%%					If $\ell_1 = \tau$
%%					and $P' \scong \newsp{\tilde{m}}{P_1 \Par P_2 \subst{\abs{y}Q}{x}}$
%%					then \\
%%					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\tau}}
%%					{\tmap{\Delta_1}{1}}{\newsp{\tilde{m}}{\pmapp{P_1}{1}{f}\Par \pmapp{P_2}{1}{f}\subst{\abs{y}\pmapp{Q}{1}{\emptyset}}{x}}}$.
%%			
%%				\item
%%					If $\ell_1 = \tau$
%%					and $P' \not\scong \newsp{\tilde{m}}{P_1 \Par P_2 \subst{m}{x}} \land P' \not\scong \newsp{\tilde{m}}{P_1 \Par P_2\subst{\abs{y}Q}{x}}$
%%					then \\
%%					$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\tau}}{\tmap{\Delta'_1}{1}}{ \pmapp{P'}{1}{f}}$.
%			\end{enumerate}
%			
%		\item	Suppose $\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{\pmapp{P}{1}{f}}{\hby{\ell_2}}{\tmap{\Delta'}{1}}{Q}$.
%			Then we have:
%%
%			\begin{enumerate}[a)]
%				\item 
%					If $\ell_2 \in
%					\set{\news{\tilde{m}}\bactout{n}{\abs{z}{\,\binp{z}{x} (\appl{x}{m})}}, \,\news{\tilde{m}} \bactout{n}{\abs{x}{R}}, \,\bactsel{s}{l}, \,\bactbra{s}{l}}$
%					then $\exists \ell_1, P'$ s.t. \\
%					$\horel{\Gamma}{\Delta}{P}{\hby{\ell_1}}{\Delta'}{P'}$, 
%					$\ell_1 = \mapa{\ell_2}^{1}$, 
%					and
%					$Q = \pmapp{P'}{1}{f}$.
%			
%				\item 
%					If $\ell_2 = \bactinp{n}{\abs{y} R}$ %(with $R \neq \binp{y}{x} \appl{x}{m}$)
%					then either:
%%
%					\begin{enumerate}[(i)]
%						\item	$\exists \ell_1, x, P', P''$ s.t. \\
%							$\horel{\Gamma}{\Delta}{P}{\hby{\ell_1}}{\Delta'}{P' \subst{\abs{y}P''}{x}}$, 
%							$\ell_1 = \mapa{\ell_2}^{1}$, $\pmapp{P''}{1}{\es} = R$, and $Q = \pmapp{P'}{1}{f}$.
%
%						\item	$R \scong \binp{y}{x} (\appl{x}{m})$ and 
%							$\exists \ell_1, z, P'$ s.t. 
%							$\horel{\Gamma}{\Delta}{P}{\hby{\ell_1}}{\Delta'}{P' \subst{m}{z}}$, \\
%							$\ell_1 = \mapa{\ell_2}^{1}$,
%							and 
%							$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta'}{1}}{Q}{\hby{\btau} \hby{\stau} \hby{\btau}}{\tmap{\Delta''}{1}}{\pmapp{P'\subst{m}{z}}{1}{f}}$
%					\end{enumerate}
%			
%%				\item 
%%					If $\ell_2 = \tau$ 
%%					then $\Delta' = \Delta$ and 
%%					either
%%%
%%					\begin{enumerate}[(i)]
%%						\item	$\exists P'$ s.t. 
%%							$\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta}{P'}$,
%%							and $Q = \map{P'}^{1}_f$.	
%%
%%						\item
%%							$\exists P_1, P_2, x, m, Q'$ s.t. 
%%							$\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta}{\newsp{\tilde{m}}{P_1 \Par P_2\subst{m}{x}} }$, and\\
%%							$\horel{\tmap{\Gamma}{1}}{\tmap{\Delta}{1}}{Q}{\hby{\btau} \hby{\stau} \hby{\btau}}{\tmap{\Delta}{1}}{\pmapp{P_1}{1}{f} \Par \pmapp{P_2\subst{m}{x}}{1}{f}}$ 
%%%							$Q = \map{P_1}^{1}_f \Par Q'$, where $Q'  \Hby{} $.
%%
%%%						\item $\exists P_1, P_2, x, R$ s.t. 
%%%						$\stytra{ \Gamma }{\tau}{ \Delta }{ P}{ \Delta}{ \news{\tilde{m}}(P_1 \Par P_2\subst{\abs{y}R}{x}) }$, and 
%%%						$Q = \map{\news{\tilde{m}}(P_1 \Par P_2\subst{\abs{y}R}{x})}^{1}_f$.
%%			\end{enumerate}
%		    \end{enumerate}
%		    
%%		\item   
%%			If  $\wtytra{\mapt{\Gamma}^{1}}{\ell_2}{\mapt{\Delta}^{1}}{\pmapp{P}{1}{f}}{\mapt{\Delta'}^{1}}{Q}$
%%			then $\exists \ell_1, P'$ s.t.  \\
%%			(i)~$\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$,
%%			(ii)~$\ell_2 = \mapa{\ell_1}^{1}$, 
%%			(iii)~$\wbb{\mapt{\Gamma}^{1}}{\ell}{\mapt{\Delta'}^{1}}{\pmapp{P'}{1}{f}}{\mapt{\Delta'}^{1}}{Q}$.
%	\end{enumerate}
%\end{proposition}

%The analog of \propref{prop:lts_corr_HOp_to_HO} does not hold for the encoding of \HOp into \sessp.
%Consider the \HOp process:
%\[
%	\Gamma; \es; \Delta \proves \bout{s}{\abs{x}{P}} \inact \hastype \Proc \hby{\bactout{s}{\abs{x} P}} \es \proves \inact \not \hby{}
%\]
%with $\abs{x}{P}$ being a linear value.
%We translate it into a \sessp process:
%\[\tmap{\Gamma}{2}; \es; \tmap{\Delta}{2} \proves \newsp{a}{\bout{s}{a} \inact \Par \binp{a}{y} \binp{y}{x} P} \hastype \Proc
%	 \hby{\bactout{s}{a}} \Delta' \proves \binp{a}{y} \binp{y}{x} P \hastype \Proc
%\hby{\bactinp{a}{V}} \dots
%\]
%
%%\begin{eqnarray*}
%%	&&\tmap{\Gamma}{2}; \es; \tmap{\Delta}{2} \proves \newsp{a}{\bout{s}{a} \inact \Par \binp{a}{y} \binp{y}{x} P} \hastype \Proc\\
%%	&&\hby{\bactout{s}{a}}\\
%%	&&\Delta' \proves \binp{a}{y} \binp{y}{x} P \hastype \Proc\\
%%	&&\hby{\bactinp{a}{V}} \dots
%%\end{eqnarray*}
%
%%\noi 
%The resulting processes have a mismatch both in the typing
%environment ($\Delta' \not= \tmap{\es}{2}$)
%and in the actions that they can %the two processes can
%subsequently observe: the first process
%cannot perform any action, while the second process
%can perform actions of the encoding of $\abs{x}{P}$.



\subsection{A Negative Result}
\label{ss:negative}
%\input{negative}

As most session calculi, 
\HOp includes communication on both shared and linear names.
Shared names enable non deterministic, unrestricted behaviour; 
linear names represent deterministic communication structures.
The expressiveness of shared names is also illustrated by our 
encoding from \HOp into \sessp (\figref{f:enc:ho_to_sessp}).
%Shared and linear names are fundamentally different; still, to the best of our knowledge,
%the status of shared communication, in terms of expressiveness, has not been formalized for session calculi.
This result begs the question: 
%\dk{can we further encode the replicated triggers in the encoding from \HOp to \HO using only session names?}
can we represent  interaction along shared names using linear names only?
%are shared names truly indispensable for communication, or could they
%be encoded using linear communication?
It turns out that shared names strictly add expressiveness to \HOp:
next we prove
the non existence of a minimal encoding 
of interaction along shared names 
using linear names. % (see \appref{app:neg} for details of the proof).
%for their behavior cannot be represented using purely deterministic processes.
%To this end, we show the non existence of a minimal encoding 
%(cf.~\defref{def:goodenc}(ii))
%of shared name communication into linear 
%communication. 

%\smallskip 

\begin{theorem}%\rm
	\label{t:negative}
	There is no minimal encoding from
		$\sessp$ to $\HOp^{\minussh}$.
\end{theorem}

%\begin{proof}
%	The proof of \thmref{t:negative} relies on
%	%As described next, 
%	$\tau$-inertness (\lemref{lem:tau_inert})
%	%is critical in the proof.
%	%Recall that minimal encodings preserve barbs 
%	and barb preservation~(\propref{p:barbpres}).
%	See details in \appref{app:neg}.
%\end{proof}

\begin{proof}
	Assume, towards a contradiction, that such a typed minimal encoding indeed exists. 
	Recall that a minimal encoding is syntax preserving,
	barb preserving, 
	and operationally complete (cf.~\defref{def:goodenc}).
	Consider the $\sessp$ process
	%
	\[
		P = \breq{a}{s} \inact \Par \bacc{a}{x} \bsel{n}{l_1} \inact \Par \bacc{a}{x} \bsel{m}{l_2} \inact \qquad \text{(with $n \neq m$)}
	\]
	%
	\noi such that 
	$\Gamma; \es; \Delta \proves P \hastype \Proc$.
	From process $P$ we have one of the following: %We then have both
	%
	\begin{eqnarray}
		& & \horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{\bsel{n}{l_1} \inact \Par \bacc{a}{x} \bsel{m}{l_2} \inact = P_1} \label{eq:nn3} \\
		& & \horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{\bsel{m}{l_2} \inact \Par \bacc{a}{x} \bsel{n}{l_1} \inact = P_2} \label{eq:nn4}
	\end{eqnarray}
	%
	Thus, by definition of typed barb (cf. \defref{d:barb}) we  have:
	%
	\begin{eqnarray}
		\Gamma; \Delta' \proves P_1 \barb{n} & \land & 
		\Gamma; \Delta' \proves P_1 \nbarb{m} \label{eq:nn1} \\
		\Gamma; \Delta' \proves P_2 \nbarb{n}  & \land & 
		 \Gamma; \Delta' \proves P_2 \barb{m}
		\label{eq:nn2}
	\end{eqnarray}
	%
	Consider now the $\HOp^{\minussh}$ process $\map{P}$.
	% = 
	% \map{\breq{a}{s} \inact} \Par \map{\bacc{a}{x} \bsel{n}{l_1} \inact} \Par \map{\bacc{a}{x} \bsel{m}{l_2}}$.
	By our assumption of operational completeness 
	(\defref{def:ep}-2(a)), 
	from \eqref{eq:nn3} with \eqref{eq:nn4}
	we infer that
	there exist $\HOp^{\minussh}$ processes $S_1$ and $S_2$ such that:
	%we have both:
	\begin{eqnarray}
		& & \horel{\mapt{\Gamma}}{\mapt{\Delta}}{\map{P}}{\Hby{\stau}}{\mapt{\Delta'}}{S_1 \WB \map{P_1}} \label{eq:n1} \\
		& & \horel{\mapt{\Gamma}}{\mapt{\Delta}}{\map{P}}{\Hby{\stau}}{\mapt{\Delta'}}{S_2 \WB \map{P_2}} \label{eq:n2}
		%\map{P} & \Hby{} &  S_1 \WB \map{P_1} \\
		%s\map{P} & \Hby{} & S_2 \WB \map{P_2}
	\end{eqnarray}
	By our assumption of barb preservation, 
	from \eqref{eq:nn1} with \eqref{eq:nn2}
	we infer: 
	%
	\begin{eqnarray}
		\mapt{\Gamma}; \mapt{\Delta'} \proves \map{P_1} \Barb{n} & \land & 
		\mapt{\Gamma}; \mapt{\Delta'} \proves \map{P_1} \nBarb{m} \label{eq:n3} \\
		\mapt{\Gamma}; \mapt{\Delta'} \proves \map{P_2} \nBarb{n}   & \land & 
		\mapt{\Gamma}; \mapt{\Delta'} \proves \map{P_2} \Barb{m} \label{eq:n4}
	\end{eqnarray}
	%
	By definition of $\WB$, 
	by combining~\eqref{eq:n1} with~\eqref{eq:n3}
	and~\eqref{eq:n2} with~\eqref{eq:n4}, we infer barbs for $S_1$ and $S_2$:
	\begin{eqnarray}
		\mapt{\Gamma}; \mapt{\Delta'} \proves S_1 \Barb{n} & \land & 
		\mapt{\Gamma}; \mapt{\Delta'} \proves S_1 \nBarb{m} \label{eq:n5} \\
		\mapt{\Gamma}; \mapt{\Delta'} \proves S_2 \Barb{m} & \land & 
		\mapt{\Gamma}; \mapt{\Delta'} \proves S_2 \nBarb{n} \label{eq:n6}
	\end{eqnarray}
	That is, $S_1$ and $\map{P_1}$ 
	(resp. $S_2$ and $\map{P_2}$)
	have the same barbs.
	Now, by $\tau$-inertness (\propref{lem:tau_inert}), we have both 
	\begin{eqnarray}
		& & \horel{\mapt{\Gamma}}{\mapt{\Delta'}}{S_1}{\WB}{\mapt{\Delta}}{\map{P}} \label{eq:n7} \\
		& & \horel{\mapt{\Gamma}}{\mapt{\Delta'}}{S_2}{\WB}{\mapt{\Delta}}{\map{P}} \label{eq:n8}
	\end{eqnarray}
	Combining~\eqref{eq:n7} with~\eqref{eq:n8}, by transitivity of $\WB$,
	we infer
	\begin{equation}
		\horel{\mapt{\Gamma}}{\mapt{\Delta'}}{S_1}{\WB}{\mapt{\Delta'}}{S_2} \label{eq:n9}
	\end{equation}
	In turn, from~\eqref{eq:n9}
	we infer that 
	it must be the case that:
	\begin{eqnarray*}
		\mapt{\Gamma}; \mapt{\Delta'} \proves \map{P_1} \Barb{n} & \land & 
		\mapt{\Gamma}; \mapt{\Delta'} \proves \map{P_1} \Barb{m} \label{eq:n10} \\
		\mapt{\Gamma}; \mapt{\Delta'} \proves \map{P_2} \Barb{n}  & \land & 
		 \mapt{\Gamma}; \mapt{\Delta'} \proves \map{P_2} \Barb{m} \label{eq:n11}
	\end{eqnarray*}
	which clearly contradict \eqref{eq:n3} and \eqref{eq:n4} above. 
	We therefore conclude that a minimal encoding from $\sessp$ to $\HOp^{\minussh}$ does not exist.
	 %\qed
\end{proof}

We then have:
\smallskip 
\NY{
\begin{corollary}
Let $\CAL_1,\CAL_2\in \{ \HOp, \HO, \sessp\}$.  
\begin{enumerate}[(a)]
\item 
There is no minimal encoding from  
	$\tyl{L}_{\CAL_1}$ 
	into
		$\tyl{L}_{\CAL_2^{-\mathsf{sh}}}$.
		
\item There is a precise encoding 
of
$\tyl{L}_{\CAL_1^{-\mathsf{sh}}}$ 
in $\tyl{L}_{\CAL_2^{-\mathsf{sh}}}$.
\end{enumerate}
\end{corollary}
\begin{proof}
Part (a) is immediate from~\thmref{t:negative}.
Part (b) follows from the definitions of the 
typed encodings of \HOp into \HO and into \sessp
	(cf. \defref{d:enc:hopitoho} and~\ref{d:enc:hopitopi}) 
	and 
	from the preciseness results for such encodings
	(cf. \propref{f:enc:hopitoho} and~\ref{f:enc:hotopi}).
\end{proof}
}


\begin{comment}
\begin{IEEEproof}[Proof]
	Let $\horel{\Gamma_1}{\Delta_1}{P_1}{\not\wb}{\Delta_2}{P_2}$
	with $P = \breq{a}{s} \inact \Par \bacc{a}{x} P_1 \Par \bacc{a}{x} P_2$ and	let $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$.
	Assume also a encoding
	$\enc{\cdot}{\cdot}: \sessp \longrightarrow \HOp^{\minussh}$
is minimum. 
	From operational correspondence we obtain:
\[
\begin{array}{rcl}
		P \red P_1 \Par \bacc{a}{x} P_2 &\textrm{implies}& \map{P} \red \map{P_1 \Par \bacc{a}{x} P_2}\\
		P \red P_2 \Par \bacc{a}{x} P_1 &\textrm{implies}& \map{P} \red \map{P_2 \Par \bacc{a}{x} P_1}
\end{array}
\]
	From the fact that
	$\horel{\Gamma_1}{\Delta_1}{P_1}{\not\wb}{\Delta_2}{P_2}$
	we can derive that
%
	\[
		\horel{\Gamma_1'}{\Delta_1'}{P_1 \Par \bacc{a}{x} P_2}{\not\wb}{\Delta_2'}{P_2 \Par \bacc{a}{x} P_1}
	\]
%
	From \lemref{lem:tau_inert}(2) we know that
%
\[
\begin{array}{rcl}
		\horel{\mapt{\Gamma}}{\mapt{\Delta}}{\map{P}}{\wb}{\mapt{\Delta_1'}}{\map{P_1 \Par \bacc{a}{x} P_2}}\wb 
{\mapt{\Delta_2'}}\proves {\map{P_2 \Par \bacc{a}{x} P_1}}
\end{array}
\]
%
	%\noi 
	thus
$\horel{\mapt{\Gamma}}{\mapt{\Delta_1'}}{\map{P_1 \Par \bacc{a}{x} P_2}}{\wb}{\mapt{\Delta_2'}}{\map{P_2 \Par \bacc{a}{x} P_1}}$, 
%
	which contradicts the assumption. 
%	so there is no mapping $\map{\cdot}: \pHO \longrightarrow \spi$ that enjoys
%	the operational correspondence and full abstraction properties.
\end{IEEEproof}
\end{comment}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Extensions: \HOp with Higher-Order Abstractions and Polyadicity}
\label{sec:extension}
%\input{HOp_extensions}

We now extend \HOp in two orthogonal ways: %to define two more higher-order
%process calculi:
\HOpp  extends   \HOp with higher-order applications/abstractions, while
\PHOp   extends  \HOp
with polyadicity.
In both cases, we detail the
required modifications in syntax and types.
By combining \HOpp and \PHOp into a single calculus we obtain \PHOpp:
the extension of \HOp allows \emph{both} higher-order
abstractions/aplications and polyadicity.

We present precise encodings of \HOpp and \PHOp into \HOp.
We then use the encodings of \HOp into \HO and \sessp, given in the previous section, 
together with 
encoding composability (\propref{pro:composition}) to relate \HO and \sessp with the super-calculus \PHOpp, which subsumes
both \HOpp and \PHOp.


%\subsection{\HOp with Higher-Order Abstractions ($\HOpp$) and 
%with Polyadicity (\PHOp).
%}
%%\label{subsec:hop}
%We first introduce \HOpp, the  extension of \HOp with higher-order abstractions and applications.
%This is the calculus that we studied in~\cite{characteristic_bis}. The syntax of \HOpp is obtained 
%from  \figref{fig:syntax} by extending
%$\appl{V}{u}$ to $\appl{V}{W}$, where  $W$ is a higher-order value. 
%As for the reduction semantics, we keep the rules in \figref{fig:reduction}, except for 
% $\orule{App}$ which is replaced by 
%$$
%	\appl{(\abs{x}{P})}{V} \red P \subst{V}{x}
%$$
%The syntax of types is modified as follows: %changes to include: 
%$
%		L \bnfis \shot{U} \bnfbar \lhot{U}.
%$
%These types can be easily accommodated in the type system 
%%in \figref{fig:typerulesmy}: 
%in \secref{sec:types}:
%we replace $C$ by $U$ in \trule{Abs} and $C$ by $U'$ in \trule{App}. Subject
%reduction~(\thmref{t:sr}) holds for \HOpp (cf.~\cite{characteristic_bis})
%
%%\subsection{\HOp with Polyadic Communication: \PHOp}
%%
%%\noi Embeddings of polyadic name passing into monadic name passing are
%%well-studied. % in the literature. 
%%Using a linear typing, precise
%%encodings (including full abstraction) can be obtained~\cite{Yoshida96}.
%The calculus  
%$\PHOp$ 
%extends $\HOp$ 
%with polyadic name passing $\tilde{n}$ and $\abs{\tilde{x}}{Q}$ in the syntax 
%of values $V$. 
%The operational semantics is kept unchanged, with the expected use of the simultaneous substitution $\subst{\tilde{V}}{\tilde{x}}$.
%The type syntax is extended to: 
%%
%\begin{center}
%	\begin{tabular}{c}
%	$	L \bnfis \shot{\tilde{C}} \bnfbar \lhot{\tilde{C}}
%		\quad\quad
%		S \bnfis  \btout{\tilde{U}} S \bnfbar \btinp{\tilde{U}} S \bnfbar \cdots$
%	\end{tabular}
%\end{center}
%%
%As in \cite{tlca07,MostrousY15},
%the type system for \PHOp 
%disallows a shared name that directly carries polyadic
%shared names.
%
%By combining \HOpp and \PHOp into a single calculus we obtain \PHOpp:
%the extension of \HOp allows \emph{both} higher-order
%abstractions/aplications and polyadicity.


%\input{extension}
\subsection{Precise Encoding of $\HOpp$ into $\HOp$}
We first introduce \HOpp, the  extension of \HOp with higher-order abstractions and applications.
This is the calculus whose (typed) behavioral theory we studied in~\cite{characteristic_bis,KouzapasPY17}. The syntax of \HOpp is obtained 
from  \figref{fig:syntax} by letting 
$\appl{V}{u}$ to $\appl{V}{W}$ in the syntax of processes, where  $W$ is a higher-order value. 
As for the reduction semantics, we keep the rules in \figref{fig:reduction}, except for 
 Rule~$\orule{App}$ which is replaced by 
$$
	\appl{(\abs{x}{P})}{V} \red P \subst{V}{x}
$$

\begin{example}\label{ex:hopp}
The following is a simple \HOpp process with its corresponding reductions:
\begin{align*}
\bout{s}{\abs{x}{Q}}\inact  \Par \binp{\dual{s}}{y}(\appl{\abs{z}{(\appl{z}{s_1}})}{y}) 
& \red 
\appl{(\abs{z}{(\appl{z}{s_1}}))}{(\abs{x}{Q})}
\\
& \red 
\appl{(\abs{x}{Q})}{s_1}
\\
& \red Q\subst{s_1}{x}
\end{align*}
Above, the additional expressivity of \HOpp with respect to \HOp is in the ability of applying a function such as 
$\abs{z}{(\appl{z}{s_1}})$ to an argument such as $\abs{x}{Q}$, which is not a name but another function.
\end{example}


		The syntax of types in \figref{f:types} is modified as follows: %changes to include: 
$$
		L \bnfis \shot{U} \bnfbar \lhot{U}.
$$
These types can be easily accommodated in the type system 
%in \figref{fig:typerulesmy}: 
in \secref{sec:types}:
we replace $C$ by $U$ in Rule~\trule{Abs} and $C$ by $U'$ in Rule~\trule{App}. 
With these extensions, subject
reduction~(\thmref{t:sr}) holds for \HOpp (cf.~\cite{characteristic_bis})

%\noi 
We give  %two extensions of \HOp: 
an encoding of \HOpp into \HOp and show that it is precise. 
We may then use encoding composition (\propref{pro:composition}) to encode
\HOpp into \HO and \sessp.
We consider the following 
typed calculus (cf.~\defref{d:tcalculus}):
$$\tyl{L}_{\HOpp}=\calc{\HOpp}{{\cal{T}}_4}{\hby{\ell}}{\hwb}{\proves}$$
where 
	${\cal{T}}_4$ is a set of types of $\HOpp$;  
the typing $\proves$ is defined in 
%\figref{fig:typerulesmy} 
\secref{sec:types}
with Rules \trule{Abs} and \trule{App} modified as explained above.
Formally, the set   
$\mathcal{A}_\HOpp$ coincides with $\mathcal{A}_{\HOp}$, for the syntax of values $V$ is the same in both languages.
However, by considering type-annotated values (cf. \remref{r:types}),
we have that   $\mathcal{A}_\HOpp$
includes output and input actions of the form
$\news{\tilde{m}} \bactout{n}{\abs{\AT{x}{L}}{P}}$
and
${\bactinp{n}{\abs{\AT{x}{L}}{P}}}$, whereas $\mathcal{A}_{\HOp}$ includes only labels of the form
$\news{\tilde{m}} \bactout{n}{\abs{\AT{x}{C}}{P}}$
and
${\bactinp{n}{\abs{\AT{x}{C}}{P}}}$.

%\myparagraph{Syntax, Operational Semantics and Types.}
%\noi First, the syntax of \figref{fig:syntax} extends 
%$\appl{V}{u}$ to 
% $\appl{V}{W}$, including higher-order value $W$. 
%The rule $\appl{(\abs{x}{P})}{V} \red P \subst{V}{x}$
%replaces
%rule $\orule{App}$ in \figref{fig:reduction}.
%The syntax of types is modified as follows: %changes to include: 
%\begin{center}
%\begin{tabular}{c}
%$L \bnfis \shot{U} \bnfbar \lhot{U}$
%\end{tabular}
%\end{center}
%These types can be easily accommodated in the type system:
% in \figref{fig:typerulesmy}, 
%we replace $C$ by $U$ in \trule{Abs} and $C$ by $U'$ in \trule{App}.
%\smallskip 
%
%\myparagraph{Behavioural Semantics.}
%Labels remain the same. Rule $\ltsrule{App}$ in the untyped LTS
%(\figref{fig:untyped_LTS}) 
%is replaced with rule $\appl{(\abs{x}{P})}{V} \by{\tau} P \subst{V}{x}$.
%\defref{def:char} (characteristic processes) is extended with  
%${\mapchar{\shot{U}}{x}} \defeq\! \mapchar{\lhot{U}}{x} \defeq\! {\appl{x}{\omapchar{U}}}$ and 
%${\omapchar{\shot{U}}} \defeq {\omapchar{\lhot{U}}} \!\!\defeq\!\! \abs{x}{\mapchar{U}{x}}$. 
%We can then use the same definitions for $\cong$, $\wbc$, $\hwb$ and $\fwb$. 
%\smallskip 

%\paragraph{Encoding \HOpp into \HOp} 
\begin{definition}
[Typed Encoding of \HOpp into \HOp]
\label{d:enc:hopptohop}
The typed encoding
$\enco{\map{\cdot}^{3}, \mapt{\cdot}^{3}}: \tyl{L}_\HOpp \to \tyl{L}_{\HOp}$ is defined
in \figref{f:enc:hopip_to_hopi}.
\end{definition}

We consider mappings for terms and types, denoted $\map{\cdot}^{3}$ and $\mapt{\cdot}^{3}$, respectively.
Since now functions can be applied to (higher-order) values, we have also an auxiliary mapping on values, denoted $\auxmap{\cdot}{3}$. 
We illustrate the essence of these mappings by means of an example.

\begin{example}
We translate the simple process from \exref{ex:hopp}, underlining the parts of the translation which are expanded/modified from one line to the following:
\begin{align*}
& \map{\bout{s}{\abs{x}{Q}}\inact  \Par \binp{\dual{s}}{y}(\appl{\abs{z}{(\appl{z}{s_1}})}{y})}^{3} 
\\
=~ &
\bout{s}{\underline{\auxmap{\abs{x}{Q}}{3}}}\underline{\map{\inact}^{3}}  \Par \binp{\dual{s}}{y}\underline{\map{(\appl{\abs{z}{(\appl{z}{s_1}})}{y})}^{3}} 
\\
=~ & \bout{s}{\abs{w}{\binp{w}{x} \pmap{Q}{3}}} \inact   \Par \binp{\dual{s}}{y}\newsp{s_0}{\binp{s_0}{z} \underline{\pmap{(\appl{z}{s_1})}{3}} \Par  \bout{\dual{s_0}}{\underline{\auxmap{y}{3}}} \inact}
\\
=~ & \bout{s}{\abs{w}{\binp{w}{x} \pmap{Q}{3}}}\inact  \Par \binp{\dual{s}}{y}\newsp{s_0}{\binp{s_0}{z} \newsp{s_2}{\appl{z}{s_2} \Par \bout{\dual{s_2}}{\underline{\auxmap{s_1}{3}}} \inact} \Par  \bout{\dual{s_0}}{y} \inact}
\\
=~ & \bout{s}{\abs{w}{\binp{w}{x} \pmap{Q}{3}}}\inact  \Par \binp{\dual{s}}{y}\newsp{s_0}{\binp{s_0}{z} \newsp{s_2}{\appl{z}{s_2} \Par \bout{\dual{s_2}}{s_1} \inact} \Par  \bout{\dual{s_0}}{y} \inact}
\\
\red~ & \inact  \Par \newsp{s_0}{\binp{s_0}{z} \newsp{s_2}{\appl{z}{s_2} \Par \bout{\dual{s_2}}{s_1} \inact} \Par  \bout{\dual{s_0}}{\abs{w}{\binp{w}{x} \pmap{Q}{3}}} \inact}
\\
\red~ & \inact  \Par \newsp{s_2}{\appl{(\abs{w}{\binp{w}{x} \pmap{Q}{3}})}{s_2} \Par \bout{\dual{s_2}}{s_1} \inact} \Par \inact
\\
\red~ & \inact  \Par \newsp{s_2}{\binp{s_2}{x} \pmap{Q}{3} \Par \bout{\dual{s_2}}{s_1} \inact} \Par \inact
\\ 
\red\scong~ & \pmap{Q}{3}\subst{s_1}{x}
\end{align*}
\end{example}
This typed encoding satisfies the following properties:
{
\begin{proposition}[\HOpp into \HOp: Type Preservation]
\label{prop:typepres_HOpp_to_HOp}
The encoding from $\tyl{L}_{\HOpp}$ into $\tyl{L}_{\HOp}$ (cf. \figref{f:enc:hopip_to_hopi})
is type preserving.
\end{proposition}}

\begin{proof}
	By induction on the inference of 
	$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$.
	See \propref{app:prop:typepres_HOpp_to_HOp} in \appref{app:HOpp_to_HOp}.
	 %\qed
	\end{proof}
	
%HERE WE NEED TO ADD AN EXCERPT OF \propref{app:prop:op_corr_HOpp_to_HOp}, BUT WE NEED TO FIX MACROS FIRST.

%\begin{proposition}[Operational Correspondence: From \HOpp to \HOp - Excerpt] %\myrm
%	\label{prop:op_corr_HOpp_to_HOp}
%	Let $P$ be an \HOpp process such that $\Gamma; \es; \Delta \proves P$.
%	\begin{enumerate}[1.]
%		\item	Completeness: 
%			$\horel{\Gamma}{\Delta}{P}{\hby{\ell}}{\Delta'}{P'}$ implies
%			\begin{enumerate}[a)]
%%				\item	If $\ell \in \set{\news{\tilde{m}} \bactout{n}{\abs{x}{Q}}, \bactinp{n}{\abs{x}{Q}}}$ then
%%%					$\exists l' $ such that
%%					$\horel{\tmap{\Gamma}{3}}{\tmap{\Delta}{3}}{\pmap{P}{3}}{\hby{\ell'}}
%%					{\tmap{\Delta'}{3}}{\pmap{P'}{3}}$ with $\mapa{\ell}^{3} = \ell'$.
%%				\item	If $\ell \notin \set{\news{\tilde{m}} \bactout{n}{\abs{x}{Q}}, \bactinp{n}{\abs{x}{Q}}, \tau}$ then
%%					$\horel{\tmap{\Gamma}{3}}{\tmap{\Delta}{3}}{\pmap{P}{3}}{\hby{\ell}}
%%					{\tmap{\Delta'}{3}}{\pmap{P'}{3}}$.
%%
%				\item	If $\ell = \btau$ then
%					$\horel{\tmap{\Gamma}{3}}{\tmap{\Delta}{3}}{\pmap{P}{3}}{\hby{\tau}}
%					{\Delta''}{R}$ and
%					$\horel{\tmap{\Gamma}{3}}{\tmap{\Delta'}{3}}{\pmap{P'}{3}}{\hwb}{\Delta''}{R}$, for some $R$;
%
%				\item	If $\ell = \tau$ and $\ell \not= \btau$ then %and $\hby{\ell}$ is not a \betatran then
%					$\horel{\tmap{\Gamma}{3}}{\tmap{\Delta}{3}}{\pmap{P}{3}}{\hby{\tau}}
%					{\tmap{\Delta'}{3}}{\pmap{P'}{3}}$.
%			\end{enumerate}
%
%		\item Soundness: $\horel{\tmap{\Gamma}{3}}{\tmap{\Delta}{3}}{\pmap{P}{3}}{\hby{\tau}}
%			{\tmap{\Delta''}{3}}{Q}$ implies either 
%%
%			\begin{enumerate}[a)]
%%				\item	If $\ell \in \set{\news{\tilde{m}} \bactout{n}{\abs{x}{Q}}, \bactinp{n}{\abs{x}{Q}}, \tau}$
%%					then
%%					$\horel{\Gamma}{\Delta}{P}{\hby{\ell'}}{\Delta'}{P'}$
%%%					and $\horel{\tmap{\Gamma}{3}}{\tmap{\Delta''}{3}}{Q}{\hby{\hat{\ell}}}{\tmap{\Delta'}{3}}{\pmap{P'}{3}}$
%%					with $\mapa{\ell'}^{3} = \ell$ and $Q \scong \pmap{P'}{3}$.
%%
%%				\item	If $\ell \notin \set{\news{\tilde{m}} \bactout{n}{\abs{x}{R}}, \bactinp{n}{\abs{x}{R}}, \tau}$
%%					then
%%					$\horel{\Gamma}{\Delta}{P}{\hby{\ell}}{\Delta'}{P'}$ and $Q \scong \pmap{P'}{3}$.
%%%					and $\horel{\tmap{\Gamma}{3}}{\tmap{\Delta''}{3}}{Q}{\hby{\hat{\ell}}}{\tmap{\Delta'}{3}}{\pmap{P'}{3}}$.
%%
%				\item	
%					$\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ with $Q \scong \pmap{P'}{3}$
%				\item 
%					$\horel{\Gamma}{\Delta}{P}{\hby{\btau}}{\Delta'}{P'}$ and
%					$\horel{\tmap{\Gamma}{3}}{\tmap{\Delta''}{3}}{Q}{\hby{\btau}}
%					{\tmap{\Delta''}{3}}{\pmap{P'}{3}}$.
%			\end{enumerate}
%	\end{enumerate}
%\end{proposition}


Before proving operational correspondence we
define a mapping on action labels:
%from $\mapa{\cdot}^{3}: \mathcal{A} \to \mathcal{A}$ where $\mathcal{A}$ is the set of labels of the relation $\hby{\ell}$:
\begin{definition}
Given 
the typed encoding
$\enco{\map{\cdot}^{3}, \mapt{\cdot}^{3}}: \tyl{L}_\HOpp \to \tyl{L}_{\HOp}$ (cf. \defref{d:enc:hopptohop}),
the mapping on actions $\mapa{\cdot}^{3}: \mathcal{A}_\HOpp \to \mathcal{A}_{\HOp}$  is defined as follows:
	\begin{align*}
		\mapa{\news{\tilde{m}} \bactout{n}{\abs{\AT{x}{L}}{P}}}^{3} 
		& \defeq
		\news{\tilde{m}} \bactout{n}{\abs{z}{\binp{z}{x} \pmap{P}{3}}}
		\\
		\mapa{\bactinp{n}{\abs{\AT{x}{L}}{P}}}^{3}
		& \defeq \bactinp{n}{\abs{z}{\binp{z}{x} \pmap{P}{3}}}
	\end{align*}
	and as an homomorphism for all other actions $\ell \in \mathcal{A}_\HOpp$.
\end{definition}

%We now state and prove a detailed version of the operational corresponce %in \defref{app:def:opc_strong}.

We may now state a labeled form of operational correspondence, as well as full abstraction:

\begin{proposition}[Operational Correspondence. From \HOpp to \HOp]%\myrm
	\label{prop:op_corr_HOpp_to_HOp}
	Let $\Gamma; \es; \Delta \proves P$.
	\begin{enumerate}
		\item	
			$\horel{\Gamma}{\Delta}{P}{\hby{\ell}}{\Delta'}{P'}$ implies
%
			\begin{enumerate}[a)]
				\item	If $\ell \in \set{\news{\tilde{m}} \bactout{n}{\abs{x}{Q}}, \bactinp{n}{\abs{x}{Q}}}$ then
%					$\exists l' $ such that
					$\horel{\tmap{\Gamma}{3}}{\tmap{\Delta}{3}}{\pmap{P}{3}}{\hby{\ell'}}
					{\tmap{\Delta'}{3}}{\pmap{P'}{3}}$ with $\mapa{\ell}^{3} = \ell'$.

%				\item	If $\ell = \bactinp{n}{\abs{x: C}{Q}}$ then
%					$\horel{\tmap{\Gamma}{3}}{\tmap{\Delta}{3}}{\pmap{P}{3}}{\hby{\bactinp{n}{\abs{x: C}{\pmap{Q}{3}}}}}
%					{\tmap{\Delta'}{3}}{\pmap{P'}{3}}$.
%
%				\item	If $\ell = \news{\tilde{m}} \bactout{n}{\abs{x: L}{Q}}$ then
%					$\horel{\tmap{\Gamma}{3}}{\tmap{\Delta}{3}}{\pmap{P}{3}}{\hby{\news{\tilde{m}} \bactout{n}{\abs{z}{\binp{z}{x} \pmap{Q}{3}}}}}
%					{\tmap{\Delta'}{3}}{\pmap{P'}{3}}$.
%
%				\item	If $\ell = \bactinp{n}{\abs{x: L}{Q}}$ then
%					$\horel{\tmap{\Gamma}{3}}{\tmap{\Delta}{3}}{\pmap{P}{3}}{\hby{\bactinp{n}{\abs{z}{\binp{z}{x} \pmap{Q}{3}}}}}
%					{\tmap{\Delta'}{3}}{\pmap{P'}{3}}$.

				\item	If $\ell \notin \set{\news{\tilde{m}} \bactout{n}{\abs{x}{Q}}, \bactinp{n}{\abs{x}{Q}}, \tau}$ then
					$\horel{\tmap{\Gamma}{3}}{\tmap{\Delta}{3}}{\pmap{P}{3}}{\hby{\ell}}
					{\tmap{\Delta'}{3}}{\pmap{P'}{3}}$.

				\item	If $\ell = \btau$ then
					$\horel{\tmap{\Gamma}{3}}{\tmap{\Delta}{3}}{\pmap{P}{3}}{\hby{\tau}}
					{\Delta''}{R}$ and
					$\horel{\tmap{\Gamma}{3}}{\tmap{\Delta'}{3}}{\pmap{P'}{3}}{\hwb}{\Delta''}{R}$, for some $R$.

				\item	If $\ell = \tau$ and $\ell \not= \btau$ then %and $\hby{\ell}$ is not a \betatran then
					$\horel{\tmap{\Gamma}{3}}{\tmap{\Delta}{3}}{\pmap{P}{3}}{\hby{\tau}}
					{\tmap{\Delta'}{3}}{\pmap{P'}{3}}$.
			\end{enumerate}

		\item	%Let $\Gamma; \es; \Delta \proves P$.
			$\horel{\tmap{\Gamma}{3}}{\tmap{\Delta}{3}}{\pmap{P}{3}}{\hby{\ell}}
			{\tmap{\Delta''}{3}}{Q}$ implies
%
			\begin{enumerate}[a)]
				\item	If $\ell \in \set{\news{\tilde{m}} \bactout{n}{\abs{x}{Q}}, \bactinp{n}{\abs{x}{Q}}}$
					then
					$\horel{\Gamma}{\Delta}{P}{\hby{\ell'}}{\Delta'}{P'}$
%					and $\horel{\tmap{\Gamma}{3}}{\tmap{\Delta''}{3}}{Q}{\hby{\hat{\ell}}}{\tmap{\Delta'}{3}}{\pmap{P'}{3}}$
					with $\mapa{\ell'}^{3} = \ell$ and $Q \scong \pmap{P'}{3}$.

				\item	If $\ell \notin \set{\news{\tilde{m}} \bactout{n}{\abs{x}{R}}, \bactinp{n}{\abs{x}{R}}, \tau}$
					then
					$\horel{\Gamma}{\Delta}{P}{\hby{\ell}}{\Delta'}{P'}$ and $Q \scong \pmap{P'}{3}$.
%					and $\horel{\tmap{\Gamma}{3}}{\tmap{\Delta''}{3}}{Q}{\hby{\hat{\ell}}}{\tmap{\Delta'}{3}}{\pmap{P'}{3}}$.

				\item	If $\ell = \tau$ then
					either
					$\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ with $Q \scong \pmap{P'}{3}$\\
					or
					$\horel{\Gamma}{\Delta}{P}{\hby{\btau}}{\Delta'}{P'}$ and
					$\horel{\tmap{\Gamma}{3}}{\tmap{\Delta''}{3}}{Q}{\hby{\btau}}
					{\tmap{\Delta''}{3}}{\pmap{P'}{3}}$.
			\end{enumerate}
	\end{enumerate}
\end{proposition}

\begin{proof}
	By transition induction.
	See \propref{app:prop:op_corr_HOpp_to_HOp} in \appref{app:HOpp_to_HOp}.
%	\qed
	\end{proof}


We may now have:

\begin{proposition}[Full Abstraction. From \HOpp to \HOp]%\myrm
	\label{prop:fulla_HOpp_to_HOp}
	Let $P, Q$ be \HOpp processes with $\Gamma; \es; \Delta_1 \proves P \hastype \Proc$ and 
	$\Gamma; \es; \Delta_2 \proves Q \hastype \Proc$. \\
	Then 
	$\horel{\Gamma}{\Delta_1}{P}{\hwb}{\Delta_2}{Q}$ if and only if $\horel{\tmap{\Gamma}{3}}{\tmap{\Delta_1}{3}}{\pmap{P}{3}}{\hwb}{\tmap{\Delta_2}{3}}{\pmap{Q}{3}}$
\end{proposition}

\begin{proof}
	By coinduction.
	See \propref{app:prop:fulla_HOpp_to_HOp} in \appref{app:HOpp_to_HOp}.
%	\qed
	\end{proof}

\input{figures/HOpp_to_HOp}

Using the above propositions,  
\thmsref{f:enc:hopitoho}
and 
\ref{f:enc:hotopi},
and \propref{pro:composition}, 
we derive the following: % theorem:

%\smallskip 

\begin{theorem}[Encoding \HOpp into~\HOp]
	\label{f:enc:hoppptohop}
	The encoding from $\tyl{L}_{\HOpp}$ into $\tyl{L}_{\HOp}$ (cf. \figref{f:enc:hopip_to_hopi})
	is precise. 
%	Hence, the encodings 
%	from $\tyl{L}_{\HOpp}$ to $\tyl{L}_{\HO}$ 
%	and from $\tyl{L}_{\HOpp}$ to $\tyl{L}_{\sessp}$ 
%	are also precise. 
\end{theorem}

\begin{proof}
According to \defref{def:goodenc}, preciseness includes syntax-, type-, and semantics-preservation. 
Syntax preservation follows immediately from the definition of the encoding. 
Type preservation follows from 
\propref{prop:typepres_HOpp_to_HOp}.
Semantics-preservation follows from 	
\propref{prop:op_corr_HOpp_to_HOp} and 
\propref{prop:fulla_HOpp_to_HOp}.
 %\qed
\end{proof}

We then have the following corollary:

\begin{corollary}[Encodability of \HOpp into \HOp and \sessp]
Consider the typed encodings
\begin{enumerate}[-]
\item $\enco{\map{\cdot}^{1}_f, \mapt{\cdot}^{1} %, \mapa{\cdot}^{1}
}: \tyl{L}_{\HOp} \to \tyl{L}_{\HO}$  (cf. \defref{d:enc:hopitoho})
\item $\enco{\map{\cdot}^{2}, \mapt{\cdot}^{2} %, \mapa{\cdot}^{2}
}: \tyl{L}_{\HOp} \to \tyl{L}_{\sessp}$ (cf. \defref{d:enc:hopitopi})
\item $\enco{\map{\cdot}^{3}, \mapt{\cdot}^{3}}: \tyl{L}_{\HOpp} \to \tyl{L}_{\HOp}$ (cf. \defref{d:enc:hopptohop})
\end{enumerate}
Then the following typed encodings 	are precise:
\begin{enumerate}[-]
\item 
$\enco{\pmap{\cdot}{1} \circ \pmap{\cdot}{3}, \tmap{\cdot}{1} \circ \tmap{\cdot}{3}}: \tyl{L}_\HOpp \to \tyl{L}_\HO$
\item
$\enco{\pmap{\cdot}{2} \circ \pmap{\cdot}{3}, \tmap{\cdot}{2} \circ \tmap{\cdot}{3}}: \tyl{L}_\HOpp \to \tyl{L}_\sessp$
\end{enumerate}

\end{corollary}

\begin{proof}
Directly from 
\thmref{f:enc:hopitoho}, 
\thmref{f:enc:hotopi}, 
and 
\thmref{f:enc:hoppptohop} (which give preciseness for all the involved encodings), using
\propref{pro:composition}.
\end{proof}

%\smallskip 



%\noi Embeddings of polyadic name passing into monadic name passing are
%well-studied. % in the literature. 
%Using a linear typing, precise
%encodings (including full abstraction) can be obtained~\cite{Yoshida96}.
%Here we summarise how $\PHOp$ can be encoded into $\HOp$. 
%The syntax of 
%$\HOp$ is extended %from \HOp by including 
%with
%polyadic name passing $\tilde{n}$ and $\abs{\tilde{x}}{Q}$ in the syntax 
%of value $V$. The type syntax is extended to: 
%
%\begin{center}
%\begin{tabular}{c}
%$
%L ::= \shot{\tilde{C}} \ | \ \lhot{\tilde{C}}
%\quad\quad S \ ::= \  \btout{\tilde{U}} S \bnfbar \btinp{\tilde{U}} S \bnfbar \cdots 
%$
%\end{tabular}
%\end{center}
%%
%The type system disallows a shared name that directly carries polyadic
%shared names as in \cite{tlca07,MostrousY15}.
%i.e. $\chtype{\tilde{\chtype{S}}}$ 
%and $\chtype{\tilde{\chtype{L}}}$ 
%are disallowed.
%Other definitions are straightforwardly extended. 
%\jpc{We slightly modify \defref{def:tenc} to capture that a 
%label $\ell$ may be mapped into a sequence of labels~$\tilde{\ell}$.}
%We extend the mapping for labels 
%($\mapa{\cdot}: \ell \to \tilde{\ell}$ in  
%\defref{def:tenc}) to capture 
%a sequence of labels  and 
%Also, \defref{def:ep} is kept unchanged, 
%assuming that if 
%$P \hby{\ell} P'$ and $\mapa{\ell} = \ell_1, \ell_2,  \cdots, \ell_m$ then
%$\map{P} \Hby{\mapa{\ell}} \map{P'}$
%should be understood as
%$\map{P} \Hby{\ell_1} P_1 \Hby{\ell_2} P_2 \cdots \Hby{\ell_m} P_m =  \map{P'}$,
%for some
%$P_1, P_2, \ldots, P_m$.

%\paragraph{Encoding $\PHOp$ into $\HOp$}
%\label{subsec:pho}

\subsection{Precise Encoding of $\PHOp$ into $\HOp$}
The calculus  
$\PHOp$ 
extends $\HOp$ 
with polyadicity.
Thus, $\PHOp$  enables the exchange of tuples of names $\widetilde{n}$ (with fixed length $k \geq 1$) in both session communication (but not along shared names) and as arguments 
to function applications.
As such, the syntax of
\figref{fig:syntax}  
is modified by considering  
polyadic first-order applications of the form
 $\abs{x_1, \ldots, x_k}{Q}$ ($k \geq 1$)
 in the syntax of values $V$;
the syntax of processes includes polyadicity in input and output prefixes, 
 as well as in function applications. 
The operational semantics in \figref{fig:reduction} requires only minor modifications to accommodate simultaneous substitution $\subst{\widetilde{V}}{\widetilde{x}}$ (for equally sized $\widetilde{V}$ and $\widetilde{x}$)
in Rules~\orule{App} and \orule{Pass}:
	\begin{align*}
		\appl{(\abs{\widetilde{x}}{P})}{\widetilde{u}}   & \red  P \subst{\widetilde{u}}{x} 
		\\[1mm]
		\bout{n}{\widetilde{V}} P \Par \binp{\dual{n}}{\widetilde{x}} Q & \red  P \Par Q \subst{\widetilde{V}}{\widetilde{x}} 
	\end{align*}
The type syntax in \figref{f:types} is extended accordingly, as follows:
%
\begin{align*}
		L & \bnfis \shot{\widetilde{C}} \bnfbar \lhot{\widetilde{C}}
		\\
		S & \bnfis  \btout{\widetilde{U}} S \bnfbar \btinp{\widetilde{U}} S \bnfbar \cdots
\end{align*}
As in \cite{tlca07,MostrousY15},
the type system for \PHOp 
disallows a shared name that carries polyadic
shared names.

We consider the following typed calculus
 (cf.~\defref{d:tcalculus}):
	$$\tyl{L}_{\PHOp}=\calc{\PHOp}{{\cal{T}}_5}{\hby{\ell}}{\hwb}{\proves}$$
where 
	${\cal{T}}_5$ is the set of types of $\PHOp$;  
the typing $\proves$ is defined
%\figref{fig:typerulesmy} 
in \secref{sec:types}
with  type syntax given above.
Also, the set of labels 
$\mathcal{A}_{\PHOp}$ extends that in \defref{d:labels} by 
including actions
$\news{\tilde{m}} \bactout{n}{m_1, \ldots, m_k}$,
$\bactout{n}{\abs{x_1, \ldots, x_k}{P}}$,
$ \bactinp{n}{m_1, \ldots, m_k}$,
and
$\bactinp{n}{\abs{x_1, \ldots, x_k}{P}}$.

We now define a typed encoding of 
$\PHOp$ into $\HOp$. For simplicity, in definitions and statements we sometimes give the dyadic case (tuples of length 2);
the general $k$-adic case is as expected.

\begin{definition}[Typed Encoding of \PHOp into \HOp]
\label{d:enc:phoptohop}
The typed encoding
	$\enco{\pmap{\cdot}{4}, \tmap{\cdot}{4}}: \tyl{L}_{\PHOp} \to \tyl{L}_{\HOp}$ 
in \figref{f:enc:poltomon}.
\end{definition}

The encoding is rather unsurprising: the polyadic communication of a tuple of length $k > 1$
is translated as $k$ independent monadic communications, exploiting the already private communication medium given by the session name --- unlike classical encodings, there is no need for an additional fresh name for the monadic exchanges.
Polyadic first-order abstraction and application appeal to an auxiliary fresh session along which   parameters are communicated one by one.

The encoding satisfies the following properties:

%HERE WE NEED TO ADD AN EXCERPT OF \propref{app:prop:op_corr_pHOp_to_HOp}, BUT WE NEED TO FIX MACROS FIRST.

{
\begin{proposition}[\PHOp into \HOp: Type Preservation]
\label{prop:typepres_pHOp_to_HOp}
The encoding from
		$\tyl{L}_{\PHOp}$ into $\tyl{L}_{\HOp}$ (cf. \figref{f:enc:poltomon})
is type preserving.
\end{proposition}}

\begin{proof}
	By induction on the inference $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$.
	See \propref{app:prop:typepres_pHOp_to_HOp} in \appref{app:pHOp_to_HOp}.
	 %\qed
	\end{proof}
	
In this case, the required mapping on actions 
maps an action on $\mathcal{A}_{\PHOp}$ into a set of actions in $\mathcal{A}_{\HOp}$.
This is a natural consequence of dividing a $k$-adic name communication or application into 
independent (monadic) communications:

\begin{definition}

Given the typed encoding
	$\enco{\pmap{\cdot}{4}, \tmap{\cdot}{4}}: \tyl{L}_{\PHOp} \to \tyl{L}_{\HOp}$ (cf. \defref{d:enc:phoptohop}), 
	the mapping on actions 
$\mapa{\cdot}^{4}: \mathcal{A}_{\PHOp} \to \mathcal{P}(\mathcal{A}_{\HOp})$
is defined as follows:
	\begin{align*}
		\mapa{\news{\tilde{m}} \bactout{n}{m_1,  m_2}}^4 
		& \defeq \{\ell_1, \ell_2\} \quad
		\textrm{ where 
		$\begin{cases}
			\ell_i = \news{m_i}\bactout{n}{m_i} \quad \text{if $m_i \in \tilde{m}$} 
			\\
			\ell_i = \bactout{n}{m_i} \quad \text{if $m_i \not\in \tilde{m}$}
		\end{cases}$}
		\\
		\mapa{\news{\tilde{m}} \bactout{n}{\abs{x_1, x_2}{P}} }^4 
		& \defeq
		\{\news{\tilde{m}} \bactout{n}{\abs{z}\binp{z}{x_1} \binp{z}{x_2} \map{P}^{4}}\}
		\\
		\mapa{\btau}^4 & \defeq \{\btau, \stau,  \stau\}
		\\
		\mapa{\tau}^{4}  & \defeq \{\tau,\tau\}
		\\
		\mapa{\bactsel{n}{l}}^{4}  & \defeq \{\bactsel{n}{l}\}
		\\
		\mapa{\bactbra{n}{l}}^{4}  & \defeq \{\bactbra{n}{l}\}
	\end{align*}
\end{definition}
\noi The above definition handles the dyadic case. Notice that we distinguish two kinds of internal actions: while  $\mapa{\tau}^{4}$ is associated to internal actions arising from the mapping of polyadic name synchronization, 
 $\mapa{\btau}^4$ results from the translation of function applications. We may now state operational correspondence:

\begin{proposition}[Operational Correspondence. From \pHOp to \HOp]\myrm
	\label{prop:op_corr_pHOp_to_HOp}
Let $\Gamma; \es; \Delta \proves P$.
	\begin{enumerate}
		\item	 Then
			$\horel{\Gamma}{\Delta}{P}{\hby{\ell}}{\Delta'}{P'}$ implies
%
			\begin{enumerate}[a)]
				\item	If $\ell = \news{\tilde{m}'} \bactout{n}{\widetilde{m}}$ with $|\widetilde{m}| = k$ then
					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta}{4}}{\pmap{P}{4}}{\hby{\ell_1} \dots \hby{\ell_k}}{\tmap{\Delta'}{4}}{\pmap{P}{4}}$
					with $\mapa{\ell}^{4} = \{\ell_1, \dots, \ell_k\}$.

				\item	If $\ell = \bactinp{n}{\widetilde{m}}$ with $|\widetilde{m}| = k$ then
					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta}{4}}{\pmap{P}{4}}{\hby{\ell_1} \dots \hby{\ell_k}}{\tmap{\Delta'}{4}}{\pmap{P}{4}}$
					with $\mapa{\ell}^{4} = \{\ell_1, \dots, \ell_k\}$.

				\item	If $\ell \in \set{\news{\tilde{m}} \bactout{n}{\abs{\tilde{x}}{R}}, \bactinp{n}{\abs{\tilde{x}}{R}}}$ then
%					$\exists l' $ such that
					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta}{4}}{\pmap{P}{4}}{\hby{\ell'}}
					{\tmap{\Delta'}{4}}{\pmap{P'}{4}}$ with $\mapa{\ell}^{4} = \{\ell'\}$.

				\item	If $\ell \in \set{\bactsel{n}{l}, \bactbra{n}{l}}$ then
					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta}{4}}{\pmap{P}{4}}{\hby{\ell}}
					{\tmap{\Delta'}{4}}{\pmap{P'}{4}}$.

				\item	If $\ell = \btau$ then %either
					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta}{4}}{\pmap{P}{4}}{\hby{\btau} \hby{\stau} \dots \hby{\stau}}
					{\tmap{\Delta'}{4}}{\pmap{P'}{4}}$ with $\mapa{\ell} = \{\btau, \stau, \dots, \stau\}$.

				\item	If $\ell = \tau$ then %and $\hby{\ell}$ is not a \betatran then
					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta}{4}}{\pmap{P}{4}}{\hby{\tau} \dots \hby{\tau}}
					{\tmap{\Delta'}{4}}{\pmap{P'}{4}}$ with $\mapa{\ell}^{4} = \{\tau, \dots, \tau\}$.
			\end{enumerate}

		\item	%Let $\Gamma; \es; \Delta \proves P$.
			$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta}{4}}{\pmap{P}{4}}{\hby{\ell}}
			{\tmap{\Delta_1}{4}}{P_1}$ implies
%
			\begin{enumerate}[a)]
				\item	If $\ell \in \set{\bactinp{n}{m}, \bactout{n}{m}, \news{m} \bactout{n}{m}}$ then
					$\horel{\Gamma}{\Delta}{P}{\hby{\ell}}{\Delta'}{P'}$ and\\
					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta_1}{4}}{P_1}{\hby{\ell_1} \dots \hby{\ell_k}}
					{\tmap{\Delta'}{4}}{\tmap{P'}{4}}$ with $\mapa{\ell}^{4} = \{\ell_1, \dots, \ell_k\}$.

				\item	If $\ell \in \set{\news{\tilde{m}} \bactout{n}{\abs{x}{R}}, \bactinp{n}{\abs{x}{R}}}$
					then
					$\horel{\Gamma}{\Delta}{P}{\hby{\ell'}}{\Delta'}{P'}$
					with $\mapa{\ell'}^{4} = \{\ell\}$ and $P_1 \scong \pmap{P'}{4}$.

				\item	If $\ell \in \set{\bactsel{n}{l}, \bactbra{n}{l}}$
					then
					$\horel{\Gamma}{\Delta}{P}{\hby{\ell}}{\Delta'}{P'}$ and $P_1 \scong \pmap{P'}{4}$.
%					and $\horel{\tmap{\Gamma}{3}}{\tmap{\Delta''}{3}}{Q}{\hby{\hat{\ell}}}{\tmap{\Delta'}{3}}{\pmap{P'}{3}}$.

				\item	If $\ell = \btau$ then
					$\horel{\Gamma}{\Delta}{P}{\hby{\btau}}{\Delta'}{P'}$ and
					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta_1}{4}}{P_1}{\hby{\stau} \dots \hby{\stau}}
					{\tmap{\Delta'}{4}}{\tmap{P'}{4}}$ with $\mapa{\ell}^{4} = \{\btau, \stau, \dots, \stau\}$.

				\item	If $\ell = \tau$ then
					$\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ and
					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta_1}{4}}{P_1}{\hby{\tau} \dots \hby{\tau}}
					{\tmap{\Delta'}{4}}{\tmap{P'}{4}}$ with $\mapa{\ell}^{4} = \{\tau, \dots, \tau\}$.
			\end{enumerate}
	\end{enumerate}
\end{proposition}

\begin{proof}
	The proof of both parts is by transition induction, following 
	the mapping defined in  \figref{f:enc:poltomon}.
	See 	\propref{app:prop:op_corr_pHOp_to_HOp} in \appref{app:pHOp_to_HOp}.
	 %\qed
\end{proof}	
	
%\begin{proposition}[Operational Correspondence: From \PHOp to \HOp - Excerpt]\myrm
%	\label{prop:op_corr_pHOp_to_HOp}
%Let $\Gamma; \es; \Delta \proves P$.
%	\begin{enumerate}[1.]
%		\item	Completeness: 
%			$\horel{\Gamma}{\Delta}{P}{\hby{\ell}}{\Delta'}{P'}$ implies
%%
%			\begin{enumerate}[a)]
%%				\item	If $\ell = \news{\tilde{m}'} \bactout{n}{\tilde{m}}$ then
%%					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta}{4}}{\pmap{P}{4}}{\hby{\ell_1} \dots \hby{\ell_n}}{\tmap{\Delta'}{4}}{\pmap{P}{4}}$
%%					with $\mapa{\ell}^{4} = \ell_1 \dots \ell_n$.
%%
%%				\item	If $\ell = \bactinp{n}{\tilde{m}}$ then
%%					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta}{4}}{\pmap{P}{4}}{\hby{\ell_1} \dots \hby{\ell_n}}{\tmap{\Delta'}{4}}{\pmap{P}{4}}$
%%					with $\mapa{\ell}^{4} = \ell_1 \dots \ell_n$.
%%
%%				\item	If $\ell \in \set{\news{\tilde{m}} \bactout{n}{\abs{\tilde{x}}{R}}, \bactinp{n}{\abs{\tilde{x}}{R}}}$ then
%%%					$\exists l' $ such that
%%					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta}{4}}{\pmap{P}{4}}{\hby{\ell'}}
%%					{\tmap{\Delta'}{4}}{\pmap{P'}{4}}$ with $\mapa{\ell}^{4} = \ell'$.
%%
%%				\item	If $\ell \in \set{\bactsel{n}{l}, \bactbra{n}{l}}$ then
%%					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta}{4}}{\pmap{P}{4}}{\hby{\ell}}
%%					{\tmap{\Delta'}{4}}{\pmap{P'}{4}}$.
%
%				\item	If $\ell = \btau$ then %either
%					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta}{4}}{\pmap{P}{4}}{\hby{\btau} \hby{\stau}  \hby{\stau}}
%					{\tmap{\Delta'}{4}}{\pmap{P'}{4}}$ %with $\mapa{\ell} = \btau, \stau \dots \stau$.
%
%				\item	If $\ell = \tau$ then %and $\hby{\ell}$ is not a \betatran then
%					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta}{4}}{\pmap{P}{4}}{\hby{\tau}\hby{\tau} \hby{\tau}}
%					{\tmap{\Delta'}{4}}{\pmap{P'}{4}}$ %with $\mapa{\ell}^{4} = \tau \dots \tau$.
%			\end{enumerate}
%
%		\item	%Let $\Gamma; \es; \Delta \proves P$.
%		Soundness: 
%			$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta}{4}}{\pmap{P}{4}}{\hby{\ell}}
%			{\tmap{\Delta_1}{4}}{P_1}$ implies
%%
%			\begin{enumerate}[a)]
%%				\item	If $\ell \in \set{\bactinp{n}{m}, \bactout{n}{m}, \news{m} \bactout{n}{m}}$ then
%%					$\horel{\Gamma}{\Delta}{P}{\hby{\ell}}{\Delta'}{P'}$ and\\
%%					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta_1}{4}}{P_1}{\hby{\ell_2} \dots \hby{\ell_n}}
%%					{\tmap{\Delta'}{4}}{\tmap{P'}{4}}$ with $\mapa{\ell}^{4} = \ell_1 \dots \ell_n$.
%%
%%				\item	If $\ell \in \set{\news{\tilde{m}} \bactout{n}{\abs{x}{R}}, \bactinp{n}{\abs{x}{R}}}$
%%					then
%%					$\horel{\Gamma}{\Delta}{P}{\hby{\ell'}}{\Delta'}{P'}$
%%					with $\mapa{\ell'}^{4} = \ell$ and $P_1 \scong \pmap{P'}{4}$.
%%
%%				\item	If $\ell \in \set{\bactsel{n}{l}, \bactbra{n}{l}}$
%%					then
%%					$\horel{\Gamma}{\Delta}{P}{\hby{\ell}}{\Delta'}{P'}$ and $P_1 \scong \pmap{P'}{4}$.
%%%					and $\horel{\tmap{\Gamma}{3}}{\tmap{\Delta''}{3}}{Q}{\hby{\hat{\ell}}}{\tmap{\Delta'}{3}}{\pmap{P'}{3}}$.
%%
%				\item	If $\ell = \btau$ then
%					$\horel{\Gamma}{\Delta}{P}{\hby{\btau}}{\Delta'}{P'}$ and
%					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta_1}{4}}{P_1}{\hby{\stau} \hby{\stau}}
%					{\tmap{\Delta'}{4}}{\tmap{P'}{4}}$ %with $\mapa{\ell}^{4} = \btau, \stau \dots \stau$.
%
%				\item	If $\ell = \tau$ then
%					$\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ and
%					$\horel{\tmap{\Gamma}{4}}{\tmap{\Delta_1}{4}}{P_1}{\hby{\tau} \hby{\tau} \hby{\tau}}
%					{\tmap{\Delta'}{4}}{\tmap{P'}{4}}$ %with $\mapa{\ell}^{4} = \tau \dots \tau$.
%			\end{enumerate}
%	\end{enumerate}
%\end{proposition}

We may now state:


\begin{proposition}[Full Abstraction: From \PHOp to \HOp]%\myrm
	\label{prop:fulla_pHOp_to_HOp}
	Let $P, Q$ be \PHOp processes with $\Gamma; \es; \Delta_1 \proves P \hastype \Proc$ and 
	$\Gamma; \es; \Delta_2 \proves Q \hastype \Proc$. Then we have: \\
	$\horel{\Gamma}{\Delta_1}{P}{\hwb}{\Delta_2}{Q}$ if and only if $\horel{\tmap{\Gamma}{4}}{\tmap{\Delta_1}{4}}{\pmap{P}{4}}{\hwb}{\tmap{\Delta_2}{4}}{\pmap{Q}{4}}$.
\end{proposition}

%Based on these propositions,we have:
Using the above propositions,  
\thmsref{f:enc:hopitoho}
and 
\ref{f:enc:hotopi},
and \propref{pro:composition}, 
we derive the following: 
\begin{theorem}[Encoding of \PHOp into \HOp]
	\label{f:enc:phopiptohopi}
	The encoding from
		$\tyl{L}_{\PHOp}$ into $\tyl{L}_{\HOp}$ (cf. \figref{f:enc:poltomon})
	is precise. 
%	Hence, the encodings 
%	from
%	$\tyl{L}_{\PHOp}$ to $\tyl{L}_{\HO}$ 
%	and $\tyl{L}_{\sessp}$ 
%	are also precise. 
\end{theorem}

\begin{proof}
According to \defref{def:goodenc}, preciseness includes syntax-, type-, and semantics-preservation. 
Syntax preservation follows immediately from the definition of the encoding. 
Type preservation follows from 
\propref{prop:typepres_pHOp_to_HOp}.
Semantics-preservation follows from 	
\propref{prop:op_corr_pHOp_to_HOp} and 
\propref{prop:fulla_pHOp_to_HOp}.
 %\qed
\end{proof}

We then have the following corollary:

\begin{corollary}[Encodability of \PHOp into \HOp and \sessp]
Consider the typed encodings
\begin{enumerate}[-]
\item $\enco{\map{\cdot}^{1}_f, \mapt{\cdot}^{1} %, \mapa{\cdot}^{1}
}: \tyl{L}_{\HOp} \to \tyl{L}_{\HO}$  (cf. \defref{d:enc:hopitoho})
\item $\enco{\map{\cdot}^{2}, \mapt{\cdot}^{2} %, \mapa{\cdot}^{2}
}: \tyl{L}_{\HOp} \to \tyl{L}_{\sessp}$ (cf. \defref{d:enc:hopitopi})
\item $\enco{\map{\cdot}^{4}, \mapt{\cdot}^{4}}: \tyl{L}_{\PHOp} \to \tyl{L}_{\HOp}$ (cf. \defref{d:enc:phoptohop})
\end{enumerate}
Then the following typed encodings 	are precise:
\begin{enumerate}[-]
\item 
$\enco{\pmap{\cdot}{1} \circ \pmap{\cdot}{4}, \tmap{\cdot}{1} \circ \tmap{\cdot}{4}}: \tyl{L}_{\PHOp} \to \tyl{L}_\HO$
\item
$\enco{\pmap{\cdot}{2} \circ \pmap{\cdot}{4}, \tmap{\cdot}{2} \circ \tmap{\cdot}{4}}: \tyl{L}_{\PHOp} \to \tyl{L}_\sessp$
\end{enumerate}

\end{corollary}

\begin{proof}
Directly from 
\thmref{f:enc:hopitoho}, 
\thmref{f:enc:hotopi}, 
and 
\thmref{f:enc:phopiptohopi} (which give preciseness for all the involved encodings), using
\propref{pro:composition}.
\end{proof}


%\begin{proof}
%See \appref{app:pHOp_to_HOp}.
%\end{proof}


By combining Thms.~\ref{f:enc:hoppptohop} and~\ref{f:enc:phopiptohopi},
we can extend preciseness to the super-calculus
$\PHOpp$, which subsumes both \HOpp and \PHOp.
% (denoted by   in Fig.~\ref{fig:express}) 


\input{figures/polHOp_to_HOp}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Related Work}
\label{sec:relwork}
%\input{relworkshort}

%We have thoroughly studied the expressivity of the higher-order $\pi$-calculus with sessions,
%here denoted $\HOp$.
%Unlike most previous works, 
%%on the expressivity of (higher-order) process calculi, 
%we have carried out our study in the setting of \emph{session types}. % for structured communications.
%Types not only delineate and enable encodings; they 
%inform the techniques required to reason about such encodings.
%Our results cover a wide spectrum of features intrinsic to higher-order concurrency:
%pure process-passing (first- and higher-order abstractions), name-passing, polyadicity, 
%linear/shared communication (cf.~\figref{fig:express}). 
%Remarkably, the discipline embodied by 
%session types turns out to be fundamental to show that all these languages are equally expressive, up to 
% strong typed bisimilarities. Indeed, although our encodings may be used in an untyped setting,
%session type information is critical to establish key properties for preciseness, in particular full abstraction.
%
%\paragraph{Related Work.}
There is a vast literature on expressiveness for process calculi; we refer to~\cite{DBLP:journals/entcs/Parrow08} 
and \cite[\S\,2.3]{PerezPhD10} for surveys.
%, both first- and higher-order. 
%For space reasons here 
%Below we concentrate on closely related work.
%In the untyped setting, the relative expressiveness of name-passing calculi with respect to 
%higher-order languages %(process- and abstraction-passing) 
%is well-known. 
Our study casts known results~\cite{SangiorgiD:expmpa} into a session typed setting, and
offers new encodability results.
Our work stresses the 
view of ``encodings as protocols'', namely session protocols which
enforce linear and shared disciplines for names, a distinction
little explored in %~\cite{SangiorgiD:expmpa,DBLP:journals/tcs/Sangiorgi01}. 
previous works.
This distinction %is key, as  
%in proper definitions of trigger processes, which are key to encodings (\defref{d:enc:hopitopi}). % and behavioural equivalences (\defref{d:hbw} and~\ref{d:fwb}).  
%in our technical developments: % in particular, 
%it 
enables us to obtain 
 refined 
operational correspondence results (cf. \propsref{prop:op_corr_HOp_to_HO}, \ref{prop:op_corr_HOp_to_p}, \ref{prop:op_corr_HOpp_to_HOp}, \ref{prop:op_corr_pHOp_to_HOp}).
We showed that
$\HO$ suffices to encode   the first-order session
calculus~\cite{honda.vasconcelos.kubo:language-primitives}, here denoted~\sessp. % with name passing ($\sessp$).
To our knowledge, this is a new result; %for session typed calculi: 
its significance is stressed by the demanding encodability criteria  considered, in particular full abstraction up to typed bisimilarities
($\hwb$/$\fwb$, cf. \propsref{prop:fulla_HOp_to_HO} and~\ref{prop:fulla_HOp_to_p}).
This encoding is relevant in a broader setting, as known encodings 
of name-passing into higher-order calculi~\cite{SaWabook,BundgaardHG06,DBLP:journals/entcs/MeredithR05,XuActa2012,DBLP:journals/corr/XuYL15}  require limitations
in source/target languages,
do not consider types,
 and/or fail to satisfy strong encodability criteria (see below). 
We also showed that $\HO$ can encode $\HOp$ and its extension with
higher-order applications ($\HOpp$). 
Thus, %using session types
all these  calculi are equally expressive with fully
abstract encodings (up to $\hwb$/$\fwb$).  
These appear to be the first results of this kind.

Early works on (relative) expressiveness appealed to different notions of encoding.
Later on, 
proposals of abstract 
frameworks which formalise the notion of encoding 
and state associated syntactic/semantic criteria 
were put forward; 
recent proposals include~\cite{DBLP:journals/iandc/Gorla10,DBLP:journals/tcs/FuL10,DBLP:journals/corr/abs-1208-2750,DBLP:conf/esop/PetersNG13,DBLP:journals/corr/PetersG15}. 
%These frameworks %are applicable to different calculi, and 
%have been used to clarify known results and to derive new ones.
Our formulation of precise encoding (\defref{def:goodenc}) 
builds upon existing proposals (e.g.,~\cite{Palamidessi03,DBLP:journals/iandc/Gorla10,DBLP:conf/icalp/LanesePSS10})
 to account for the session types
associated to \HOp. % and its variants.


Early expressiveness studies for higher-order calculi are~\cite{Tho90,SangiorgiD:expmpa}; 
recent works include~\cite{BundgaardHG06,DBLP:conf/icalp/LanesePSS10,DBLP:journals/iandc/LanesePSS11,XuActa2012,DBLP:conf/wsfm/XuYL13}.
Due to the close relationship between higher-order process calculi and functional calculi, 
%works devoted to 
encodings of (variants of) the $\lambda$-calculus into the $\pi$-calculus (see, e.g.,~\cite{San92,DBLP:journals/tcs/Fu99,DBLP:journals/iandc/YoshidaBH04,BHY,DBLP:conf/concur/SangiorgiX14}) are also related.
Sangiorgi's encoding of the higher-order $\pi$-calculus
into the  $\pi$-calculus~\cite{SangiorgiD:expmpa} 
is fully abstract with respect to reduction-closed, barbed congruence. 
We have shown in \secref{subsec:HOp_to_sessp} that the analogue of Sangiorgi's encoding for the session typed setting also satisfies full abstraction (up to $\hwb$/$\fwb$, cf. \propref{prop:op_corr_HOp_to_p}).
A basic form of input/output types is used in~\cite{DBLP:journals/tcs/Sangiorgi01}, where the encoding in~\cite{SangiorgiD:expmpa} is casted in the asynchronous setting, with output and applications coalesced in a single construct. Building upon~\cite{DBLP:journals/tcs/Sangiorgi01}, 
a simply typed encoding for synchronous processes is given in~\cite{SaWabook}; the reverse encoding (i.e.,  first-order communication into higher-order processes) is also studied  for an asynchronous, localised $\pi$-calculus (only the output capability of names can be sent around).
The work~\cite{San96int} studies hierarchies for calculi with \emph{internal} first-order mobility and 
with higher-order mobility without name-passing (similarly as the subcalculus \HO). 
The hierarchies are
defined according to the order of types needed in typing.
Via fully abstract encodings, it is shown that that name- and process-passing calculi with equal order of types have the same expressiveness.

%With respect to these previous results, our approach based on session types 
%has several important consequences and allows us to derive new results.  Our study reinforces the intuitive view of ``encodings as protocols'', namely session protocols which enforce precise linear and shared disciplines for names, a distinction not investigated in~\cite{SangiorgiD:expmpa,DBLP:journals/tcs/Sangiorgi01}. 
%In turn, the linear/shared distinctionbs central in proper definitions of trigger processes, which are essential to encodings and behavioural equivalences.
%More interestingly, we showed that $\HO$, a  minimal higher-order session calculus (no name passing, only first-order application) suffices to encode $\sessp$ (the session calculus with name passing) but also 
%$\HOp$  and 
%its extension  with higher-order applications (denoted $\HOpp$). 
%Thus, using session types all these calculi are shown to be equally expressive with fully abstract encodings.
%To our knowledge, these are the first expressiveness results of this kind.

Other related works are~\cite{BundgaardHG06,DBLP:journals/entcs/MeredithR05,XuActa2012,DBLP:journals/iandc/LanesePSS11}.
The paper~\cite{BundgaardHG06} gives a fully abstract %, contin\-u\-a\-tion-passing style 
encoding of the 
$\pi$-calculus into Homer, a higher-order  calculus with explicit locations, local names, and nested locations.
The paper~\cite{DBLP:journals/entcs/MeredithR05}
presents a \emph{reflective}  calculus with a ``quoting'' operator: names are quoted processes and represent the code 
of a process; name-passing is then a way of passing the code of a process. This reflective calculus 
can encode both first- and higher-order $\pi$-calculus.
Building upon~\cite{ThomsenB:plachoasgcfhop},
the work~\cite{XuActa2012} studies 
the (non)en\-co\-da\-bi\-lity of the untyped $\pi$-calculus into 
a higher-order $\pi$-calculus with a powerful 
name relabelling operator, which is 
%shown to be 
essential to encode name-passing. 
The paper~\cite{DBLP:journals/corr/XuYL15} defines an encoding of the (untyped) $\pi$-calculus 
without relabeling. 
This encoding is quite different from the one in~\secref{subsec:HOpi_to_HO}:
in~\cite{DBLP:journals/corr/XuYL15} names are encoded using polyadic name abstractions (called \emph{pipes}); 
guarded replication %(rather than recursion) 
enables infinite behaviours.
While our encoding satisfies full abstraction, % (\propref{prop:fulla_HOp_to_HO}), 
the encoding in~\cite{DBLP:journals/corr/XuYL15} does not: only 
divergence-reflection
and 
operational correspondence (soundness and completeness) properties 
are established.
Soundness is stated up-to \emph{pipe-bisimilarity}, an equivalence tailored to the encoding strategy;
the authors of~\cite{DBLP:journals/corr/XuYL15} describe this result as ``weak''.
%this result is described by the authors of~\cite{DBLP:journals/corr/XuYL15} as ``weak''.


A core higher-order calculus is studied in~\cite{DBLP:journals/iandc/LanesePSS11}: it lacks restriction,  name passing, output prefix, % (asynchronous communication), 
and %constructs for infinite behaviour.
replication/recursion. 
Still, this  subcalculus of \HO is Turing equivalent.
The work~\cite{DBLP:conf/icalp/LanesePSS10}
extends this core calculus with restriction,
output prefix, and polyadicity; it shows that 
synchronous communication can encode asynchronous communication, % (as in the first-order setting),
and that process passing polyadicity induces an expressiveness  hierarchy. % (unlike the first-order setting).
%A further extension with process abstractions of order one
%(functions from processes to processes)
% is shown to strictly add expressive power with respect to passing of processes only.
The paper~\cite{DBLP:conf/wsfm/XuYL13} 
complements~\cite{DBLP:conf/icalp/LanesePSS10} 
by studying the expressivity %of second-order abstractions.
%with replication ($!P$).  
%The work \cite{DBLP:conf/wsfm/XuYL13} focuses  
%%name and process abstractions are distinguished and contrasted, also 
%on expressiveness of the hirarchy of polyadic abstraction parameters. 
%(the same kind of polyadicity present in \pHOp)
%By adapting the encodings in~\cite{DBLP:conf/icalp/LanesePSS10} 
%Polyadicity 
of 
second-order process abstractions.
Polyadicity is shown to induce an expressiveness hierarchy; 
also,
by adapting the encoding in~\cite{SangiorgiD:expmpa},
process abstractions are encoded into name abstractions.
In contrast, here we 
give a fully abstract encoding of
 \PHOpp into \HO that preserves session types; this improves~\cite{DBLP:conf/icalp/LanesePSS10,DBLP:conf/wsfm/XuYL13}   
by enforcing linearity disciplines on process behaviour.
The focus of~\cite{DBLP:conf/icalp/LanesePSS10,XuActa2012,DBLP:conf/wsfm/XuYL13,DBLP:journals/corr/XuYL15} is on 
untyped, higher-order processes; they
%Moreover,~\cite{DBLP:conf/icalp/LanesePSS10,DBLP:conf/wsfm/XuYL13}
do not address communication disciplined by 
(session) type systems.
%therefore, our work complements their  results. 
% by clarifying the status of typeful %, resource-aware 
%structured communications. % in trigger-based representations of process passing, both in encodings and  equivalences.



Within session types, the works~\cite{DemangeonH11,Dardha:2012:STR:2370776.2370794} 
encode binary sessions into a linearly typed $\pi$-calculus. 
While~\cite{DemangeonH11}~gives an encoding of \sessp into a linear calculus 
(an extension of \cite{BHY}),  
the work~\cite{Dardha:2012:STR:2370776.2370794} 
gives  operational correspondence (without full abstraction)
for the first- and higher-order 
$\pi$-calculi into~\cite{LinearPi}. 
%They investigate an embeddability of two different typing systems;
By the result of \cite{DemangeonH11}, 
\HOpp is encodable  into the linearly typed $\pi$-calculi.     
The syntax of $\HOp$ is a subset of that in~\cite{tlca07,MostrousY15}.
The work~\cite{tlca07} develops a higher-order session calculus
with process abstractions and applications; it admits the type 
$U=U_1 \rightarrow U_2 \dots U_n \rightarrow \Proc$ and its linear type 
$U^1$
which corresponds to $\shot{\tilde{U}}$ and $\lhot{\tilde{U}}$ in 
a super-calculus of $\HOpp$ and $\PHOp$. 
%in~\cite{MostrousY15} in the asynchronous setting.
%The session type
%system considered is influenced by the type systems for $\lambda$-calculi and
%uses type syntax of the form $U_1 \rightarrow U_2 \dots U_n \rightarrow \Proc$
%for shared values and $(U_1 \rightarrow U_2 \dots U_n \rightarrow \Proc)^{1}$
%for linear values.
%Such a type is expressed in $\HOpp$
%terms using the type $\shot{U}$ (respectively, $\lhot{U}$)
%with $U$ being a nested higher-order type; and 
%the $\HOp$ uses only types of the form
%$\shot{C}$ and $\lhot{C}$ with $C$ being a first-order channel type.
Our results show that
the calculus in~\cite{tlca07} is not only expressed but 
also reasoned in 
$\HO$ via precise encodings (with a limited form of arrow types: $\shot{C}$ and $\lhot{C}$). 
\newj{The recent work \cite{OY2016} studies two encodings:
from PCF with an effect system into a session-typed $\pi$-calculus, 
and its reverse. The reverse encoding is used to implement session channel passing in Concurrent Haskell. 
In future work we plan to use the core calculi 
studied in this paper 
to implement higher-order communication efficiently into Concurrent Haskell without losing its expressiveness.
}

\section{Concluding Remarks}
\label{sec:concl}
%\input{relworkshort}

We have thoroughly studied the expressivity of the higher-order $\pi$-calculus with sessions,
here denoted $\HOp$.
Unlike most previous works, 
%on the expressivity of (higher-order) process calculi, 
we have carried out our study in the setting of \emph{session types}. % for structured communications.
Types not only delineate and enable encodings; they 
inform the techniques required to reason about such encodings.
Our results cover a wide spectrum of features intrinsic to higher-order concurrency:
pure process-passing (first- and higher-order abstractions), name-passing, polyadicity, 
linear/shared communication (cf.~\figref{fig:express}). 
Remarkably, the discipline embodied by 
session types turns out to be fundamental to show that all these languages are equally expressive, up to 
 strong typed bisimilarities. Indeed, although our encodings may be used in an untyped setting,
session type information is critical to establish key properties for preciseness, in particular full abstraction.

\paragraph{Acknowledgments}
We have benefited from feedback from the users of the Moca mailing list, in particular Greg Meredith and Xu Xian.
We are grateful to the ESOP'16 anonymous reviewers for their useful remarks and suggestions.
This work has been partially sponsored by the Doctoral Prize Fellowship, EPSRC EP/K011715/1, EPSRC EP/K034413/1, and EPSRC EP/L00058X/1, EU project FP7-612985 UpScale, and EU COST Actions IC1201 (BETTY), IC1402 (ARVI), and IC1405 (Reversible Computation). P\'{e}rez is also affiliated to the NOVA Laboratory for Computer Science and Informatics (NOVA LINCS), Universidade Nova de Lisboa, Portugal.
 
%\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{References}
%\bibliographystyle{abbrv}
\bibliographystyle{elsarticle-num}
{\bibliography{session}}

\newpage
\onecolumn
\setcounter{tocdepth}{3}
\tableofcontents

\appendix 
\section{Appendix}
\label{app:types}
\input{appendix/app-types}
\input{appendix/app-behavioural}
\input{appendix/app-encoding}
%\input{appendix/app-negative}

\end{document}


