% !TEX root = main.tex

\noi
We develop a theory for observational equivalence over
session typed \HOp processes that follows the principles
laid in our previous works~\cite{KYHH2015,KY2015}.
We introduce \emph{higher-order bisimulation} (\defref{d:hwb})
and
\emph{characteristic bisimulation} (\defref{d:fwb}), 
denoted $\hwb$ and $\fwb$, respectively.
We prove that
they coincide with reduction-closed,
barbed congruence (\thmref{the:coincidence}, page \pageref{the:coincidence}).

We briefly summarise our strategy for obtaining \thmref{the:coincidence}.
We begin by defining an (early) labelled transition system (LTS) on
untyped processes~(\S\,\ref{ss:lts}). 
Then, using the \emph{environmental} transition semantics (\secref{ss:elts}), 
we define a typed LTS that formalises 
how a typed process interacts with a typed observer. 
Later,  we define 
reduction-closed, barbed congruence and 
context bisimilarity, respectively (\secref{subsec:rc} and~\secref{subsec:bisimulation}). 
Subsequently, 
we define the refined LTS based on characteristic values~(\secref{ss:reflts}).
Building upon this LTS, 
we define
higher-order  and  characteristic bisimilarities  (\secref{ss:hwb}).
Then, we develop an auxiliary  proof technique based on deterministic transitions (\secref{ss:deter}).
Our main result, the 
characterisation of barbed congruence in terms of $\hwb$ and $\fwb$, is stated in~\secref{ss:charact}.
Finally, we revisit our two implementations for the Hotel Booking Scenario (\secref{exam:proc}), 
using  \thmref{the:coincidence}
to show that they are behaviourally equivalent (\secref{ss:examprev}).

\subsection{Labelled Transition System for Processes}
\label{ss:lts}

We define the interaction of processes with their environment using action labels $\ell$:
%
\begin{center}
	\begin{tabular}{l}
		$\ell
			\bnfis  \tau 
			\bnfbar	\news{\widetilde{m}} \bactout{n}{V}
			\bnfbar	\bactinp{n}{V} 
			\bnfbar	\bactsel{n}{l} 
			\bnfbar	\bactbra{n}{l}$
	\end{tabular}
\end{center}
%
\noi 
Label $\tau$ defines internal actions.
Action
$\news{\widetilde{m}} \bactout{n}{V}$
denotes the sending of value $V$
over channel $n$ with a possible empty set of restricted names
$\widetilde{m}$ 
(we may write $\bactout{n}{V}$ when $\widetilde{m}$ is empty).
Dually, the action for value reception is 
$\bactinp{n}{V}$.
Actions for select and branch on
a label~$l$ are denoted $\bactsel{n}{l}$ and $\bactbra{n}{l}$, resp.
We write $\fn{\ell}$ and $\bn{\ell}$ to denote the
sets of free/bound names in $\ell$, resp.
%and set $\mathsf{n}(\ell)=\bn{\ell}\cup \fn{\ell}$. 
Given $\ell \neq \tau$, we write $\subj{\ell}$
to denote the \emph{subject} of $\ell$.
\newc{This way, we have:  
$\subj{\news{\widetilde{m}} \bactout{n}{V}} = 
\subj{\bactinp{n}{V}} = 
\subj{\bactsel{n}{l}} = 
\subj{\bactbra{n}{l}} = n$}.

%%%%%%%%%%%%%%%%%%%% LTS Figure %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}
	\begin{mathpar}
		\inferrule[\ltsrule{App}]{
		}{
			\appl{(\abs{x}{P})}{V} \by{\tau} P \subst{V}{x}
		}
		\and
		\inferrule[\ltsrule{Snd}]{
		}{
			\bout{n}{V} P \by{\bactout{n}{V}} P
		}
		\and
		\inferrule[\ltsrule{Rv}]{
		}{
			\binp{n}{x} P \by{\bactinp{n}{V}} P\subst{V}{x}
		}
		\and
		\inferrule[\ltsrule{Sel}]{
		}{
			\bsel{s}{l}{P} \by{\bactsel{s}{l}} P
		}
		\and
		\inferrule[\ltsrule{Bra}]{j\in I
		}{
			\bbra{s}{l_i:P_i}_{i \in I} \by{\bactbra{s}{l_j}} P_j 
		}
		\and
		\inferrule[\ltsrule{Alpha}]{
			P \scong_\alpha Q
			\and
			Q\by{\ell} P'
		}{
			P \by{\ell} P'
		}
		\and
		\inferrule[\ltsrule{Res}]{
			P \by{\ell} P'
			\and
			n \notin \fn{\ell}
		}{
			\news{n} P \by{\ell} \news{n} P'
		}
		\and
		\inferrule[\ltsrule{New}]{
			P \by{\news{\widetilde{m}} \bactout{n}{V}} P'
			\and
			m \in \fn{V}
		}{
			\news{m} P \by{\news{m\cat\widetilde{m}'} \bactout{n}{V}} P'
		}
		\and
		\inferrule[\ltsrule{Par${}_L$}]{
			P \by{\ell} P'
			\and
			\bn{\ell} \cap \fn{Q} = \es
		}{
			P \Par Q \by{\ell} P' \Par Q
		}
		\and
		\inferrule[\ltsrule{Tau}]{
			P \by{\ell_1} P'
			\and
			Q \by{\ell_2} Q'
			\and
			\ell_1 \asymp \ell_2
		}{
			P \Par Q \by{\tau} \newsp{\bn{\ell_1} \cup \bn{\ell_2}}{P' \Par Q'}
		}
		\and
		\inferrule[\ltsrule{Rec}]{
			P\subst{\recp{X}{P}}{\rvar{X}} \by{\ell} P'
		}{
			\recp{X}{P}  \by{\ell} P'
		}
	\end{mathpar}
	%
	\caption{The Untyped LTS for \HOp processes. We omit rule $\ltsrule{Par${}_R$}$.  \label{fig:untyped_LTS}}
	%
\end{figure}

%%%%%%%%%%%%%%%%%%%% End LTS Figure %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Dual actions}
occur on subjects that are dual between them and carry the same
object; thus, output is dual to input and 
selection is dual to branching.
Formally, duality \jpc{on actions}
is the least symmetric relation $\asymp$ that satisfies:
\[
	\bactsel{n}{l} \asymp \bactbra{\dual{n}}{l}
	\qquad \qquad 
	\news{\widetilde{m}} \bactout{n}{V} \asymp \bactinp{\dual{n}}{V}
\]
The (early) labelled transition system
(LTS) %LTS
over \emph{untyped processes}
is given in
\figref{fig:untyped_LTS}. 
We write $P_1 \by{\ell} P_2$ with the usual meaning.
The rules are standard~\cite{KYHH2015,KY2015}; we comment on some of them.
A process with an output prefix can
interact with the environment with an output action that carries a value
$V$ (Rule~$\ltsrule{Snd}$).  Dually, in Rule~$\ltsrule{Rv}$ a
receiver process can observe an input of an arbitrary value $V$.
Select and branch processes observe the select and branch
actions in Rules~$\ltsrule{Sel}$ and $\ltsrule{Bra}$, resp.
Rule $\ltsrule{Res}$ 
%closes the LTS under restriction 
\newc{enables an observable action from a process with an outermost restriction, provided that 
 the restricted name does not occur free in the action}. 
If a restricted name occurs free in
the carried value of an output action,
the process performs scope opening (Rule~$\ltsrule{New}$).  
Rule~$\ltsrule{Rec}$ handles recursion unfolding.
Rule~$\ltsrule{Tau}$ 
states that two parallel processes which perform
dual actions can synchronise by an internal transition.
Rules~$\ltsrule{Par${}_L$}$/$\ltsrule{Par${}_R$}$ 
and $\ltsrule{Alpha}$ 
%close the LTS under parallel composition and $\alpha$-renaming. 
\newc{define standard treatments for actions under parallel composition and $\alpha$-renaming.}

\subsection{Environmental Labelled Transition System}
\label{ss:elts}
Our typed LTS is obtained by coupling the untyped LTS given before with a labelled transition relation 
on typing environments. Such a relation, given in \figref{fig:envLTS}, 
is defined on triples of environments by 
extending the LTSs
in \cite{KYHH2015,KY2015}; it is 
denoted
%
\[
	(\Gamma_1, \Lambda_1, \Delta_1) \by{\ell} (\Gamma_2, \Lambda_2, \Delta_2)
\]
%
\newc{Recall that  $\Gamma$ admits  weakening. 
Using this principle (not valid for $\Lambda$ and $\Delta$), we have  
$
	(\Gamma', \Lambda_1, \Delta_1) \hby{\ell} (\Gamma', \Lambda_2, \Delta_2)
$
whenever 
$
	(\Gamma, \Lambda_1, \Delta_1) \hby{\ell} (\Gamma', \Lambda_2, \Delta_2)
$.}
%
\paragraph{Input Actions} 
are defined by 
Rules~$\eltsrule{SRv}$ and $\eltsrule{ShRv}$.
In Rule~$\eltsrule{SRv}$
the type of value $V$
and the type of the object associated to the session type on $s$ 
should coincide. 
The resulting type tuple must contain the environments 
associated to $V$. 
The
dual endpoint $\dual{s}$ cannot be
present in the session environment: if it were present
the only possible communication would be the interaction
between the two endpoints (cf. Rule~$\eltsrule{Tau}$).
Rule~$\eltsrule{ShRv}$ is for shared names and follows similar principles.

\paragraph{Output Actions} are defined by Rules~$\eltsrule{SSnd}$
and $\eltsrule{ShSnd}$.  
Rule~$\eltsrule{SSnd}$ states the conditions for observing action
$\news{\widetilde{m}} \bactout{s}{V}$ on a type tuple 
$(\Gamma, \Lambda, \Delta\cdot \AT{s}{S})$. 
The session environment $\Delta \,\cat\, \AT{s}{S}$ 
should include the session environment of the sent value $V$ \newc{(denoted $\Delta'$ in the rule)}, 
{\em excluding} the session environments of names $m_j$ 
in $\widetilde{m}$ which restrict the scope of value $V$ \newc{(denoted $\Delta_j$ in the rule)}. 
Analogously, the linear variable environment 
$\Lambda'$ of $V$ should be included in $\Lambda$. 
\newc{The rule defines the scope extrusion of session names in $\widetilde{m}$; consequently, 
environments associated to 
their dual endpoints  (denoted $\Delta'_j$ in the rule) appear in
the resulting session environment}. Similarly for shared 
names in $\widetilde{m}$ that are extruded.  
All free values used for typing $V$ \newc{(denoted $\Lambda'$ and $\Delta'$ in the rule)} are subtracted from the
resulting type tuple. The prefix of session $s$ is consumed
by the action.
Rule $\eltsrule{ShSnd}$ follows very similar ideas for output actions on shared names:
the name must be typed with $\chtype{U}$; 
conditions on value $V$ are identical to those on Rule~$\eltsrule{SSnd}$.
\newc{We illustrate Rule~$\eltsrule{SSnd}$ by means of an example:}

\begin{example}
	\newc{Consider environment tuple
	$
		(\Gamma;\, \es;\, s: \btout{\lhot{(\btout{S} \tinact)}} \tinact \cat s': S)
	$
	and typed value $V= \abs{x} \bout{x}{s'} \binp{m}{z} \inact$ with 
	\[
		\Gamma; \es; s': S \cat m: \btinp{\tinact} \tinact \proves V \, \hastype \, \lhot{(\btout{S} \tinact)}
	\]
%
%	\noi Let 
%	$
%		\Delta'_1=\set{\overline{m}: \btout{\tinact} \tinact}
%	$
%	and $U=\btout{\lhot{\btout{S} \tinact}} \tinact$.
	Then by Rule $\eltsrule{SSnd}$, we can derive:
%
	\[
		(\Gamma; \es; s: \btout{\lhot{\btout{S} \tinact}} \tinact \cat s': S) \by{\news{m} \bactout{s}{V}} (\Gamma; \es; s: \tinact \cat \dual{m}: \btout{\tinact} \tinact)
	\]
%	\qed
Observe how the protocol along $s$ is partially consumed; also, the resulting session environment is extended with 
  $\dual{m}$, the dual endpoint of the extruded name $m$.}
\end{example}


\begin{notation}
Given a value $V$ of type $U$, we sometimes annotate the output action 
$\news{\widetilde{m}} \bactout{n}{V}$
with the type of $V$ 
as $\news{\widetilde{m}} \bactout{n}{\AT{V}{U}}$.
\end{notation}

\paragraph{Other Actions}
Rules $\eltsrule{Sel}$ and $\eltsrule{Bra}$ describe actions for
select and branch.
%Both
%rules require the absence of the dual endpoint from the session
%environment.%, and the presence of the action labels in the type.
Rule~$\eltsrule{Tau}$ defines
internal transitions: 
it keeps the session environment unchanged or 
reduces it (\defref{d:wtenvred}).

\smallskip

%%%%%%%%%%%%%%%%%%%% Environment LTS Figure %%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}
\begin{mathpar}
	\inferrule[\eltsrule{SRv}]{
		\dual{s} \notin \dom{\Delta}
		\and
		\Gamma; \Lambda'; \Delta' \proves V \hastype U
	}{
		(\Gamma; \Lambda; \Delta \cat s: \btinp{U} S) \by{\bactinp{s}{V}} (\Gamma; \Lambda\cat\Lambda'; \Delta\cat\Delta' \cat s: S)
	}
	\and
	\inferrule[\eltsrule{ShRv}]{
		\Gamma; \es; \es \proves a \hastype \chtype{U}
		\and
		\Gamma; \Lambda'; \Delta' \proves V \hastype U
	}{
		(\Gamma; \Lambda; \Delta) \by{\bactinp{a}{{V}}} (\Gamma; \Lambda\cat\Lambda'; \Delta\cat\Delta')
	}
	\and
	\inferrule[\eltsrule{SSnd}]{
		\begin{array}{l}
			\Gamma \cat \Gamma'; \Lambda'; \Delta' \proves V \hastype U
			\and
			\Gamma'; \es; \Delta_j \proves m_j  \hastype U_j
			\and
			\dual{s} \notin \dom{\Delta}
			\\
			\Delta'\backslash (\cup_j \Delta_j) \subseteq (\Delta \cat s: S)
			\and
			\Gamma'; \es; \Delta_j' \proves \dual{m}_j  \hastype U_j'
			\and
			\Lambda' \subseteq \Lambda
		\end{array}
	}{
		(\Gamma; \Lambda; \Delta \cat s: \btout{U} S)
		\by{\news{\widetilde{m}} \bactout{s}{V}}
		(\Gamma \cat \Gamma'; \Lambda\backslash\Lambda'; (\Delta \cat s: S \cat \cup_j \Delta_j') \backslash \Delta')
	}
	\and
	\inferrule[\eltsrule{ShSnd}]{
		\begin{array}{l}
			\Gamma \cat \Gamma' ; \Lambda'; \Delta' \proves V \hastype U
			\and
			\Gamma'; \es; \Delta_j \proves m_j \hastype U_j
			\and
			\Gamma ; \es ; \es \proves a \hastype \chtype{U}
			\\
			\Delta'\backslash (\cup_j \Delta_j) \subseteq \Delta
			\and
			\Gamma'; \es; \Delta_j' \proves \dual{m}_j\hastype U_j'
			\and
			\Lambda' \subseteq \Lambda
		\end{array}
	}{
		(\Gamma ; \Lambda; \Delta) \by{\news{\widetilde{m}}
		\bactout{a}{V}}
		(\Gamma \cat \Gamma'; \Lambda\backslash\Lambda'; (\Delta \cat \cup_j \Delta_j') \backslash \Delta')
	}
	\and
	\inferrule[\eltsrule{Sel}]{
		\dual{s} \notin \dom{\Delta}
		\and
		j \in I
	}{
		(\Gamma; \Lambda; \Delta \cat s: \btsel{l_i: S_i}_{i \in I}) \by{\bactsel{s}{l_j}} (\Gamma; \Lambda; \Delta \cat s:S_j)
	}
	\and
	\inferrule[\eltsrule{Bra}]{
		\dual{s} \notin \dom{\Delta} \quad j \in I
	}{
		(\Gamma; \Lambda; \Delta \cat s: \btbra{l_i: T_i}_{i \in I}) \by{\bactbra{s}{l_j}} (\Gamma; \Lambda; \Delta \cat s:S_j)
	}
	\and
	\inferrule[\eltsrule{Tau}]{
		\Delta_1 \red \Delta_2 \vee \Delta_1 = \Delta_2
	}{
		(\Gamma; \Lambda; \Delta_1) \by{\tau} (\Gamma; \Lambda; \Delta_2)
	}
\end{mathpar}
%
\caption{Labelled Transition System for Typed Environments. 
\label{fig:envLTS}}
%
\end{figure}


%%%%%%%%%%%%%%%%%%%% End Environment LTS Figure %%%%%%%%%%%%%%%%%%%%%%



\noi
The typed LTS  combines
the LTSs in \figref{fig:untyped_LTS}
and \figref{fig:envLTS}. 

\begin{definition}[Typed Transition System]
	\label{d:tlts}
	A {\em typed transition relation} is a typed relation
	$\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_2}{P_2}$
	where:
%
	\begin{enumerate}
		\item
				$P_1 \by{\ell} P_2$ and 
		\item
				$(\Gamma, \emptyset, \Delta_1) \by{\ell} (\Gamma, \emptyset, \Delta_2)$ 
				with $\Gamma; \emptyset; \Delta_i \proves P_i \hastype \Proc$ ($i=1,2$).
%				\dk{We sometimes annotated the output action with
%				the type of value $V$ as in $\widetilde{m} \bactout{n}{V: U}$.}
	\end{enumerate}
%
	We 
	%extend to $\By{}$ and $\By{\hat{\ell}}$  where we 
	write  $\By{}$ for the reflexive and transitive closure of $\by{}$,
	$\By{\ell}$ for the transitions $\By{}\by{\ell}\By{}$, and $\By{\hat{\ell}}$
	for $\By{\ell}$ if $\ell\not = \tau$ otherwise $\By{}$.
\end{definition}

\newc{A typed transition relation requires type judgements with an empty $\Lambda$. 
Notice that we are working with closed terms.
Furthermore, we can always apply Rule~$\trule{EProm}$ and obtain an empty $\Lambda$. 
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Reduction closed barbed congruence
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Reduction-Closed, Barbed Congruence ($\cong$)}
\label{subsec:rc}

\noi We now define \emph{typed relations} and \emph{contextual equivalence} (i.e., barbed congruence).  
To define typed relations, we first define \emph{confluence}
over session environments $\Delta$.
\newc{Recall that 
$\Delta$ captures session communication, which is deterministic. 
The notion of confluence allows us to abstract away from alternative computation paths 
that may arise due to non-interfering reductions of session names.}

%
\begin{definition}[Session Environment Confluence]\label{d:conf}
	Two session environments $\Delta_1$ and $\Delta_2$
	are \emph{confluent}, denoted $\Delta_1 \bistyp \Delta_2$,
	if there exists $\Delta$ such that:
	i)~$\Delta_1 \red^\ast \Delta$ and 
	ii)~$\Delta_2 \red^\ast \Delta$
	(here we write $\red^\ast$ for the multi-step reduction in \defref{d:wtenvred}).
\end{definition}
Typed relations relate only closed terms whose
session environments are balanced  and confluent:

\begin{definition}[Typed Relation]
	We say that a binary relation over typing judgements
	\[
		\Gamma; \emptyset; \Delta_1 \proves P_1 \hastype \Proc\ \Re \ \Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc
	\]
%
	\noi
	is a {\em typed relation} whenever:
	\begin{enumerate}
		\item	$P_1$ and $P_2$ are closed;
		\item	$\Delta_1$ and $\Delta_2$ are balanced (cf. \defref{d:wtenvred}); and
		\item	$\Delta_1 \bistyp \Delta_2$ (cf. \defref{d:conf}).
	\end{enumerate}
	\end{definition}
\begin{notation}[Typed Relations]
	We write
	\[
		\horel{\Gamma}{\Delta_1}{P_1}{\ \Re \ }{\Delta_2}{P_2}
	\]
	to denote the typed relation 
		$\Gamma; \emptyset; \Delta_1 \proves P_1 \hastype \Proc\ \Re \ \Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$.
\end{notation}	
%\end{definition}


Next we define  {\em barbs}~\cite{MiSa92}
with respect to types. 

\begin{definition}[Barbs]
	\label{def:barbs}
	Let $P$ be a closed process. We write
	\begin{enumerate}
		\item
				\begin{enumerate}
					\item	$P \barb{n}$ if $P \scong \newsp{\tilde{m}}{\bout{n}{V} P_2 \Par P_3}$
					or %, with $n \notin \tilde{m}$.
					%\item	
					%$P \barb{n}$ if 
					$P \scong \newsp{\tilde{m}}{\bsel{n}{l} P_2 \Par P_3}$, with $n \notin \tilde{m}$.
					\item	We write $P \Barb{n}$ if $P \red^* \barb{n}$.
				\end{enumerate}

		\item	Similarly, we write
				\begin{enumerate}
					\item	$\Gamma; \emptyset; \Delta \proves P \barb{n}$ if
							$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ with $P \barb{n}$ and $\dual{n} \notin \Delta$.
					\item	We write $\Gamma; \emptyset; \Delta \proves P \Barb{n}$ if $P \red^* P'$ and
							$\Gamma; \emptyset; \Delta' \proves P' \barb{n}$.
				\end{enumerate}
	\end{enumerate}
\end{definition}

\noi A barb $\barb{n}$ is an observable on an output (resp. select) prefix with subject $n$;
a weak barb $\Barb{n}$ is a barb after zero or more reduction steps.
Typed barbs $\barb{n}$ (resp.\ $\Barb{n}$)
are observed  on typed processes $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$.
When $n$ is a session name we require that its dual endpoint $\dual{n}$ is not
present in the session environment $\Delta$.

\newc{Notice that observing output  barbs is enough 
to (indirectly) observe input actions. For instance, the process $P = \binp{n}{x} P'$ has an input barb on $n$; by composing $P$
with  $\bout{n}{m} \bout{\suc}{} \inact$ (with fresh $\suc$) then one obtains a (weak) observation
uniquely associated to  the input along $n$ in $P$. }

To define a congruence relation, we introduce the family $\C$ of contexts:

\begin{definition}[Context]
	Context $\C$ is defined over the syntax:
%
	\begin{eqnarray*}
		\C & ::= & \hole \bnfbar \bout{u}{V} \C \bnfbar \binp{u}{x} \C \bnfbar \bout{u}{\lambda x.\C} P \bnfbar \news{n} \C \bnfbar
		(\lambda x.\C)u \bnfbar \recp{X}{\C}\\ 
		& \bnfbar & \C \Par P \bnfbar P \Par \C \bnfbar \bsel{u}{l} \C \bnfbar \bbra{u}{l_1:P_1,\cdots,l_i:\C,\cdots,l_n:P_n}
	\end{eqnarray*}
%
	Notation $\context{\C}{P}$ denotes the result of substituting 
	the hole $\hole$ in $\C$ with process $P$.
\end{definition}

\noi The first behavioural relation we define is reduction-closed, barbed congruence \cite{HondaKYoshida95}. 

\begin{definition}[Reduction-Closed, Barbed Congruence]
\label{def:rc}
	Typed relation
	\[
		\horel{\Gamma}{\Delta_1}{P}{\ \Re\ }{\Delta_2}{Q}
	\]
	is a {\em reduction-closed, barbed congruence} whenever:
%
	\begin{enumerate}[1)]
		\item
				\begin{enumerate}
					\item	If $P \red P'$ then there exist $\Delta_1', Q', \Delta_2'$ such that $Q \red^* Q'$ and\\
							$\horel{\Gamma}{\Delta_1'}{P'}{\ \Re\ }{\Delta_2'}{Q'}$;
					\item	and the symmetric case;
				\end{enumerate}
		\item
				\begin{enumerate}
					\item	If $\Gamma;\Delta_1 \proves P \barb{n}$ then $\Gamma;\Delta_2 \proves Q \Barb{n}$;
					\item	and the symmetric case;
				\end{enumerate}

		\item	For all $\C$, there exist $\Delta_1'',\Delta_2''$ such that
				$\horel{\Gamma}{\Delta_1''}{\context{\C}{P}}{\ \Re\ }{\Delta_2''}{\context{\C}{Q}}$.
	\end{enumerate}
	The largest such relation is denoted with $\cong$.
\end{definition}

\subsection{Context Bisimilarity ($\wbc$)}
\label{subsec:bisimulation}

Following Sangiorgi~\cite{San96H}, 
we now define the standard (weak) context bisimilarity. 
%
\begin{definition}[Context Bisimilarity]
	\label{def:wbc}
	A typed relation $\Re$ is {\em a context bisimulation} if
	for all $\horel{\Gamma}{\Delta_1}{P_1}{\ \Re \ }{\Delta_2}{Q_1}$,
%
	\begin{enumerate}[1)] 
		\item
				Whenever 
				$\horel{\Gamma}{\Delta_1}{P_1}{\by{\news{\widetilde{m_1}} \bactout{n}{V_1}}}{\Delta_1'}{P_2}$,
				there exist $Q_2$, $V_2$, $\Delta'_2$
				such that $\horel{\Gamma}{\Delta_2}{Q_1}{\By{\news{\widetilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}$ and 
				for all $R$ with $\fv{R}=\{x\}$:
%
			\[
				\horel{\Gamma}{\Delta_1''}{\newsp{\widetilde{m_1}}{P_2 \Par R\subst{V_1}{x}}}
				{\ \Re\ }
				{\Delta_2''}{\newsp{\widetilde{m_2}}{Q_2 \Par R\subst{V_2}{x}}};
			\]

		\item	
				For all $\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_1'}{P_2}$ such that 
				$\ell$ is not an output, there exist $Q_2$, $\Delta'_2$ such that 
				$\horel{\Gamma}{\Delta_2}{Q_1}{\By{\hat{\ell}}}{\Delta_2'}{Q_2}$
				and
				$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re \ }{\Delta_2'}{Q_2}$; and  

		\item
				The symmetric cases of 1 and 2.                
	\end{enumerate}
%
	The largest such bisimulation is called \emph{context bisimilarity} and is denoted by $\wbc$.
\end{definition}

\noi As suggested in
%\secref{subsec:intro:bisimulation}, 
\secref{sec:overview}, in the general case,
\newc{context bisimilarity is an overly demanding relation on processes}.
Below we introduce \emph{higher-order bisimulation} and \emph{characteristic bisimulation},
which are meant to offer a \emph{tractable} proof technique over session typed
processes with higher-order communication.
%$\hwb$ and  $\fwb$.
%due to: (1) the universal
%quantification over contexts in the output case;
%and (2) a higher-order input prefix which can observe
%infinitely many different input actions (since
%infinitely many different processes can match
%the session type of an input prefix).

\subsection{Characteristic Values and the Refined LTS}
\label{ss:reflts}

\noi 
We formalise the ideas given in \secref{sec:overview}, concerning 
characteristic processes/values and the refined LTS.
%the introduction.
We first define characteristic processes/values:

\begin{definition}[Characteristic Process and Values]
	\label{def:char}
	Let $u$ and $U$ be a name and a type, respectively.
	\newc{The {\em characteristic process} of $U$ (along $u$), denoted $\mapchar{U}{u}$, and 
	the {\em characteristic value} of $U$, denoted $\omapchar{U}$, are defined in \figref{fig:char}.}
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%% Characteristic Process Figure %%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}
%\[
%	\begin{array}{rclcrcl}
%		\mapchar{\btinp{U} S}{u}
%		&\defeq&
%		\binp{u}{x} (\mapchar{S}{u} \Par \mapchar{U}{x})
%		&\qquad &
%		\omapchar{S}  & \defeq &  s ~~ (s \textrm{ fresh})
%		\\
%		\mapchar{\btout{U} S}{u}
%		&\defeq&
%		\bout{u}{\omapchar{U}} \mapchar{S}{u}  
%		&&
%		\omapchar{\chtype{S}} \defeq \omapchar{\chtype{L}} &\defeq&a ~~ (a \textrm{ fresh})
%		\\
%		\mapchar{\btsel{l : S}}{u}
%		& \defeq &
%		\bsel{u}{l} \mapchar{S}{u}
%		&&
%		\omapchar{\shot{U}} \defeq \omapchar{\lhot{U}} & \defeq &  \abs{x}{\mapchar{U}{x}}
%		\\
%				\mapchar{\btbra{l_i: S_i}_{i \in I}}{u}
%		& \defeq &
%		\bbra{u}{l_i: \mapchar{S_i}{u}}_{i \in I}
%		&&
%		 
%		&   &
%		 
%		\\
%		\mapchar{\tvar{t}}{u}
%		&\defeq&
%		\varp{X}_{\vart{t}}
%		& & 
%		 
%		& &
%		 
%		\\
%		\mapchar{\trec{t}{S}}{u}Thank you Oleg

%		&\defeq&
%		\recp{X_{\vart{t}}}{\mapchar{S}{u}}
%		&&
%		 
%		& &
%		 
%		\\
%		\mapchar{\tinact}{u}
%		& \defeq &
%		\inact
%		& & 
%		  
%		& &
%		 
%		\\
%		\mapchar{\chtype{S}}{u} 
%		&\defeq&
%		\bout{u}{\omapchar{S}} \inact
%		& & 	
%					 
%		&   &
%		 
%		\\
%		\mapchar{\chtype{L}}{u}
%		&\defeq&
%		 \bout{u}{\omapchar{L}} \inact
%		&&
%		 
%		& &
% 
%		\\
%		\mapchar{\shot{U}}{u}
%		\defeq 
%		\mapchar{\lhot{U}}{u}
%		&\defeq &
%		\appl{u}{\omapchar{U}}
%		&&
%		 
%		& &
%		 	\end{array}
%	\]

	\begin{comment}
\[
	\begin{array}{rclcrcl}
		\mapchar{\btinp{U} S}{u}
		&\defeq&
		\binp{u}{x} (\binp{t}{y} (\appl{y}{u}) \Par \mapchar{U}{x})
		&\qquad &
		\omapchar{S}  & \defeq &  s ~~ (s \textrm{ fresh})
		\\
		\mapchar{\btout{U} S}{u}
		&\defeq&
		\bout{u}{\omapchar{U}} \binp{t}{y} (\appl{y}{x})
		&&
		\omapchar{\chtype{S}} \defeq \omapchar{\chtype{L}} &\defeq&a ~~ (a \textrm{ fresh})
		\\
		\mapchar{\btsel{l : S}}{u}
		& \defeq &
		\bsel{u}{l} \binp{t}{y} (\appl{y}{x})
		&&
		\omapchar{\shot{U}} \defeq \omapchar{\lhot{U}} & \defeq &  \abs{x}{\mapchar{U}{x}}
		\\
		\mapchar{\btbra{l_i: S_i}_{i \in I}}{u}
		& \defeq &
		\bbra{u}{l_i: \binp{t}{y} (\appl{y}{x})}_{i \in I}
		&&
		 
		&   &
		 
%		\\
%\dk{		\mapchar{\tvar{t}}{u}}
%		&\defeq&
%		\varp{X}_{\vart{t}}
%		& & 
%		 
%		& &		 
		\\
\dk{		\mapchar{\trec{t}{S}}{u}}
		&\defeq&
%		\recp{X_{\vart{t}}}{\mapchar{S}{u}}
		\mapchar{S \subst{\trec{t}{S}}{\vart{t}}}{u}
		&&
		 
		& &
		 
		\\
		\mapchar{\tinact}{u}
		& \defeq &
		\inact
		& & 
		  
		& &
		 
		\\
		\mapchar{\chtype{S}}{u} 
		&\defeq&
		\bout{u}{\omapchar{S}} \binp{t}{y} (\appl{y}{x})
		& & 	
					 
		&   &
		 
		\\
		\mapchar{\chtype{L}}{u}
		&\defeq&
		 \bout{u}{\omapchar{L}} \binp{t}{y} (\appl{y}{x})
		&&
		 
		& &
 
		\\
		\mapchar{\shot{U}}{u}
		\defeq 
		\mapchar{\lhot{U}}{u}
		&\defeq &
		\appl{u}{\omapchar{U}}
		&&
		 
		& &
		 	\end{array}
	\]
\end{comment}
\[
	\begin{array}{rclcrcl}
		\mapchar{\btinp{U} S}{u}
		&\defeq&
		\binp{u}{x} (\bout{t}{u} \inact \Par \mapchar{U}{x})
		&\qquad &
		\omapchar{S}  & \defeq &  s ~~ (s \textrm{ fresh})
		\\
		\mapchar{\btout{U} S}{u}
		&\defeq&
		\bout{u}{\omapchar{U}} \bout{t}{u} \inact
		&&
		\omapchar{\chtype{S}} &\defeq& a ~~ (a \textrm{ fresh})
		\\
		\mapchar{\btsel{l : S}}{u}
		& \defeq &
		\bsel{u}{l} \bout{t}{u} \inact
		&&
		\omapchar{\chtype{L}} &\defeq&a ~~ (a \textrm{ fresh})
		\\
		\mapchar{\btbra{l_i: S_i}_{i \in I}}{u}
		& \defeq &
		\bbra{u}{l_i: \bout{t_i}{u} \inact}_{i \in I}		 
		&&
		\omapchar{\shot{U}} &\defeq& \abs{x}{\mapchar{U}{x}}
		\\
		 
%		\\
%		\mapchar{\tvar{t}}{u}
%		&\defeq&
%		\varp{X}_{\vart{t}}
%		\\
%
		\mapchar{ \trec{t}{S} }{u} &\defeq& \mapchar{S \subst{\tinact}{\vart{t}} }{u}

		&&
		\omapchar{\lhot{U}} & \defeq &  \abs{x}{\mapchar{U}{x}}
		\\
		\mapchar{\tinact}{u}
		& \defeq &
		\inact
		\\
		\mapchar{\chtype{S}}{u} 
		&\defeq&
		\bout{u}{\omapchar{S}} \bout{t}{u} \inact		 
		\\
		\mapchar{\chtype{L}}{u}
		&\defeq&
		 \bout{u}{\omapchar{L}} \bout{t}{u} \inact 
		\\
		\mapchar{\shot{U}}{u}
		&\defeq& 
		\appl{u}{\omapchar{U}}
		\\
		\mapchar{\lhot{U}}{u}
		&\defeq &
		\appl{u}{\omapchar{U}}
	\end{array}
	\]

%\[
%	\begin{array}{rclcrcl}
%		\mapchar{\btinp{U} S}{u}
%		&\defeq&
%		\binp{u}{x} (\mapchar{S}{u} \Par \mapchar{U}{x})
%		&&
%		\mapchar{\btout{U} S}{u}
%		&\defeq&
%		\bout{u}{\omapchar{U}} \mapchar{S}{u} %& & n \textrm{ fresh}
%		\\
%
%		\mapchar{\btsel{l : S}}{u}
%		& \defeq &
%		\bsel{u}{l} \mapchar{S}{u}
%		&&
%		\mapchar{\btbra{l_i: S_i}_{i \in I}}{u}
%		& \defeq &
%		\bbra{u}{l_i: \mapchar{S_i}{u}}_{i \in I}
%		\\
%
%		\mapchar{\tvar{t}}{u}
%		&\defeq&
%		\varp{X}_{\vart{t}}
%		& & 
%		\mapchar{\trec{t}{S}}{u}
%		&\defeq&
%		\recp{X_{\vart{t}}}{\mapchar{S}{u}}
%		\\
%
%		\mapchar{\tinact}{u}
%		& \defeq &
%		\inact
%		& & 
%		\mapchar{\chtype{S}}{u} 
%		&\defeq&
%		\bout{u}{\omapchar{S}} \inact
%		\\
%
%		\mapchar{\chtype{L}}{u}
%		&\defeq&
%		\bout{u}{\omapchar{L}} \inact
%		&&
%		\mapchar{\shot{U}}{u}
%		&\defeq &
%		\mapchar{\lhot{U}}{u}
%		\, \defeq \,
%		\appl{u}{\omapchar{U}}
%	\end{array}
%	\]
%	\[
%	\begin{array}{c}
%		\omapchar{S}  \defeq  s ~~ (s \textrm{ fresh})
%		\qquad
%		\omapchar{\chtype{S}} \defeq \omapchar{\chtype{L}} \defeq a ~~ (a \textrm{ fresh})
%		\qquad
%		\omapchar{\shot{U}} \defeq \omapchar{\lhot{U}} \,\defeq\, \abs{x}{\mapchar{U}{x}}
%	\end{array}
%	\]
%
\caption{Characteristic Processes (left) and Characteristic Values (right).\label{fig:char}}
%
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%% End Characteristic Process Figure %%%%%%%%%%%%%%%%%%%%%


\noi We can verify that characteristic processes/values  
do inhabit their associated type.

\begin{proposition}[Characteristic Processes/Values Inhabit Their Types]\label{p:inhabit}
	\begin{enumerate}
		\item	Let $U$ be a channel type.
				Then $\Gamma; \es; \Delta \proves \omapchar{U} \hastype U$.
		\item	
				Let $S$ be a session type.
				Then $\Gamma; \es; \Delta \cat s: S \proves \mapchar{S}{s} \hastype \Proc$.
		\item	
				Let $U$ be a channel type.
				Then $\Gamma \cat a: U; \es; \Delta \proves \mapchar{U}{a} \hastype \Proc$.

	\end{enumerate}
\end{proposition}

\begin{proof}[Sketch]
	The proof is done by induction on the syntax of types.
	We give some notable cases in the Appendix---see \propref{app:characteristic_inhabit} (\mypageref{app:characteristic_inhabit})
	\qed
\end{proof}

\dk{
	We show an example of a characteristic process inhabiting a
	recursive type.
	\begin{example}
		Let recursive type $S = \trec{t}{ \btout{S'} \vart{t}}$.
		From the definition of the characteristic process for 
		recursive types we get:
		\[
			\mapchar{\trec{t}{ \btout{S'} \vart{t}}}{s} = \mapchar{ \btout{S'} \trec{t}{ \btout{S'} \vart{t}} }{s}
		\]
		From the definition of the characteristic process for the output
		prefixed session types we get:
		\[
			\bout{s}{s'} \bout{t}{s} \inact
		\]
%		Note that we get the same characteristic process even if we unfold the type more than once:
%		\[
%		\mapchar{ \btout{S'} \btout{S'} \trec{t}{ \btout{S'} \vart{t}} }{s} = \bout{s}{s'} \bout{t}{s} \inact
%		\]
%		If we type the characteristic process for $S$ we get:
%		\[
%			\Gamma; \es; s: S \cat s':S' \cat t: \btout{S} \tinact \proves \bout{s}{s'} \bout{t}{s} \inact \hastype \Proc
%		\]
	\end{example}
}

The following example motivates the refined 
LTS explained in \secref{sec:overview}.
We rely on the following definition.

\begin{definition}[Trigger Value]\label{d:trigger}
Given a fresh name $t$, the \emph{trigger value} on $t$ is defined as the abstraction
$\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}$.
\end{definition}

%\newc{In the following, in all uses of the trigger value $\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}$ name $t$ is assumed fresh.}
%the introduction.


%\begin{example}
%	Consider the type $U = \shot{(\shot{(\shot{(\btout{S} \tinact)})})}$.
%	It is easy to verify that %the characteristic process %of the above type is:
%	$\mapchar{\btinp{U} \inact}{s} = \binp{s}{x} \appl{x}{(\abs{y}{\appl{y}{n})}}$, for some fresh $n$.
%%%
%%	\begin{eqnarray*}
%%		\mapchar{\btinp{U} \inact}{s} = && \binp{s}{x} \mapchar{\shot{(\shot{(\shot{(\btout{S} \tinact)})})}}{x}\\
%%		= && \binp{s}{x} \appl{x}{\omapchar{\shot{(\shot{(\btout{S} \tinact)})}}}\\
%%		= && \binp{s}{x} \appl{x}{(\abs{y}{\mapchar{\shot{(\btout{S} \tinact)}}{y}})}\\
%%		= && \binp{s}{x} \appl{x}{(\abs{y}{\appl{y}{\omapchar{\btout{S} \tinact}})}}\\
%%		= && \binp{s}{x} \appl{x}{(\abs{y}{\appl{y}{n})}}\\
%%	\end{eqnarray*}
%%%
%	\qed
%\end{example}


\begin{example}[The Need for the Refined Typed LTS]
	\dkmargin{check if this example is OK. \newc{JP: looks OK}}
	\label{ex:motivation}
	We illustrate the complementary r\^{o}le that characteristic values 
	(cf. \figref{fig:char})
	and the trigger value (\defref{d:trigger}) play in defining sound bisimilarities.
	
	We first notice that observing  characteristic values
	as inputs
	is not enough
	to define a sound bisimulation.
	Consider   processes % $P_1, P_2$:
%
	\begin{eqnarray}
		P_1 = \binp{s}{x} (\appl{x}{s_1} \Par \appl{x}{s_2}) 
		&\qquad \qquad& 
		P_2 = \binp{s}{x} (\appl{x}{s_1} \Par \appl{(\abs{z}{\inact})}{s_2}) 
		\label{equ:6}
	\end{eqnarray}
%
%
%
%	\begin{eqnarray}
%		P_1 = \binp{s}{x} (\appl{x}{s_1} \Par \appl{x}{s_2}) 
%		&\qquad \qquad& 
%		P_2 = \binp{s}{x} (\appl{x}{s_1} \Par \binp{s_2}{y} \inact) 
%		\label{equ:6}
%	\end{eqnarray}
%
%	where $\Delta = s_1: \btinp{C} \tinact \cat s_2: \btinp{C} \tinact$ and:
such that 
	\[
		\Gamma; \es; \Delta \cat s: \btinp{\shot{\tinact}} \tinact \proves P_i \hastype \Proc \qquad (i \in \set{1,2})
	\]
with $\Delta = s_1{:}\tinact \cat s_2{:}\tinact$.
%
%	\[
%		\Gamma; \es; \Delta \cat s: \btinp{\shot{(\btinp{C} \tinact)}} \tinact \proves P_i \hastype \Proc \qquad (i \in \set{1,2})
%	\]
%
	If $P_1$ and $P_2$ input along $s$
	a characteristic value of the form
%	$\omapchar{\shot{(\btinp{C} \tinact)}} = \abs{x}{\binp{x}{y} \inact}$
	$\omapchar{\shot{(\tinact)}} = \abs{z}{\inact}$ (cf. \figref{fig:char}), then both of them  would evolve into:
%
%	\[
%		\Gamma; \es; \Delta \proves \binp{s_1}{y} \inact \Par \binp{s_2}{y} \inact \hastype \Proc
%	\]
%
%
	\[
		\Gamma; \es; \Delta \proves \appl{(\abs{z}{\inact})}{s_1} \Par \appl{(\abs{z}{\inact})}{s_2} \hastype \Proc
	\]
%
	\noi therefore becoming context bisimilar.
	However, processes $P_1$ and $P_2$ in (\ref{equ:6}) 
	are clearly {\em not} context bisimilar: many input actions
	may be used to distinguish them.
	For example, if  $P_1$ and $P_2$ input
%
%	$\abs{x} \newsp{s'}{\bout{a}{s'} \binp{x}{y} \inact}$
%
	$\abs{x} \newsp{s'}{\bout{a}{s'} \inact}$
	with
%
	$\Gamma; \es; \es \proves a \hastype \chtype{\tinact}$,
%
	then their derivatives are not bisimilar:
%
%\[
%	\begin{array}{rcll}
%		\Gamma; \es; \Delta &\proves& P_1 \by{\bactinp{s}{\abs{x} \newsp{s'}{\bout{a}{s'} \binp{x}{y} \inact}}} \red \red\\
%		\Delta &\proves& \newsp{s'}{\bout{a}{s'} \binp{s_1}{y} \inact} \Par \newsp{s'}{\bout{a}{s'} \binp{s_2}{y} \inact}
%		\\[4mm]
%		\Gamma; \es; \Delta &\proves& P_2 \by{\bactinp{s}{\abs{x} \newsp{s'}{\bout{a}{s'} \binp{x}{y} \inact}}} \red\\
%		\Delta &\proves& \newsp{s'}{\bout{a}{s'} \binp{s_1}{y} \inact} \Par \binp{s_2}{y} \inact
%	\end{array}
%\]
\[
	\begin{array}{rcll}
		\Gamma; \es; \Delta &\proves& P_1 \by{\bactinp{s}{\abs{x} \newsp{s'}{\bout{a}{s'} \inact}}} \red \red\\
		\Delta &\proves& \newsp{s'}{\bout{a}{s'} \inact} \Par \newsp{s'}{\bout{a}{s'} \inact}
		\\[4mm]
		\Gamma; \es; \Delta &\proves& P_2 \by{\bactinp{s}{\abs{x} \newsp{s'}{\bout{a}{s'} \inact}}} \red\\
		\Delta &\proves& \newsp{s'}{\bout{a}{s'} \inact} \Par \appl{(\abs{z}{\inact})}{s_2}
	\end{array}
\]

	Observing only the characteristic value
	results in an under-discriminating bisimulation.
	However, if a trigger value
	$\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}$  (\defref{d:trigger})
	is received along $s$, 
	we can distinguish $P_1$ and $P_2$ in~\eqref{equ:6}:  
	%
	\begin{eqnarray*}
		\Gamma; \es; \Delta \proves
		P_1 &\By{\bactinp{s}{\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}}}& \Delta \proves \binp{t}{x} (\appl{x}{s_1}) \Par \binp{t}{x} (\appl{x}{s_2})
%		\hastype \Proc
		\qquad \mbox{and}\\
		\Gamma; \es; \Delta \proves
		P_2 &\By{\bactinp{s}{\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}}}& \Delta \proves \binp{t}{x} (\appl{x}{s_1}) \Par \appl{(\abs{z}{\inact})}{s_2} 
%		\hastype \Proc
	\end{eqnarray*}
%
	In the light of this example, one natural question is whether the trigger value suffices
	to distinguish two processes (hence no need of characteristic values). % as the input. 
	This is not the case: the trigger value
	alone also results in an under-discriminating bisimulation relation.
	In fact, the  trigger value can be observed on any input prefix
	of {\em any type}. For example, consider processes:
%
	\begin{eqnarray}
%		\Gamma; \es; \Delta \proves 
		\newsp{s}{\binp{n}{x} (\appl{x}{s}) \Par \bout{\dual{s}}{\abs{x} R_1} \inact} 
%		\hastype \Proc
		\label{equ:7}
		\\
%		\qquad \mbox{and} \qquad
%		\Gamma; \es; \Delta \proves 
		\newsp{s}{\binp{n}{x} (\appl{x}{s}) \Par \bout{\dual{s}}{\abs{x} R_2} \inact} 
%		\hastype \Proc
		\label{equ:8}
	\end{eqnarray}
%
	\noi If processes in \eqref{equ:7} and \eqref{equ:8}
	input the trigger value, we obtain:
%
	\begin{eqnarray*}
%		\Gamma; \es; \Delta \proves 
		\newsp{s}{\binp{t}{x} (\appl{x}{s}) \Par \bout{\dual{s}}{\abs{x} R_1} \inact} 
%		\hastype \Proc
%		\qquad \mbox{ and } \qquad
		\\
%		\Gamma; \es; \Delta \proves 
		\newsp{s}{\binp{t}{x} (\appl{x}{s}) \Par \bout{\dual{s}}{\abs{x} R_2} \inact}
%		\hastype \Proc
	\end{eqnarray*}

	\noi thus we can easily derive a bisimulation relation if we 
	assume a definition of bisimulation that allows only trigger value input.
%
%	\noi It is easy to obtain a closure if allow only the
%	trigger value as the input value. 
	But if processes in \eqref{equ:7}/\eqref{equ:8}
	input the characteristic value
%	$\abs{z}{\binp{z}{x} (\appl{x}{m})}$,
	$\abs{z}{\binp{z}{x} ( \bout{t}{z} \inact \Par \appl{x}{m})}$,
	\newc{where $m$ is a fresh name}, 
	then they would become, under appropriate $\Gamma$ and $\Delta$:
%
%	\begin{eqnarray*}
%		\Gamma; \es; \Delta \proves \newsp{s}{\binp{s}{x} (\appl{x}{m}) \Par \bout{\dual{s}}{\abs{x} R_i} \inact}\ \wbc\ \Delta \proves R_i \subst{m}{x}
%	\qquad (i=1,2)
%	\\
%	\Gamma; \es; \Delta \proves \newsp{s}{\binp{s}{x} (\appl{x}{m}) \Par \bout{\dual{s}}{\abs{x} Q} \inact} \wbc \Delta \proves Q \subst{m}{x}
%	\end{eqnarray*}
%
%
	\begin{eqnarray*}
		\Gamma; \es; \Delta \proves \newsp{s}{\binp{s}{x} (\bout{t}{s} \inact \Par \appl{x}{m}) \Par \bout{\dual{s}}{\abs{x} R_i} \inact}\ \wbc\ \Delta \proves R_i \subst{m}{x}
	\qquad (i=1,2)
%	\\
%	\Gamma; \es; \Delta \proves \newsp{s}{\binp{s}{x} (\appl{x}{m}) \Par \bout{\dual{s}}{\abs{x} Q} \inact} \wbc \Delta \proves Q \subst{m}{x}
	\end{eqnarray*}
%

	\noi which are not bisimilar if $R_1 \subst{m}{x} \not\wbc R_2 \subst{m}{x}$.
	%\qed
	
	These examples illustrate the need for both 
	trigger and characteristic values 
	as an input observation in the refined transition relation.   %(\eltsrule{RRcv})
	This will be the content of \defref{def:rlts} below.
	\qed
\end{example}

\noi As explained in \secref{sec:overview}, 
%the introduction,
we define the
\emph{refined} typed LTS
by considering a transition rule for input in which admitted values are
trigger or characteristic values or names:

%\dk{(assume extension of the structural
%congruence to acommodate values: i) $\abs{x}{P} \scong \abs{x}{Q}$ if
%$P \scong Q$) and ii) $n \scong m$ if $n = n$)}: 

%\begin{definition}[Refined Typed Labelled Transition System]
%	\label{def:rlts}
%	We define the environment transition rule for input actions 
%	using the input rules in \figref{fig:envLTS}:
%	\begin{mathpar}
%		\inferrule[\eltsrule{RRcv}]{
%			(\Gamma_1; \Lambda_1; \Delta_1) \by{\bactinp{n}{V}} (\Gamma_2; \Lambda_2; \Delta_2)
%			\and
%			V = m 
%			\vee  V \scong \omapchar{U}
%			\vee V  \scong \abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}
%			\textrm{ {\small with $t$ fresh}} 
%		}{
%			(\Gamma_1; \Lambda_1; \Delta_1) \hby{\bactinp{n}{V}} (\Gamma_2; \Lambda_2; \Delta_2)
%		}
%	\end{mathpar}
%	\noi Rule $\eltsrule{RRcv}$ is defined on top
%	of rules $\eltsrule{SRv}$ and $\eltsrule{ShRv}$
%	in \figref{fig:envLTS}.
%	We  use the non-input rules in \figref{fig:envLTS}
%	together with rule $\eltsrule{RRcv}$
%	to define 
%	$$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_2}{P_2}$$
%	as in \defref{d:tlts}.
%\end{definition}

\begin{definition}[Refined Typed Labelled Transition System]
	\label{def:rlts}
	\newc{The 
	refined typed labelled transition relation on typing environments 
	$$
	(\Gamma_1; \Lambda_1; \Delta_1) \hby{\ell} (\Gamma_2; \Lambda_2; \Delta_2)
	$$
	is 
	defined by on top of the rules
	in \figref{fig:envLTS} using the following rules:
	\begin{mathpar}
		\inferrule[\eltsrule{Tr}] {
			(\Gamma_1; \Lambda_1; \Delta_1) \by{\ell} (\Gamma_2; \Lambda_2; \Delta_2)
			\and
			\ell \not= \bactinp{n}{V}
		}{
			(\Gamma_1; \Lambda_1; \Delta_1) \hby{\ell} (\Gamma_2; \Lambda_2; \Delta_2)
		}
		\\
		\inferrule[\eltsrule{RRcv}]{
			(\Gamma_1; \Lambda_1; \Delta_1) \by{\bactinp{n}{V}} (\Gamma_2; \Lambda_2; \Delta_2)
			\and
			V = m 
			\vee  V \scong \omapchar{U}
			\vee V  \scong \abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}
			\textrm{ {\small $t$ fresh}} 
		}{
			(\Gamma_1; \Lambda_1; \Delta_1) \hby{\bactinp{n}{V}} (\Gamma_2; \Lambda_2; \Delta_2)
		}
	\end{mathpar}
	Then, the refined typed labelled transition system 
			$$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_2}{P_2}$$
	is given as in \defref{d:tlts}, replacing the requirement 
	$(\Gamma, \emptyset, \Delta_1) \by{\ell} (\Gamma, \emptyset, \Delta_2)$
	with 
	$
	(\Gamma_1; \Lambda_1; \Delta_1) \hby{\ell} (\Gamma_2; \Lambda_2; \Delta_2)
	$, as just defined.
	Also following \defref{d:tlts}, 
	we 
	write  $\Hby{}$ for the reflexive and transitive closure of $\hby{\tau}$,
	$\Hby{\ell}$ for the transitions $\Hby{}\hby{\ell}\Hby{}$, and $\Hby{\hat{\ell}}$
	for $\Hby{\ell}$ if $\ell\not = \tau$ otherwise $\Hby{}$.}
	\end{definition}


 Notice that
the (refined) transition
$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_2}{P_2}$  implies  
the (ordinary) transition
$\horel{\Gamma}{\Delta_1}{P_1}{\by{\,\ell\,}}{\Delta_2}{P_2}$.
\begin{notation}\label{not:outtype}
Below we sometimes write  
$\hby{\news{\widetilde{m}} \bactout{n}{\AT{V}{U}}}$
when the type of $V$ is~$U$.
\end{notation}
%See \exref{ex:motivation} for the reason why {\em both} 
%the trigger values ($\lambda x.\binp{t}{y} (\appl{y}{{x}})$) 
%and characteristic values ($\lambda x.\map{U}^{{x}}$) are required 
%to define the following two bisimulations. 


\subsection{Higher-Order Bisimilarity ($\hwb$) and  Characteristic  Bisimilarity ($\fwb$)}
\label{ss:hwb}
\newc{Having introduced a refined LTS on $\HOp$ processes,}
we now define \emph{higher-order bisimilarity} and 
\emph{characteristic bisimilarity}, 
two tractable bisimilarity relations.
As explained in \secref{sec:overview},
the two bisimulations 
use two different trigger processes (cf.~\eqref{eq:4}):
%
\begin{eqnarray}
	\htrigger{t}{V}	& \defeq &
	\begin{cases}
%	\left\{ \begin{array}{ll}
		\hotrigger{t}{x}{s}{V} & \newc{\text{if $V$ is a first-order value}}\\
		\binp{t}{x} \newsp{s}{\binp{s}{y} (\appl{y}{x}) \Par \bout{\dual{s}}{V} \inact} & \newc{\text{if $V$ is a higher-order value}~~}
	%\end{array}
	%\right.
		\end{cases}
	\label{eqb:0} \\
	\ftrigger{t}{V}{U}	& \defeq &	\fotrigger{t}{x}{s}{U}{V}	\label{eqb:4}
%	\mapchar{\btinp{U} \tinact}{s}
\end{eqnarray}
%
The process in \eqref{eqb:0} is called \emph{higher-order trigger process},
while process in \eqref{eqb:4} is called \emph{characteristic trigger process}.
Notice that while 
in \eqref{eqb:0} there is a higher-order input on $t$, 
in \eqref{eqb:4} variable $x$ does not play any role.

We use higher-order trigger processes to define \emph{higher-order bisimilarity}:

\begin{definition}[Higher-Order Bisimilarity]
	\label{d:hwb}
	A typed relation $\Re$ is a {\em  higher-order bisimulation} if 
	for all $\horel{\Gamma}{\Delta_1}{P_1}{\ \Re \ }{\Delta_2}{Q_1}$ 
%
	\begin{enumerate}[1)]
		\item 
				Whenever 
				$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\widetilde{m_1}} \bactout{n}{V_1}}}{\Delta_1'}{P_2}$, there exist 
				$Q_2$, $V_2$, $\Delta'_2$ such that 
				$\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\widetilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}$ and, for fresh $t$, 
				\[
					\begin{array}{lrlll}
						\Gamma; \Delta''_1  \proves  {\newsp{\widetilde{m_1}}{P_2 \Par \htrigger{t}{V_1}}}
						\ \Re\ 
						\Delta''_2 \proves {\newsp{\widetilde{m_2}}{Q_2 \Par \htrigger{t}{V_2}}}
					\end{array}
				\]
		\item	
				For all $\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}$ such that 
				$\ell$ is not an output, 
				there exist $Q_2$, $\Delta'_2$ such that 
				$\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\hat{\ell}}}{\Delta_2'}{Q_2}$
				and
				$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re \ }{\Delta_2'}{Q_2}$; and 

		\item	The symmetric cases of 1 and 2.                
	\end{enumerate}
%
	The largest such bisimulation is called \emph{higher-order bisimilarity}, denoted by $\hwb$.
\end{definition}


We exploit characteristic trigger processes to define \emph{characteristic bisimilarity}: 

\begin{definition}[Characteristic Bisimilarity]
\label{d:fwb}
	A typed relation $\Re$ is a {\em  characteristic bisimulation} if 
	for all $\horel{\Gamma}{\Delta_1}{P_1}{\ \Re \ }{\Delta_2}{Q_1}$, 
%
	\begin{enumerate}[1)]
		\item 
				Whenever 
				$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\widetilde{m_1}} \bactout{n}{V_1: U_1}}}{\Delta_1'}{P_2}$ 
				then there exist 
				$Q_2$, $V_2$, $\Delta'_2$ such that 
				$\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\widetilde{m_2}}\bactout{n}{V_2: U_2}}}{\Delta_2'}{Q_2}$
				and, for fresh $t$,
%
				\[
					\Gamma; \Delta''_1  \proves  {\newsp{\widetilde{m_1}}{P_2 \Par \ftrigger{t}{V_1}{U_1}}}
	 				\ \Re\ 
					\Delta''_2 \proves {\newsp{\widetilde{m_2}}{Q_2 \Par \ftrigger{t}{V_2}{U_2}}}
				\]

		\item	
				For all $\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}$ such that 
				$\ell$ is not an output, there exist $Q_2$, $\Delta'_2$ such that 
				$\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\hat{\ell}}}{\Delta_2'}{Q_2}$
				and
				$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re \ }{\Delta_2'}{Q_2}$; and 

		\item	The symmetric cases of 1 and 2.                
	\end{enumerate}
%
	The largest such bisimulation is called \emph{characteristic bisimilarity}, denoted by $\fwb$.
\end{definition}

Observe how we have used \notref{not:outtype} to explicitly refer to the type in output actions.

\newc{
\begin{remark}[Differences between $\hwb$ and $\fwb$]
Although $\hwb$ and $\fwb$ are conceptually similar, they differ in the kind of 
trigger process considered. Because of the application in 
$\htrigger{t}{V}$ (cf. \eqref{eqb:0}), $\hwb$ cannot be used to reason about first-order session processes (i.e., processes without higher-order features). In contrast, $\fwb$ is more general: it can uniformly input characteristic, first- or higher-order values. 
\end{remark}
}

%\dk{
%\begin{example}
%	\begin{eqnarray*}
%			&&\Gamma; \es; s: S \cat s_1:S' \cat t: \btout{S} \tinact \proves \bout{s}{s_1} \bout{t}{s} \inact
%			\\
%			&&\hby{\bactout{s}{s'}}
%			\Gamma; \es; s: S \cat s_1:S' \cat t: \btout{S} \tinact \cat t_1': \btinp{\btinp{S'} \tinact} \tinact \proves \htrigger{t_1'}{s_1} \Par \bout{t}{s} \inact
%			\\
%			&&\hby{\bactout{t}{s}}
%			\Gamma; \es; s: S \cat s_1:S' \cat t_1: \btinp{\btinp{S} \tinact} \tinact \cat t_1': \btinp{\btinp{S'} \tinact} \tinact \proves \htrigger{t_1'}{s_1} \Par \htrigger{t_1}{s}
%			\\
%			&&\hby{\bactinp{t}{ \omapchar{\btinp{S} \tinact} }} \hby{\dtau} \hby{\dtau}
%			\\
%			&&\Gamma; \es; s: S \cat s_1:S' \cat s_2: S' \cat t_2: \btout{S} \tinact \cat t_1': \btinp{\btinp{S'} \tinact} \tinact \cat t_1'': \btout{\tinact} \tinact \\
%			&&\proves \htrigger{t_1'}{s_1} \Par \bout{s}{s_2} \bout{t_2}{s} \inact \Par \news{s}{\bout{t_1''}{s} \inact}
%			\\
%			&&\hby{\bactout{t_1''}{ s }} \hby{\bactinp{t'''}{\omapchar{\btinp{\tinact} \tinact}} } \hby{\dtau} \hby{\dtau}
%			\\
%			&&\Gamma; \es; s: S \cat s_1:S' \cat s_2: S' \cat t_2: \btout{S} \tinact \cat t_1': \btinp{\btinp{S'} \tinact} \tinact
%			\\
%			&&\proves \htrigger{t_1'}{s_1} \Par \bout{s}{s_2} \bout{t_2}{s} \inact
%			\\
%			&& \vdots
%			\\
%			&&\Gamma; \es; s: S \cat s_1:S' \cat s_2: S' \cat s_3: S' \cat t_3: \btout{S} \tinact \cat t_1': \btinp{\btinp{S'} \tinact} \tinact \cat t_2': \btinp{\btinp{S'} \tinact} \tinact
%			\\
%			&&\proves \htrigger{t_1'}{s_1} \Par \htrigger{t_2'}{s_2} \Par \bout{s}{s_3} \bout{t_3}{s} \inact
%			\\
%			&& \vdots
%	\end{eqnarray*}
%\end{example}
%}

\subsection{Deterministic Transitions and Up-to Techniques}
\label{ss:deter}

As hinted at earlier, internal transitions associated to session interactions or  
$\beta$-reductions are deterministic.  To define an auxiliary proof technique that exploits determinacy we require some auxiliary definitions.
		
\begin{definition}[Deterministic Transitions]
\label{def:dettrans}
	Suppose $\Gamma; \es; \Delta \proves P \hastype \Proc$ \newc{with balanced~$\Delta$}.
	Transition $\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ is called:
%
	\begin{enumerate}[$-$]
		\item 
				a {\em \sesstran} whenever transition $P \by{\tau} P'$ 
				is derived using Rule~$\ltsrule{Tau}$ 
				(where $\subj{\ell_1}$ and $\subj{\ell_2}$ in the premise are dual endpoints), 
				possibly followed by uses of Rules~$\ltsrule{Alpha}$, $\ltsrule{Res}$, $\ltsrule{Rec}$, or $\ltsrule{Par${}_L$}/
				\ltsrule{Par${}_R$}$ (cf. \figref{fig:untyped_LTS}).

	%	We write $\horel{\Gamma}{\Delta}{P}{\hby{\stau}}{\Delta'}{P'}$ to denote a \sesstran.
		
		\item
				a {\em \betatran} whenever transition $P \by{\tau} P'$
				is derived using Rule $\ltsrule{App}$,
				possibly followed by uses of Rules~$\ltsrule{Alpha}$, $\ltsrule{Res}$, $\ltsrule{Rec}$, or $\ltsrule{Par${}_L$}/
				\ltsrule{Par${}_R$}$ (cf. \figref{fig:untyped_LTS}).

		%		We write $\horel{\Gamma}{\Delta}{P}{\hby{\btau}}{\Delta'}{P'}$ to denote a $\beta$-transition.

%		\item	Also, $\horel{\Gamma}{\Delta}{P}{\hby{\dtau}}{\Delta'}{P'}$ denotes				either a \sesstran or a \betatran.
	\end{enumerate}
%
%	We write $\Hby{\dtau}$ to denote a (possibly empty) sequence of deterministic steps $\hby{\dtau}$.
\end{definition}

\begin{notation} We use the following notations:
	\begin{enumerate}[$-$]
		\item 	 $\horel{\Gamma}{\Delta}{P}{\hby{\stau}}{\Delta'}{P'}$  denotes a \sesstran.
		
		\item  $\horel{\Gamma}{\Delta}{P}{\hby{\btau}}{\Delta'}{P'}$   denotes a $\beta$-transition.

		\item	 $\horel{\Gamma}{\Delta}{P}{\hby{\dtau}}{\Delta'}{P'}$   denotes
				either a \sesstran or a \betatran.
\item  We write $\Hby{\dtau}$ to denote a (possibly empty) sequence of deterministic steps $\hby{\dtau}$.
	\end{enumerate}
\end{notation}


Deterministic transitions imply the $\tau$-inertness property~\cite{DBLP:journals/tcs/GrooteS96}, which
ensures behavioural invariance on deterministic transitions.

\begin{proposition}[$\tau$-inertness]
	\label{lem:tau_inert}
	Suppose $\Gamma; \es; \Delta \proves P \hastype \Proc$ \newc{with balanced $\Delta$}.
	Then
	\begin{enumerate}
		\item	
				$\horel{\Gamma}{\Delta}{P}{\hby{\dtau}}{\Delta'}{P'}$ implies
				$\horel{\Gamma}{\Delta}{P}{\hwb}{\Delta'}{P'}$.
		\item	$\horel{\Gamma}{\Delta}{P}{\Hby{\dtau}}{\Delta'}{P'}$ implies
				$\horel{\Gamma}{\Delta}{P}{\hwb}{\Delta'}{P'}$.
	\end{enumerate}
\end{proposition}
%
\begin{proof}[Sketch]
	The proof for Part 1 requires a case analysis on the structure of
	\betatran and session-transition. The proof for Part 2 is direct from Part 1.
	See \appref{app:sub_tau_inert} (\mypageref{app:sub_tau_inert}) for the full details of the proof.
	\qed
\end{proof}


Using the above determinacy properties, we can state the following up-to technique.
%We write $\Hby{\dtau}$ to denote a (possibly empty) sequence of deterministic steps $\hby{\dtau}$.

\begin{lemma}[Up-to Deterministic Transition]
	\label{lem:up_to_deterministic_transition}
	Let $\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{Q_1}$ such
	that if whenever:
%
	\begin{enumerate}[1.]
		\item	$\forall \news{\widetilde{m_1}} \bactout{n}{V_1}$ such that
			$
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\widetilde{m_1}} \bactout{n}{V_1}}}{\Delta_3}{P_3}
			$
			implies that $\exists Q_2, V_2$ such that
			$
				\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\widetilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}
			$
			and
			$
				\horel{\Gamma}{\Delta_3}{P_3}{\Hby{\dtau}}{\Delta_1'}{P_2}
			$
			and for fresh $t$:\\
			\[
				\horel{\Gamma}{\Delta_1''}{\newsp{\widetilde{m_1}}{P_2 \Par \htrigger{t}{V_1}}}
				{\ \Re\ }
				{\Delta_2''}{}{\newsp{\widetilde{m_2}}{Q_2 \Par \htrigger{t}{V_2}}}
			\]
%
		\item	$\forall \ell \not= \news{\widetilde{m}} \bactout{n}{V}$ such that
			$
				\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_3}{P_3}
			$
			implies that $\exists Q_2$   such that \\
			$
				\horel{\Gamma}{\Delta_1}{Q_1}{\hat{\Hby{\ell}}}{\Delta_2'}{Q_2}
			$
			and
			$
				\horel{\Gamma}{\Delta_3}{P_3}{\Hby{\dtau}}{\Delta_1'}{P_2}
			$
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re\ }{\Delta_2'}{Q_2}$.

		\item	The symmetric cases of 1 and 2.
	\end{enumerate}
	Then $\Re\ \subseteq\ \hwb$.
\end{lemma}

\begin{proof}[Sketch]
	The proof is easy by considering the relation
	\[
		\Re^{\Hby{\dtau}} = \set{ \horel{\Gamma}{\Delta_1'}{P_2}{,}{\Delta_2'}{Q_1} \setbar \horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2'}{Q_1},
		\horel{\Gamma}{\Delta_1}{P_1}{\Hby{\dtau}}{\Delta_1'}{P_2} }
	\]
	We verify that $\Re^{\Hby{\dtau}}$ is a bisimulation with
	the use of \propref{lem:tau_inert}.
	\qed
\end{proof}

\[
\]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Characterisation of rc bp congruence
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Characterisation of Higher-order and Characteristic Bisimilarities}
\label{ss:charact}

This section proves the main result; %typed bisimilarities collapse for \HOp processes. 
it allows us to use $\fwb$ and $\hwb$   as tractable reasoning
techniques for \HOp processes.


\begin{lemma}
	\label{lem:wb_eq_wbf}
	$\fwb\ =\ \hwb$.
\end{lemma}

\begin{proof}[Sketch]
\newc{
	The main difference between 
	$\hwb$ and $\fwb$
%	the definition of the two bisimilarity relations
	is the trigger process (namely, higher-order triggers $\htrigger{t}{V}$ in $\hwb$ and characteristic triggers $\ftrigger{t}{V}{U}$ in $\fwb$). Thus, the most interesting case in the proof is when we observe an output from a process. 
	When showing that $\fwb \subseteq \hwb$, 
	the
	key after the output is to show that
	\[
		\newsp{\tilde{m_1}}{P_1 \Par \ftrigger{t}{V}{U}} \hwb \newsp{\tilde{m_2}}{P_2 \Par \ftrigger{t}{V_2}{U}}
	\]
	given that 
	\[
		\newsp{\tilde{m_1}}{P_1 \Par \htrigger{t}{V}} \hwb \newsp{\tilde{m_2}}{P_2 \Par \htrigger{t}{V_2}}.
	\]
	Similarly, in the proof of $\hwb \subseteq \fwb$, the key step is showing that
	\[
		\newsp{\tilde{m_1}}{P_1 \Par \htrigger{t}{V}} \fwb \newsp{\tilde{m_2}}{P_2 \Par \htrigger{t}{V_2}}
	\]
	given that 
	\[
		\newsp{\tilde{m_1}}{P_1 \Par \ftrigger{t}{V}{U}} \fwb \newsp{\tilde{m_2}}{P_2 \Par \ftrigger{t}{V_2}{U}}.
	\]
	Intuitively, the above equalities follow from the fact that  
	characteristic trigger processes
	$\ftrigger{t}{V}{U}$
	and
	higher-order trigger processes
	$\htrigger{t}{V}$
	exhibit similar behaviour, see \lemref{lem:trigger_equiv} in the Appendix for more details.}
	Indeed, while for the former we have
	\begin{eqnarray*}
		\fotrigger{t}{x}{s}{U}{V} &\hby{\bactinp{t}{s'}}& \newsp{s}{\binp{s}{y} \mapchar{U}{y}  \Par \bout{\dual{s}}{V} \inact}
	\end{eqnarray*}
		for the latter we have:
	\begin{eqnarray*}
		\hotrigger{t}{x}{s}{V} &\hby{\bactinp{t}{\omapchar{U}}}& \newsp{s}{ \binp{s}{y} \mapchar{U}{y}  \Par \bout{\dual{s}}{V} \inact}
%		&\by{\tau}& \newsp{s}{ \binp{s}{y} \mapchar{U}{y}  \Par \bout{\dual{s}}{V} \inact}
	\end{eqnarray*}
%
	Using the above information we can show that typed relations induced by 
	$\hwb$ and $\fwb$ coincide.
	The full proof is found in 
	in \appref{app:sub_coinc}, \lemref{app:lem:wb_eq_wbf} (\mypageref{app:lem:wb_eq_wbf}).
	\qed
\end{proof}

%\begin{lemma}[Linear Process Substitution]
%	\label{lem:subst_equiv}
%	If 
%%
%	\begin{enumerate}
%		\item	$\fpv{P_2} = \fpv{Q_2} = \set{x}$.
%		\item	$\Gamma; x: U; \Delta_1''' \proves P_2 \hastype \Proc$ and $\Gamma; x: U; \Delta_2''' \proves Q_2 \hastype \Proc$.
%		\item	$\horel{\Gamma}{\Delta_1'}{\newsp{\widetilde{m_1}}{P_1 \Par P_2 \subst{\auxtr{t}}{x}}}
%			{\wb}
%			{\Delta_2'}{\newsp{\widetilde{m_2}}{Q_1 \Par Q_2 \subst{\auxtr{t}}{x}}}$, 
%			for some fresh $t$.
%
%		\item	$\horel{\Gamma}{\Delta_1''}{\newsp{\widetilde{m_1}}{P_1 \Par P_2 \subst{\omapchar{U}}{x}}}
%			{\wb}{\Delta_2''}{\newsp{\widetilde{m_2}}{Q_1 \Par Q_2 \subst{\omapchar{U}}{x}}}$,
%			for some $U$.
%	\end{enumerate}
%%
%	then $\forall R$ such that $\fv{R} = \widetilde{x}$
%\[
%	\horel{\Gamma}{\Delta_1}{\newsp{\widetilde{m_1}}{P_1 \Par P_2 \subst{\abs{\widetilde{x}}{R}}{x}}}
%	{\wb}
%	{\Delta_2}{\newsp{\widetilde{m_2}}{Q_1 \Par Q_2 \subst{\abs{\widetilde{x}}{R}}{x}}}
%\]
%\end{lemma}
%
%\begin{proof}[Sketch]
%	\qed
%\end{proof}

The next lemma is crucial for the characterisation of
higher-order and characteristic bisimilarities.
It states that if two processes are equivalent under the
trigger value %and the characteristic value substitution
then they are equivalent under any higher-order substitution.

\begin{lemma}[Process Substitution]
	\label{lem:proc_subst}
	Let $P$ and $Q$ be two processes and some fresh $t$. If 
%
%	\begin{enumerate}
%		\item
			\[\horel{\Gamma}{\Delta_1'}{P \subst{\trvalx{t}}{z}}{\hwb}{\Delta'_2}{Q \subst{\trvalx{t}}{z}}\]
%
%		\item	$\horel{\Gamma}{\Delta_1''}{P \subst{\omapchar{U}}{x}}{\hwb}{\Delta_2''}{Q \subst{\omapchar{U}}{x}}$,
%				for some $U$.
%	\end{enumerate}
%
	then $\forall R$ such that $\fv{R} = x$
	\[
		\horel{\Gamma}{\Delta_1}{P \subst{\abs{x}{R}}{z}}{\hwb}{\Delta_2}{Q \subst{\abs{x}{R}}{z}}
	\]
\end{lemma}

    \newc{The full proof of \lemref{lem:proc_subst} can be found in \appref{app:sub_coinc}, 
	\lemref{lem:process_subst} (\mypageref{lem:process_subst}); it is obtained 
by constructing a typed relation on the
	substitution properties stated by the lemma
	and proving that it is a higher-order bisimulation, using the auxiliary result given next.
	 Given a finite index set $I = \{1, \ldots, n\}$, we 
	shall write 
	$\prod_{i \in I} P_i$ to stand for $P_1 \Par P_2 \Par \cdots \Par P_n$.
	}
	\begin{lemma}[Trigger Substitution]
	\label{lem:trigger_subst}
	Let $P$ and $Q$ be processes. Also, let $t$ be a fresh name. If
	\[
		\horel{\Gamma}{\Delta_1}{\newsp{\widetilde{m_1}}{P \Par \prod_{i \in I} \appl{(\trvalx{t_i})}{n_i} }}
		{\hwb}
		{\Delta_2}{\newsp{\widetilde{m_2}}{Q \Par\prod_{i \in I} \appl{(\trvalx{t_i})}{m_i} }}
	\]
	then $\forall \abs{\widetilde{x}}{R}, \exists \Delta_1', \Delta_2'$ such that
	\[
		\horel{\Gamma}{\Delta_1'}{\newsp{\widetilde{m_1}}{P \Par \appl{(\abs{\widetilde{x}}{R})}{\widetilde{n}} }}
		{\hwb}
		{\Delta_2'}{\newsp{\widetilde{m_2}}{Q \Par \appl{(\abs{\widetilde{x}}{R})}{\widetilde{m}} }}.
	\]
\end{lemma}
%
%	
%	 which shows that if
%	\[
%		\horel{\Gamma}{\Delta_1}{\newsp{\widetilde{m_1}}{P \Par \appl{(\trvalx{t})}{n_1} }}
%		{\hwb}
%		{\Delta_2}{\newsp{\widetilde{m_2}}{Q \Par \appl{(\trvalx{t})}{n_2} }}
%	\]
%	then for all $\abs{x}{R}$, there exist $\Delta_1', \Delta_2'$ such that
%	\[
%		\horel{\Gamma}{\Delta_1'}{\newsp{\widetilde{m_1}}{P \Par \appl{(\abs{x}{R})}{n_1} }}
%		{\hwb}
%		{\Delta_2'}{\newsp{\widetilde{m_2}}{Q \Par \appl{(\abs{x}{R})}{n_2} }}
%	\]
	\begin{proof}[Sketch]
	The proof follows the definition of the characteristic process; 
	see \lemref{lem:trigger_subst}, page \pageref{lem:trigger_subst}, in the Appendix for details.
	Let us consider a particular case; we need to construct a typed relation:
	\begin{eqnarray*}
		\Re &=& \set{
					\horel{\Gamma}{\Delta_1'}{\newsp{\widetilde{m_1}}{P \Par \appl{(\abs{x}{R})}{n_1} }}
					{\ ,\ }
					{\Delta_2'}{\newsp{\widetilde{m_2}}{Q \Par \appl{(\abs{x}{R})}{n_2} }} \setbar
					\\
				&&	\horel{\Gamma}{\Delta_1}{\newsp{\widetilde{m_1}}{P \Par \appl{(\trvalx{t})}{n_1} }}
					{\hwb}
					{\Delta_2}{\newsp{\widetilde{m_2}}{Q \Par \appl{(\trvalx{t})}{n_2} }}
				}
	\end{eqnarray*}
	Typed relation $\Re$ can be shown to be a higher-order bisimulation
	by taking advantage of the shape of the characteristic process; each time
	a characteristic process does a transition then an output on a fresh name
	appears, $\bout{t}{n} \inact$. 
	\newc{JP: I assume that this refers only to session types. In any case, this is not accurate because there's at most one transition on a fresh name (the top level action); the new definition is not inductive.}
	To understand this better 
	we sketch the demanding case of the proof that $\Re$ is a higher-order bisimulation.
	Assume that
	\begin{eqnarray*}
		\Gamma; \es; \Delta_1' \proves \newsp{\widetilde{m_1}}{P \Par R \subst{n_1}{x} }
		\hby{\ell_1}
		\Delta_1'' \proves \newsp{\widetilde{m_1}'}{P' \Par R' \subst{n_1}{x}}
	\end{eqnarray*}
	\newc{JP: There's something missing here:
	We should analyze moves from $\newsp{\widetilde{m_1}}{P \Par \appl{(\abs{x}{R})}{n_1} }$ not from $\newsp{\widetilde{m_1}}{P \Par R \subst{n_1}{x} }$, right?}
	Then from the definition of $\Re$ we have:
	\begin{eqnarray*}
		\Gamma; \es; \Delta_1 \proves \newsp{\widetilde{m_1}}{P \Par \appl{(\trvalx{t})}{n_1} }
		\hby{\dtau}\hby{ \bactinp{t}{\omapchar{U}} } \Hby{\dtau}
		\Delta_3 \proves \newsp{\widetilde{m_1}''}{P \Par \mapchar{U}{x} \subst{n_1}{x} }
	\end{eqnarray*}
	\newc{JP: In the last bit I would just write $\mapchar{U}{n_1}$.}
	By the shape of the characteristic process we can always observe \newc{JP: This previous sentence is too vague, I am not sure I understand what it means...}
	\begin{eqnarray*}
		\Gamma; \es; \Delta_3 \proves \newsp{\widetilde{m_1}''}{P \Par \mapchar{U}{x} \subst{n_1}{x} }
		\hby{\ell_1}
		\newsp{\widetilde{m_1}'''}{P' \Par \bout{t'}{n_1} \inact }
		\hby{\bactout{t'}{n_1}}
		\Delta_1' \proves \news{\widetilde{m_1}'''} P'
%		\Hby{\dtau} \hwb
%		\Delta_1' \proves \newsp{\widetilde{m_1}'}{P' \Par \appl{(\trvalx{t'})}{n_1} }
	\end{eqnarray*}
	\newc{JP: Above we consider the (particular) case in which $\ell_1$ is due to the trigger (the subject is $n_1$, right?) Why does $P$ evolve to $P'$?...}
	which implies from the requirements of higher-order bisimulation that there exists
	$\newsp{\widetilde{m_2}''}{Q' \Par \mapchar{U}{x} \subst{n_2}{x} }$ such that
	\begin{eqnarray*}
		\Gamma; \es; \Delta_2 \proves \newsp{\widetilde{m_2}}{Q \Par \appl{(\trvalx{t})}{n_2} }
		\Hby{ \bactinp{t}{\omapchar{U}} } \Hby{\dtau}
		\Delta_4 \proves \newsp{\widetilde{m_2}''}{Q' \Par \mapchar{U}{x} \subst{n_2}{x} }
	\end{eqnarray*}
	\newc{JP: We can refine the above weak transition to denote the missing beta-transition before the action on $t$.}
	By the shape of the characteristic process we can always observe for
	$\ell_2, \subj{\ell_2} = \subj{\ell_1}$ if $\ell_1$ is output, and $\ell_2 = \ell_1$ otherwise, that:
	\begin{eqnarray*}
		\Gamma; \es; \Delta_4 \proves \newsp{\widetilde{m_2}''}{Q' \Par \mapchar{U}{x} \subst{n_2}{x} }
		&\Hby{\ell_2}&
		\newsp{\widetilde{m_2}'''}{Q'' \Par \bout{t'}{n_2} \inact }
		\\
		&\hby{\bactout{t'}{n_2}}&
		\Delta_4' \proves \news{\widetilde{m_2}'''} Q''
	\end{eqnarray*}
	and
	\[
		\horel{\Gamma}{\Delta_3''}{\newsp{\widetilde{m_1}'''}{P' \Par \htrigger{t''}{n_1} }}
		{\hwb}
		{\Delta_4''}{ \newsp{\widetilde{m_2}'''}{Q'' \Par \htrigger{t''}{n_2} } } 
	\]
	Two further results are implied from the last two equations \newc{JP: We need to add precise equation numbers!}:
	\begin{eqnarray*}
		\Gamma; \es; \Delta_2' \proves \newsp{\widetilde{m_2}}{Q \Par R \subst{n_2}{x} }
		\Hby{\ell_2}
		\Delta_2'' \proves \newsp{\widetilde{m_2}'}{Q'' \Par R' \subst{n_2}{x}}
	\end{eqnarray*}
	and
	\[
		\horel{\Gamma}{\Delta_3''}{\newsp{\widetilde{m_1}'''}{P' \Par \appl{(\trvalx{t''})}{n_1} }}
		{\hwb}
		{\Delta_4''}{ \newsp{\widetilde{m_2}'''}{Q'' \Par \appl{(\trvalx{t''})}{n_2} } } 
	\]
	\newc{JP: How do we infer these facts, exactly? Also, we need to infer a weak transition from 
	$\newsp{\widetilde{m_2}}{Q \Par \appl{(\abs{x}{R})}{n_2} }$, right?...}
	which implies from the definition of $\Re$ that for $R'$ we get
	\[
		\horel{\Gamma}{\Delta_1''}{\newsp{\widetilde{m_1}'}{P' \Par R' \subst{n_1}{x} }}
		{\ \Re\ }
		{\Delta_2''}{ \newsp{\widetilde{m_2}'}{Q'' \Par R' \subst{n_2}{x} } } 
	\]
	as required.
%	The result is proved by constructing a typed relation on the above
%	substitution properties and proving that it is a
%	higher-order bisimulation, up-to \betatran (\lemref{lem:up_to_deterministic_transition}).
	\qed
\end{proof}

We now show that higher-order bisimilarity is sound with respect to contextual bisimilarity.
To show soundness we use the crucial result of \lemref{lem:proc_subst}:

\begin{lemma}
	\label{lem:wb_is_wbc}
	$\hwb\ \subseteq\ \wbc$.
\end{lemma}

\begin{proof}[Sketch]
	The proof relies on \lemref{lem:proc_subst} to prove that:
	\begin{enumerate}
		\item	Whenever two processes are higher-order bisimilar
				under the input of
				a characteristic value and a trigger value
				then they are higher-order bisimilar under the
				input of any value $\abs{x}{R}$, which is the
				requirement for context bisimilarity (cf.~\defref{def:wbc}).

		\item	The input requirement is then further used
				to prove that the 
				%output clause for $\hwb$ (cf.~\defref{d:hwb}).
				%implies the output clause of $\wbc$, i.e.~the 
				output clause requirement for $\hwb$ (cf.~\defref{d:hwb}):
				\[
					\begin{array}{lrlll}
						\Gamma; \Delta_1  \proves  {\newsp{\widetilde{m_1}}{P_2 \Par \htrigger{t}{V_1}}}
						\ \Re\ 
						\Delta_2 \proves {\newsp{\widetilde{m_2}}{Q_2 \Par \htrigger{t}{V_2}}}
					\end{array}
				\]
			%
				implies the output clause requirement for $\wbc$ that is,
				for all $R$ with $\fv{R}=x$:
				\[
					\horel{\Gamma}{\Delta_1}{\newsp{\widetilde{m_1}}{P_2 \Par R\subst{V_1}{x}}}
					{\ \Re\ }
					{\Delta_2}{\newsp{\widetilde{m_2}}{Q_2 \Par R\subst{V_2}{x}}};
				\]
	\end{enumerate}
%
	The full proof is found  in \appref{app:sub_coinc}, 
	\lemref{app:lem:wb_is_wbc} (\mypageref{app:lem:wb_is_wbc}).
	\qed
\end{proof}

Context bisimilarity is included in barbed congruence:
\begin{lemma}
	\label{lem:wbc_is_cong}
	$\wbc\ \subseteq\ \cong$.
\end{lemma}

\begin{proof}[Sketch]
	We show that $\wbc$ satisfies the defining
	properties of $\cong$.
	It is easy to show that $\wbc$ is reduction-closed
	and barb preserving (cf. \defref{d:conf}).
		The challenging part is
	to show that $\wbc$ is a congruence; the most challenging
	case is parallel congruence.
	To this end, we construct the following relation:
%	a parallel congruence closure:
%
	\begin{eqnarray*}
		\mathcal{S} &=&	\set{
				(\Gamma; \emptyset; \Delta_1 \cat \Delta_3 \proves \newsp{\widetilde{n_1}}{P_1 \Par R} %\hastype \Proc
				\ ,\ 
				\Gamma; \emptyset; \Delta_2 \cat \Delta_3 \proves \newsp{\widetilde{n_2}}{P_2 \Par R})
				\setbar \\
		& &		\qquad \qquad\qquad \horel{\Gamma}{\Delta_1}{P_1}{\wbc}{\Delta_2}{P_2} \quad \mbox{and} \quad
				\forall R \mbox{ such that }\Gamma; \emptyset; \Delta_3 \proves R \hastype \Proc}
	\end{eqnarray*}
%
	We show that $\mathcal{S}$ is a context bisimulation
	by  a case analysis on the transitions of the pairs in $\mathcal{S}$.
	The full proof is found  in \appref{app:sub_coinc}, 
	\lemref{app:lem:wbc_is_cong} (\mypageref{app:lem:wbc_is_cong}).
	\qed
\end{proof}

The last ingredient required for our main result is the following inclusion.

\begin{lemma}
	\label{lem:cong_is_wb}
	$\cong \subseteq \hwb$.
\end{lemma}

\begin{proof}[Sketch]	
	The proof exploits
the \emph{definability} technique developed in~\cite[\S6.7]{Hennessy07} and
refined for session types in~\cite{KYHH2015,KY2015}.
Intuitively, this technique exploits small test processes that
reveal the presence of a visible action by reducing with a given pair of processes
and exhibiting a barb on a fresh name.

More precisely, given a fresh name $\suc$, and for each visible action $\ell$, we define 
		a  test process
	$\Gamma; \emptyset; \Delta_2 \proves T\lrangle{\ell, \suc} \hastype \Proc$
	with the following property:
%
	\[
		\Gamma; \Delta_1 \proves P \Par T\lrangle{\ell, \suc} \red \Delta_2 \proves P' \Par \bout{\suc}{\dual{m}} \inact \barb{\suc}
		\quad \mbox{iff} \quad
		\Gamma; \Delta \proves P \hby{\ell} \Gamma; \Delta' \proves P'
	\]
%
	See \defref{app:def:definibility} (\mypageref{app:def:definibility}) for the formal definition.
	The test processes can therefore be used to check the
	typed labelled transition interactions of two
	processes that are related by reduction-closed,
	barbed congruence. Indeed, we have that 
	\[
		\Gamma; \Delta_1 \proves P\ \cong\ \Delta_2 \proves Q
	\]
	implies from congruence of $\cong$, that if there exist $\Delta_3, \Delta_4$ such that:
	\begin{eqnarray*}
		\Gamma; \Delta_3 \proves P \Par T\lrangle{\ell, \suc}\ \cong\ \Delta_4 \proves Q \Par T\lrangle{\ell, \suc}
%		\label{prsk:1}
	\end{eqnarray*}
	then it implies from reduction-closeness of $\cong$ and the definition of $T\lrangle{\ell, \suc}$:
	\begin{eqnarray}
		\Gamma; \Delta_3' \proves P' \Par \bout{\suc}{\dual{m}} \inact\ \cong\ \Delta_4' \proves Q' \Par \bout{\suc}{\dual{m}} \inact
		\label{prsk:2}
	\end{eqnarray}
	which in turn means that whenever $\Gamma; \Delta_1 \proves P \hastype \Proc$ can
	perform an action $\hby{\ell}$ then we can derive that $\Gamma; \Delta_2 \proves Q \hastype \Proc$
	can also perform action $\Hby{\ell}$ because of the result in \eqref{prsk:2}.
	By applying \lemref{lem:extrusion} on \eqref{prsk:2} we can deduce that
	$\Gamma; \Delta_1' \proves P'\ \cong\ \Delta_2' \proves Q'$.
	This concludes the requirements of  $\wbc$: % bisimulation closure:
	\[
		\Gamma; \Delta \proves P\ \hwb\ \Delta' \proves Q
	\]
	The full details can be found in  \appref{app:sub_coinc}, \lemref{app:lem:cong_is_wb} (\mypageref{app:lem:cong_is_wb}).
	\qed
\end{proof}

We can finally state our main result:
\begin{theorem}[Coincidence]
	\label{the:coincidence}
	$\cong$, $\wbc$, $\hwb$ and $\fwb$ coincide in $\HOp$. 
\end{theorem}

\begin{proof}
	The proof is a direct consequence from our previous results:
	\lemref{lem:wb_eq_wbf} (which proves $\hwb\ =\ \fwb$), 
	\lemref{lem:wb_is_wbc} (which proves $\hwb\ \subseteq\ \wbc$),
	\lemref{lem:wbc_is_cong} (which proves $\wbc\ \subseteq\ \cong$), and	
	\lemref{lem:cong_is_wb} (which proves $\cong\ \subseteq\ \hwb$).
%
%\begin{enumerate}[$-$]
%		\item	\lemref{lem:wb_eq_wbf} proves $\wb\ =\ \wbf$.
%		\item	\lemref{lem:cong_is_wb} proves $\cong\ \subseteq\ \wb$.
%		\item	\lemref{lem:wb_is_wbc} proves $\wb\ \subseteq\ \wbc$.
%		\item \lemref{lem:wbc_is_cong} proves $\wbc\ \subseteq\ \cong$.
%		\end{enumerate}
Indeed, we may conclude $$\cong\ \subseteq\ \hwb\ =\ \fwb\ \subseteq\ \wbc\ \subseteq\ \cong$$
	\qed
\end{proof}
 

\subsection{Revisiting the Hotel Booking Scenario (Section \ref{exam:proc})}
\label{ss:examprev}

Now we prove that $\Client_1$ and $\Client_2$ 
in \secref{exam:proc} are behaviourally equivalent.

\begin{proposition}\label{p:examp}
	Let
	$S = \btout{\rtype} \btinp{\Quote} \btsel{\accept: \btout{\creditc} \tinact, \reject: \tinact}$
	and
	$\Delta = s_1: \btout{\lhot{S}} \tinact \cat s_2: \btout{\lhot{S}} \tinact$.
%	\begin{eqnarray*}
%		S &=& \btout{\rtype} \btinp{\Quote} \btsel{\accept: \btout{\creditc} \tinact, \reject: \tinact}\\
%		\Delta &=& s_1: \btout{\lhot{S}} \tinact \cat s_2: \btout{\lhot{S}} \tinact
%	\end{eqnarray*}
	Then
	$\horel{\es}{\Delta}{\Client_1}
	{\hwb}
	{\Delta}{\Client_2}$, where $\Client_1$ and $\Client_2$ are as in \secref{exam:proc}. 
\end{proposition}

%\begin{proof}[Sketch]
%	\noi We show a higher-order bisimulation closure by following transitions on each $\Client$;
%	%We show the initial higher order transitions.
%	see \appref{hotel_closure} for details.
%	First, the characteristic process is given as:
%	$\mapchar{\btinp{\lhot{S}} \tinact}{s} = \binp{s}{x} (\appl{x}{k})$.
%	We show that the clients can simulate each other on
%	the first two output transitions, that also generate the trigger
%	processes:
%%
%\[
%	\begin{array}{lll}
%		&	\es; \es; \Delta \proves \Client_1
%		&
%			\by{\bactout{s_1}{\abs{x}{P_{xy} \subst{h_1}{y}}}}
%			\qquad
%			\by{\bactout{s_2}{\abs{x}{P_{xy} \subst{h_2}{y}}}}
%		\\
%		&	\es; \es; k_1: S \cat k_2: S \proves
%		&
%			\newsp{h_1, h_2}{\binp{\dual{h_1}}{x} \binp{\dual{h_2}}{y}
%		\\
%		&
%		&	\If\ x \leq y\ \Then (\bsel{\dual{h_1}}{\accept} \bsel{\dual{h_2}}{\reject} \inact
%			\Else \bsel{\dual{h_1}}{\reject} \bsel{\dual{h_2}}{\accept} \inact)
%		\\
%		&
%		&	\Par \ftrigger{t_1}{\abs{x}{P_{xy} \subst{h_1}{y}}}{\lhot{S}} \Par \ftrigger{t_2}{\abs{x}{P_{xy} \subst{h_2}{y}}}{\lhot{S}}}
%%		& \Par \binp{t_1}{x} \newsp{s}{\binp{s}{x} \appl{x}{k_1} \Par \bout{\dual{s}}{\abs{x}{P \subst{h_1}{y}}} \inact }\\
%%		& \Par \binp{t_2}{x} \newsp{s}{\mapchar{\btinp{\lhot{S}}}{s} \Par \bout{\dual{s}}{\abs{x}{P \subst{h_2}{y}}} \inact }}
%		\\[2mm]
%		& \mbox{and}
%		\\[2mm]
%		&	\es; \es; \Delta \proves \Client_2
%		&
%			\by{\bactout{s_1}{\abs{x}{Q_1 \subst{h}{y}}}}
%			\qquad
%			\by{\bactout{s_2}{\abs{x}{Q_2 \subst{\dual{h}}{y}}}}
%		\\
%		&	\es; \es; k_1: S \cat k_2: S \proves & \newsp{h}{
%			\ftrigger{t_1}{\abs{x}{Q_1 \subst{h}{y}}}{\lhot{S}} \Par \ftrigger{t_2}{\abs{x}{Q_2 \subst{\dual{h}}{y}}}{\lhot{S}}}
%%		\binp{t_1}{x} \newsp{s}{\binp{s}{x} \appl{x}{k_1} \Par \bout{\dual{s}}{\abs{x}{P_1 \subst{h}{y}}} \inact }\\
%%		&\Par \binp{t_2}{x} \newsp{s}{\binp{s}{x} \appl{x}{k_2} \Par \bout{\dual{s}}{\abs{x}{P_2 \subst{\dual{h}}{y}}} \inact }}
%	\end{array}
%\]
%	\noi 
%	After these transitions, 
%	we can analyse that 
%	the resulting processes are behaviourally equivalent
%	since they have the same visible transitions; the rest 
%	is internal deterministic transitions. 
%	\qed
%\end{proof}

\begin{proof}
	\noi	We show a case where each typed process simulates the other, according to the definition of
			$\hwb$ (cf. \defref{d:hwb}).
 For fresh sessions $s, k$, we get \dkmargin{check the example if it correct}
%	$$
%		\mapchar{\btinp{\lhot{S}} \tinact}{s} = \binp{s}{x} (\mapchar{\tinact}{s} \Par \mapchar{\lhot{S}}{x})
%		= \binp{s}{x} (\inact \Par \appl{x}{\omapchar{S}})
%		= \binp{s}{x} (\inact \Par \appl{x}{k})
%		\scong \binp{s}{x} (\appl{x}{k})
%	$$
%
	$$
		\dk{\mapchar{\btinp{\lhot{S}} \tinact}{s} = \binp{s}{x} ( \bout{t}{s} \inact \Par \mapchar{\lhot{S}}{x})}
%		= \binp{s}{x} (\inact \Par \appl{x}{\omapchar{S}})
%		= \binp{s}{x} (\inact \Par \appl{x}{k})
%		\scong \binp{s}{x} (\appl{x}{k})
	$$
	

	\noi To observe $\Client_1$ assume:
%
	\begin{eqnarray*}
		R' &\scong& \If\ x \leq y\ \Then (\bsel{\dual{h_1}}{\accept} \bsel{\dual{h_2}}{\reject} \inact
		\Else \bsel{\dual{h_1}}{\reject} \bsel{\dual{h_2}}{\accept} \inact)\\
		Q &\scong& \bbra{z}{\accept: \bsel{k_2}{\accept} \bout{k_2}{\creditc} \inact, \reject: \bsel{k_2}{\reject} \inact}
%		Q &\scong& z \triangleleft \left\{
%		\begin{array}{l}
%			\accept: \bsel{k_2}{\accept} \bout{k_2}{\creditc} \inact,\\
%			\reject: \bsel{k_2}{\reject} \inact
%		\end{array}
%		\right\}
	\end{eqnarray*}
%
	\noi We can now observe $\Client_1$ as:
\[
	\begin{array}{ll}
		& \es; \es; \Delta \proves \Client_1
		\\[1mm]

		\by{\bactout{s_1}{\abs{x}{P_{xy} \subst{h_1}{y}}}}&
		\es; \es; s_2: \btout{\lhot{S}} \tinact \cat k_1: S \proves \\
		& \newsp{h_1, h_2}{\bout{s_2}{\abs{x}{P_{xy} \subst{h_2}{y}}} \inact
		\Par \binp{\dual{h_1}}{x} \binp{\dual{h_2}}{y} R'\\
		& \Par \ftrigger{t_1}{P_{xy} \subst{h_1}{y}}{\lhot{S}}}
		%\binp{t_1}{x} \newsp{s}{\mapchar{\btinp{\lhot{S}}}{s} \Par \bout{\dual{s}}{\abs{x}{P \subst{h_1}{y}}} \inact }}
		\\[1mm]

		\by{\bactout{s_2}{\abs{x}{P_{xy} \subst{h_2}{y}}}}&
		\es; \es; k_1: S \cat k_2: S \proves \newsp{h_1, h_2}{
		\binp{\dual{h_1}}{x} \binp{\dual{h_2}}{y} R'\\
		& \ftrigger{t_1}{P_{xy} \subst{h_1}{y}}{\lhot{S}} \Par \ftrigger{t_2}{P_{xy} \subst{h_2}{y}}{\lhot{S}}}
%		\Par \binp{t_1}{x} \newsp{s}{\binp{s}{x} \appl{x}{k_1} \Par \bout{\dual{s}}{\abs{x}{P \subst{h_1}{y}}} \inact }\\
%		& \Par \binp{t_2}{x} \newsp{s}{\mapchar{\btinp{\lhot{S}}}{s} \Par \bout{\dual{s}}{\abs{x}{P \subst{h_2}{y}}} \inact }}
		\\[1mm]

		\by{\bactinp{t_1}{b}} \by{\bactinp{t_2}{b}} \by{\dtau}\by{\dtau}&
		\es; \es; k_1: S \cat k_2: S \proves \newsp{h_1, h_2}{
		\binp{\dual{h_1}}{x} \binp{\dual{h_2}}{y} R' \\
		&  \Par \newsp{s_1', s_2'}{ P_{xy}\subst{h_1}{y} \subst{k_1}{x} \Par P_{xy}\subst{h_1}{y} \subst{k_2}{x}}\\
		& \Par \bout{t_3}{s_1'} \inact \Par \bout{t_4}{s_2'} \inact}
		\\[1mm]

		\by{\bactout{t_3}{s_1'}} \by{ \bactout{t_4}{s_2'}} &
		\es; \es; k_1: S \cat k_2: S \proves \newsp{h_1, h_2}{
		\binp{\dual{h_1}}{x} \binp{\dual{h_2}}{y} R' \\
		&  \Par P_{xy}\subst{h_1}{y} \subst{k_1}{x} \Par P_{xy}\subst{h_1}{y} \subst{k_2}{x}}\\
		& \Par \newsp{s_1', s_2'}{\ftrigger{t_3'}{s_1'}{\tinact} \Par \ftrigger{t_4}{s_2'}{\tinact}}
		\\[1mm]

		\by{\bactout{t_3'}{c}} \by{ \bactout{t_4'}{c}} \\
		\by{\dtau} \by{\dtau} \by{\dtau} \by{\dtau} &
		\es; \es; k_1: S \cat k_2: S \proves \newsp{h_1, h_2}{
		\binp{\dual{h_1}}{x} \binp{\dual{h_2}}{y} R' \\
		&  \Par P_{xy}\subst{h_1}{y} \subst{k_1}{x} \Par P_{xy}\subst{h_1}{y} \subst{k_2}{x}}
		\\[1mm]

		\by{\bactout{k_1}{\rtype}} \by{\bactout{k_2}{\rtype}}\\
		\by{\bactinp{k_1}{\Quote}} \by{\bactinp{k_2}{\Quote}}
		& \es; \es; k_1: S' \cat k_2: S' \proves \newsp{h_1, h_2}{
		\binp{\dual{h_1}}{x} \binp{\dual{h_2}}{y} R'\\
		& \Par \bout{h_1}{\Quote} Q \subst{h_1}{z} \Par \bout{h_2}{\Quote} Q \subst{h_2}{z}}
		\\[1mm]

		\by{\dtau} \by{\dtau} \by{\dtau}&
		\es; \es; k_1: S' \cat k_2: S' \proves \\
		& \newsp{h_1, h_2}{\bsel{\dual{h_1}}{\accept} \bsel{\dual{h_2}}{\reject} \inact
		\Par Q \subst{h_1}{z} \Par Q \subst{h_2}{z}}
		\\[1mm]

		\by{\dtau} \by{\dtau}&
		\es; \es; k_1: S' \cat k_2: S' \proves
		\bsel{k_1}{\accept} \bout{k_1}{\creditc} \inact 
		\Par \bsel{k_2}{\reject} \inact
		\\[1mm]

		\by{\bactsel{k_1}{\accept}} \by{\bactsel{k_2}{\reject}} \by{\bactsel{k_1}{\creditc}}&
		\es; \es; \es \proves \inact
	\end{array}
\]

\noi	We can observe the same sequence of external transitions for $\Client_2$:

\[
	\begin{array}{ll}
		& \es; \es; \Delta \proves \Client_2
\\[1mm]

		\by{\bactout{s_1}{\abs{x}{Q_1 \subst{h}{y}}}}&
		\es; \es; s_2: \btout{\lhot{S}} \tinact \cat k_1: S \proves \newsp{h}{\bout{s_2}{\abs{x}{Q_2 \subst{\dual{h}}{y}}} \inact\\
		& \Par \ftrigger{t_1}{Q_1 \subst{h}{y}}{\lhot{S}}}
		% \binp{t_1}{x} \newsp{s}{\mapchar{\btinp{\lhot{S}}}{s} \Par \bout{\dual{s}}{\abs{x}{Q_1 \subst{h}{y}}} \inact }}
\\[1mm]

		\by{\bactout{s_2}{\abs{x}{Q_2 \subst{\dual{h}}{y}}}}&
		\es; \es; k_1: S \cat k_2: S \proves \newsp{h}{\\
		& \ftrigger{t_1}{Q_1 \subst{h}{y}}{\lhot{S}} \Par \ftrigger{t_2}{Q_2 \subst{\dual{h}}{y}}{\lhot{S}}}
%		\binp{t_1}{x} \newsp{s}{\binp{s}{x} \appl{x}{k_1} \Par \bout{\dual{s}}{\abs{x}{Q_1 \subst{h}{y}}} \inact }\\
%		& \Par \binp{t_2}{x} \newsp{s}{\mapchar{\btinp{\lhot{S}}}{s} \Par \bout{\dual{s}}{\abs{x}{Q_2 \subst{\dual{h}}{y}}} \inact }}
\\[1mm]

		\by{\bactinp{t_1}{b}} \by{\bactinp{t_2}{b}} \by{\dtau}\by{\dtau}&
		\es; \es; k_1: S \cat k_2: S \proves \newsp{h}{
		P\subst{h}{y} \subst{k_1}{x} \Par P_{xy}\subst{\dual{h}}{y} \subst{k_2}{x}\\
		& \Par \newsp{s_1', s_2'}{\bout{t_3}{s_1'} \inact \Par \bout{t_4}{s_2'} \inact}}
\\[1mm]

		\by{\bactout{t_3}{s_1'}} \by{ \bactout{t_4}{s_2'}} &
		\es; \es; k_1: S \cat k_2: S \proves \newsp{h}{
		P\subst{h}{y} \subst{k_1}{x} \Par P_{xy}\subst{\dual{h}}{y} \subst{k_2}{x}\\
		& \Par \newsp{s_1', s_2'}{\ftrigger{t_3'}{s_1'}{\tinact} \Par \ftrigger{t_4'}{s_2'}{\tinact}}}
\\[1mm]

		\by{\bactout{t_3'}{c}} \by{ \bactout{t_4'}{c}} \\
		\by{\dtau} \by{\dtau} \by{\dtau} \by{\dtau} &
		\es; \es; k_1: S \cat k_2: S \proves \newsp{h}{
		P\subst{h}{y} \subst{k_1}{x} \Par P_{xy}\subst{\dual{h}}{y} \subst{k_2}{x}}
		\\[1mm]


		\by{\bactout{k_1}{\rtype}} \by{\bactout{k_2}{\rtype}}\\
		\by{\bactinp{k_1}{\Quote}} \by{\bactinp{k_2}{\Quote}}
		& \es; \es; k_1: S' \cat k_2: S' \proves \newsp{h}{
		\bout{h}{\Quote_1} \binp{h}{\Quote_2} R \subst{k_1}{x} \\
		& \Par \binp{\dual{h}}{\Quote_2} \bout{\dual{h}}{\Quote_1} R \subst{k_2}{x}}
\\[1mm]
		\by{\dtau} \by{\dtau}&
		\es; \es; k_1: S' \cat k_2: S' \proves R \subst{k_1}{x} \Par R \subst{k_2}{x}
\\[1mm]
		\by{\dtau} \by{\dtau}&
		\es; \es; k_1: S' \cat k_2: S' \proves
		\bsel{k_1}{\accept} \bout{k_1}{\creditc} \inact 
		\Par \bsel{k_2}{\reject} \inact
\\[1mm]
		\by{\bactsel{k_1}{\accept}} \by{\bactsel{k_2}{\reject}} \by{\bactsel{k_1}{\creditc}}&
		\es; \es; \es \proves \inact
	\end{array}
\]
\qed
\end{proof}

%\smallskip 

%\noi 
%Thus, we may use $\hwb$ for tractable reasoning %is the most tractable 
%in the higher-order setting;  
%%the calculus is limited  
%%the $\sessp$-calculus, 
%%into~\jpc{\sessp}
%in the first-order setting of $\sessp$
%we can still use~$\fwb$. 



%PERHAPS REVISIT EXAMPLE \ref{ex:motivation}??


%\smallskip  
%
%\noi Processes that do not use shared names are inherently deterministic. 
%The following \jpc{determinacy property will be} useful 
%\dk{for proving our expressiveness results (\secref{sec:positive})}.
%%for both positive and negative results. 
%We require an auxiliary definition. 
%A transition $\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ is said
%		{\em deterministic} if it is derived using~$\ltsrule{App}$ or~$\ltsrule{Tau}$ 
%		(where $\subj{\ell_1}$ and $\subj{\ell_2}$ in the premise 
%		are dual endpoints), 
%		possibly followed by uses of  $\ltsrule{Alpha}$, $\ltsrule{Res}$, $\ltsrule{Rec}$, or $\ltsrule{Par${}_L$}/\ltsrule{Par${}_R$}$.
%
%
%%\smallskip 
%
%\begin{lemma}[$\tau$-Inertness]\rm
%	\label{lem:tau_inert}
%	\begin{enumerate}[1)]
%		\item %(deterministic transitions) 
%		Let $\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ be a deterministic transition,
%		with balanced $\Delta$. Then 
%		$\Gamma; \Delta \proves P \cong \Delta'\proves P'$ 
%		with $\Delta \red^\ast \Delta'$ balanced.
%%		Transition $\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ is called
%%		{\em deterministic} if it is derived by $\ltsrule{App}$ or 
%%		$\ltsrule{Tau}$ where $\subj{\ell_1}$ and $\subj{\ell_2}$ in the premise 
%%		are dual session names. Suppose $\Delta$ is balanced. Then 
%%		$\Gamma; \Delta \proves P \cong \Delta'\proves P'$ 
%%		with $\Delta \red^\ast \Delta'$ balanced. 
%		\item 
%		%Let $P$ is the $\HOp^{-\mathsf{sh}}$-calculus. 
%		Let $P$ be an $\HOp^{-\mathsf{sh}}$ process. 
%		Assume $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$. Then 
%		$P \red^\ast P'$ implies $\Gamma; \Delta \proves 
%		P \cong \Delta'\proves P'$ with $\Delta \red^\ast \Delta'$. 
%	\end{enumerate}
%\end{lemma}


%\smallskip 


%\begin{IEEEproof}
%	The full details of the proof are in Appendix~\ref{app:sub_coinc}.
%	The theorem is split into a hierarchy of Lemmas. Specifically
%	Lemma~\ref{lem:wb_eq_wbf} proves 
%	$\wb$ coincides with $\fwb$; 
%	Lemma~\ref{lem:wb_is_wbc} exploits the process substitution result
%	(Lemma~\ref{lem:proc_subst}) to prove that $\hwb \subseteq \wbc$.
%	Lemma~\ref{lem:wbc_is_cong} shows that $\wbc$ is a congruence
%	which implies $\wbc \subseteq \cong$.
%	The final result comes from Lemma~\ref{lem:cong_is_wb} where
%	we use label testing to show that $\cong \subseteq \fwb$ using
%	the technique in developed in~\cite{Hennessy07}. The formulation of input
%	triggers in the bisimulation relation allows us to prove
%	the latter result without using a matching operator.
%\end{IEEEproof}

%\smallskip 

%\noi Processes that do not use shared names, are inherently $\tau$-inert.

%\smallskip 

%\begin{lemma}[$\tau$-inertness]\rm
%	\label{lem:tau_inert}
%	Let $P$ is the $\HOp^{-\mathsf{sh}}$-calculus. 
%Assume $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$. Then 
%$P \red^\ast P'$ implies $\Gamma; \Delta \proves 
%P \cong \Delta'\proves P'$ with $\Delta \red^\ast \Delta'$. 
%\end{lemma}


%\begin{IEEEproof}
%	The proof is relied on the fact that processes of the
%	form $\Gamma; \es; \Delta \proves_s \bout{s}{V} P_1 \Par \binp{k}{x} P_2$
%	cannot have any typed transition observables and the fact
%	that bisimulation is a congruence.
%	See details in Appendix~\ref{app:sub_tau_inert}.
%	\qed
%\end{IEEEproof}

