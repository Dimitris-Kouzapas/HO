% !TEX root = main.tex

We have thoroughly studied the expressivity of $\HOp$, the higher-order $\pi$-calculus with sessions.
Unlike most previous works on the expressivity of 
(higher-order) process calculi, we have carried out our study in the setting of \emph{session types}. % for structured communications.
Types not only delineate and enable encodings; they 
inform the techniques required to reason about such encodings.
Our results cover a wide spectrum of features intrinsic to higher-order concurrency:
pure process-passing (with first- and higher-order abstractions), pure name-passing, polyadicity, 
linear/shared communication (see \figref{fig:express}). 
Remarkably, the discipline embodied by 
session types turns out to be fundamental to show that all these languages are equally expressive, up to 
 strong behavioural correspondences. Indeed, although our encodings may be exploited in an untyped setting,
session type information is critical in the proofs of key properties for preciseness, in particular full abstraction.

\jparagraph{Related Work}
There is a vast literature on expressiveness for process calculi, both 
first- and higher-order. 
%For space reasons here 
%Below we concentrate on closely related work.
In the untyped setting, the relative expressiveness of name-passing calculi with respect to 
higher-order languages %(process- and abstraction-passing) 
is well-known. 
Our study  recasts some classic results~\cite{SangiorgiD:expmpa} into a session typed setting, and
offers new encodability results.
Our study also stresses the 
view of ``encodings as protocols'', namely session protocols which
enforce  linear and shared disciplines for names, a distinction
not explored in %~\cite{SangiorgiD:expmpa,DBLP:journals/tcs/Sangiorgi01}. 
previous works.
This distinction is key 
%in proper definitions of trigger processes, which are key to encodings (\defref{d:enc:hopitopi}). % and behavioural equivalences (\defref{d:hbw} and~\ref{d:fwb}).  
in our technical developments: % in particular, 
it enables us to obtain 
 refined 
operational correspondence statements (cf. \propsref{prop:op_corr_HOp_to_HO}, \ref{prop:op_corr_HOp_to_p}, \ref{prop:op_corr_HOpp_to_HOp}, and \ref{prop:op_corr_pHOp_to_HOp}).
Remarkably, we showed that
$\HO$ suffices to encode \sessp,  the first-order session
calculus~\cite{honda.vasconcelos.kubo:language-primitives}. % with name passing ($\sessp$).
To our knowledge, this is a new result for session typed calculi: its significance is stressed by the demanding encodability criteria  considered here, in particular full abstraction up to higher-order/characteristic bisimilarity ($\hwb$/$\fwb$, cf. \propsref{prop:fulla_HOp_to_HO} and~\ref{prop:fulla_HOp_to_p}).
As such, this new result is relevant in a broader setting, for known encodings 
of name-passing into higher-order calculi~\cite{SaWabook,BundgaardHG06,DBLP:journals/entcs/MeredithR05,XuActa2012,DBLP:journals/corr/XuYL15} either require heavy limitations
in source/target languages,
do not consider types,
 and/or fail to satisfy strong encodability criteria (see below). 
We also show that $\HO$ can encode $\HOp$ and its extension with
higher-order applications ($\HOpp$). 
Thus, %using session types
all these  calculi are equally expressive with fully
abstract encodings (up to $\hwb$/$\fwb$).  
To our knowledge, these are the first expressivity results of this kind.

Early works on (relative) expressiveness appealed to different notions of encoding.
Later on, 
proposals of abstract 
frameworks which formalise the notion of encoding 
and state associated syntactic/semantic criteria 
were put forward; 
recent proposals include~\cite{DBLP:journals/iandc/Gorla10,DBLP:journals/tcs/FuL10,DBLP:journals/corr/abs-1208-2750,DBLP:conf/esop/PetersNG13,DBLP:journals/corr/PetersG15}. 
These frameworks %are applicable to different calculi, and 
have been used to clarify known results and to derive new ones.
Our formulation of precise encoding (\defref{def:goodenc}) 
builds upon existing proposals (e.g.,~\cite{Palamidessi03,DBLP:journals/iandc/Gorla10,DBLP:conf/icalp/LanesePSS10})
in order to account for the session types
associated to \HOp. % and its variants.


Early expressiveness studies for higher-order calculi are~\cite{Tho90,SangiorgiD:expmpa}; 
more recent works include~\cite{BundgaardHG06,DBLP:conf/icalp/LanesePSS10,DBLP:journals/iandc/LanesePSS11,XuActa2012,DBLP:conf/wsfm/XuYL13}.
Due to the close relationship between higher-order process calculi and functional calculi, 
%works devoted to 
encodings of (variants of) the $\lambda$-calculus into (variants of) the $\pi$-calculus (see, e.g.,~\cite{San92,DBLP:journals/tcs/Fu99,DBLP:journals/iandc/YoshidaBH04,BHY,DBLP:conf/concur/SangiorgiX14}) are also related.
The well-known encoding of the higher-order $\pi$-calculus
into the  $\pi$-calculus 
by Sangiorgi~\cite{SangiorgiD:expmpa} 
is fully abstract with respect to reduction-closed, barbed congruence. 
We have shown in \secref{subsec:HOp_to_sessp} that the analogue of Sangiorgi's encoding for the session typed setting also satisfies full abstraction (up to $\hwb$/$\fwb$, cf. \propref{prop:op_corr_HOp_to_p}).
A basic form of input/output types is used in~\cite{DBLP:journals/tcs/Sangiorgi01}, where the encoding in~\cite{SangiorgiD:expmpa} is casted in the asynchronous setting, with output and applications coalesced in a single construct. Building upon~\cite{DBLP:journals/tcs/Sangiorgi01}, 
a simply typed encoding for synchronous processes is given in~\cite{SaWabook}; the reverse encoding (i.e.,  first-order communication into higher-order processes) is also studied there for an asynchronous, localised $\pi$-calculus (only the output capability of names can be sent around).
The work~\cite{San96int} studies hierarchies for calculi with \emph{internal} first-order mobility and 
with higher-order mobility without name-passing (similarly as the subcalculus \HO). 
The hierarchies are %based on expressivity: 
formally defined according to the order of types needed in typing:
they describe different ``degrees of mobility''.
Via fully abstract encodings, it is shown that that name- and process-passing calculi with equal order of types have the same expressiveness.

%With respect to these previous results, our approach based on session types 
%has several important consequences and allows us to derive new results.  Our study reinforces the intuitive view of ``encodings as protocols'', namely session protocols which enforce precise linear and shared disciplines for names, a distinction not investigated in~\cite{SangiorgiD:expmpa,DBLP:journals/tcs/Sangiorgi01}. 
%In turn, the linear/shared distinctionbs central in proper definitions of trigger processes, which are essential to encodings and behavioural equivalences.
%More interestingly, we showed that $\HO$, a  minimal higher-order session calculus (no name passing, only first-order application) suffices to encode $\sessp$ (the session calculus with name passing) but also 
%$\HOp$  and 
%its extension  with higher-order applications (denoted $\HOpp$). 
%Thus, using session types all these calculi are shown to be equally expressive with fully abstract encodings.
%To our knowledge, these are the first expressiveness results of this kind.

Other related works are~\cite{BundgaardHG06,DBLP:journals/entcs/MeredithR05,XuActa2012,DBLP:journals/iandc/LanesePSS11}.
The paper~\cite{BundgaardHG06} proposes a fully abstract, contin\-u\-a\-tion-passing style encoding of the 
$\pi$-calculus into Homer, a higher-order  calculus with explicit locations, local names, and nested locations.
The paper~\cite{DBLP:journals/entcs/MeredithR05}
presents a \emph{reflective}  calculus with a ``quoting'' operator: names are quoted processes and represent the code 
of a process; name-passing then becomes a way of passing the code of a process. This reflective calculus 
can encode both first- and higher-order $\pi$-calculus.
Building upon~\cite{ThomsenB:plachoasgcfhop},
the work~\cite{XuActa2012} studies 
the (non)en\-co\-da\-bi\-lity of the untyped $\pi$-calculus into 
a higher-order $\pi$-calculus with a powerful 
name relabelling operator, which is 
%shown to be 
essential to encode name-passing. 
In a recent   development, the paper~\cite{DBLP:journals/corr/XuYL15} defines an encoding of the (untyped) $\pi$-calculus 
without relabeling. 
The encoding in~\cite{DBLP:journals/corr/XuYL15} is quite different from the one in~\secref{subsec:HOpi_to_HO}:
in~\cite{DBLP:journals/corr/XuYL15} names are encoded using polyadic name abstractions (called \emph{pipes}); 
guarded replication (rather than recursion) enables infinite behaviours.
While our encoding satisfies full abstraction (\propref{prop:fulla_HOp_to_HO}), 
the encoding in~\cite{DBLP:journals/corr/XuYL15} does not: only 
divergence-reflection
and 
operational correspondence (soundness and completeness) properties 
are established.
Soundness is stated up-to \emph{pipe-bisimilarity}, an equivalence tailored to the encoding strategy;
the authors of~\cite{DBLP:journals/corr/XuYL15} describe this result as ``weak''.
%this result is described by the authors of~\cite{DBLP:journals/corr/XuYL15} as ``weak''.


A minimal calculus of higher-order concurrency is studied in~\cite{DBLP:journals/iandc/LanesePSS11}: it lacks restriction,  name passing, output prefix, % (asynchronous communication), 
and %constructs for infinite behaviour.
replication/recursion. 
Still, this  sublanguage of \HO is Turing equivalent.
In~\cite{DBLP:conf/icalp/LanesePSS10}
this core calculus  is extended with restriction,
output prefix, and polyadicity: it is shown that 
synchronous communication can encode asynchronous communication, % (as in the first-order setting),
and that process passing polyadicity induces an expressiveness  hierarchy. % (unlike the first-order setting).
%A further extension with process abstractions of order one
%(functions from processes to processes)
% is shown to strictly add expressive power with respect to passing of processes only.
The paper~\cite{DBLP:conf/wsfm/XuYL13} 
complements~\cite{DBLP:conf/icalp/LanesePSS10} 
by studying the expressivity %of second-order abstractions.
%with replication ($!P$).  
%The work \cite{DBLP:conf/wsfm/XuYL13} focuses  
%%name and process abstractions are distinguished and contrasted, also 
%on expressiveness of the hirarchy of polyadic abstraction parameters. 
%(the same kind of polyadicity present in \pHOp)
%By adapting the encodings in~\cite{DBLP:conf/icalp/LanesePSS10} 
%Polyadicity 
of 
second-order process abstractions.
Polyadicity is shown to induce an expressiveness hierarchy; 
also,
by adapting the encoding in~\cite{SangiorgiD:expmpa},
process abstractions are encoded into name abstractions.
In contrast, we 
give a fully abstract encoding of
 \PHOpp into \HO that preserves session types; this improves~\cite{DBLP:conf/icalp/LanesePSS10,DBLP:conf/wsfm/XuYL13}   
by enforcing linearity disciplines on process behaviour.
The focus of~\cite{DBLP:conf/icalp/LanesePSS10,XuActa2012,DBLP:conf/wsfm/XuYL13,DBLP:journals/corr/XuYL15} is on 
untyped, higher-order processes; they
%Moreover,~\cite{DBLP:conf/icalp/LanesePSS10,DBLP:conf/wsfm/XuYL13}
do not address communication disciplined by 
(session) type systems.
%therefore, our work complements their  results. 
% by clarifying the status of typeful %, resource-aware 
%structured communications. % in trigger-based representations of process passing, both in encodings and  equivalences.



Within session types, the works~\cite{DemangeonH11,Dardha:2012:STR:2370776.2370794} 
study encodings of binary session calculi into a linearly typed $\pi$-calculus. 
While~\cite{DemangeonH11}~gives a precise encoding of \sessp into a linear calculus 
(an extension of \cite{BHY}),  
the work~\cite{Dardha:2012:STR:2370776.2370794} 
gives  operational correspondence (without full abstraction)
for the first- and higher-order 
$\pi$-calculi into \cite{LinearPi}. 
%They investigate an embeddability of two different typing systems;
By the result of \cite{DemangeonH11}, 
\HOpp is encodable  into the linearly typed $\pi$-calculi.     
The syntax of $\HOp$ is a subset of that in~\cite{tlca07,MostrousY15}.
The work~\cite{tlca07} develops a full higher-order session calculus
with process abstractions and applications; it admits the type 
$U=U_1 \rightarrow U_2 \dots U_n \rightarrow \Proc$ and its linear type 
$U^1$
which corresponds to $\shot{\tilde{U}}$ and $\lhot{\tilde{U}}$ in 
a super-calculus of $\HOpp$ and $\PHOp$. 
%in~\cite{MostrousY15} in the asynchronous setting.
%The session type
%system considered is influenced by the type systems for $\lambda$-calculi and
%uses type syntax of the form $U_1 \rightarrow U_2 \dots U_n \rightarrow \Proc$
%for shared values and $(U_1 \rightarrow U_2 \dots U_n \rightarrow \Proc)^{1}$
%for linear values.
%Such a type is expressed in $\HOpp$
%terms using the type $\shot{U}$ (respectively, $\lhot{U}$)
%with $U$ being a nested higher-order type; and 
%the $\HOp$ uses only types of the form
%$\shot{C}$ and $\lhot{C}$ with $C$ being a first-order channel type.
Our results show that
the calculus in~\cite{tlca07} is not only expressed but 
also reasoned in 
$\HO$ (with limited form of arrow types, $\shot{C}$ and $\lhot{C}$), via precise encodings. 


\jp{\paragraph{Acknowledgments}
We benefited from feedback from the users of the Moca mailing list, in particular Greg Meredith and
 Xu Xian.}
%\newpage




