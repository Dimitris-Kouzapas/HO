% !TEX root = main.tex
\begin{abstract}
%\noi \textbf{\abstractname} \ 
In \emph{higher-order process calculi} exchanged values may contain processes:
by integrating
constructs from the $\lambda$-calculus and 
the $\pi$-calculus
these languages %uniformly combine 
enable the specification of communications with mobile code.
We consider 
\HOp, 
the higher-order $\pi$-calculus in
which communications are governed by \emph{session types} that express interaction protocols.
We develop a complete 
study of the expressivity of \HOp and of its most significant subcalculi.
Our study adopts the novel notion of \emph{precise encodings}: these are encodings that  
satisfy usual syntactic and semantic encodability criteria, but also \emph{preserve types}
and satisfy \emph{full abstraction} up to typed behavioral equalities.
We identify \HO, 
a core subcalculus of \HOp which lacks
\jpc{higher-order applications/abstractions}, name-passing,
and recursion.
We show that \HO can  encodings which are  encode 
\HOp. 
Also, we show that \HO can   encode extensions of \HOp with higher-order abstractions/applications, as found in 
%previously proposed 
existing
higher-order session calculi.
Moreover, we show  
that $\sessp$ (a first-order session $\pi$-calculus) can encode 
\HOp. %, fully abstractly.  
%Our encodings are fully abstract.
%We also 
%prove that 
%%then prove a  non-encodability result from 
%the session $\pi$-calculus
%with passing of shared names 
%cannot be encoded 
%into \HOp without shared names. 
All our encodings are precise; overall, we show that $\HOp$, $\HO$, and $\sessp$ are  equally expressive.
%the expressivity of \HO enables effective reasoning about 
%typed equivalences for higher-order processes, as developed in our previous work.

%Our results highlight how the expressivity of \HO
%results into more effective 
%%reduces a burden of 
%reasoning about typed
%equivalences for 
%higher-order % name-passing 
%session processes. 
%

%In calculi for \emph{higher-order} concurrency, values exchanged as communication objects may include processes. Based on process passing, this paradigm is in contrast with the \emph{first-order} (or name passing) concurrency of the $\pi$-calculus. %based on name passing. 
%%The higher-order paradigm is sometimes consideredBy combining mechanisms for functional and concurrent computation, these languages offer a unified account of different forms of interaction. 
%Although previous works have related calculi for higher-order and first-order concurrency, little is known about the nature of this relationship when interactions are disciplined by \emph{types for structured communications}. Here we tackle this challenge from the perspective of \emph{session types}, focusing on \emph{typed behavioral equivalences} and issues of \emph{relative expressiveness}. First, we identify a core higher-order, session-typed calculus and develop for it  characterizations of typed contextual equivalences as labeled bisimilarities. 
%Second, we formalize (non) encodability results between session calculi with either name-passing or process-passing mechanisms. 
%Our results clarify the relationship between name- and process-passing in terms of high-level communication structures based on types. 
\end{abstract}
