\section{Typed Encodings}\label{s:expr}

We define the notion of \emph{typed encoding} that we
shall use in the following section.
%In general, we may define:

\begin{definition}[Typed Calculus]\label{d:tcalculus}\rm
	A \emph{typed calculus} $\tyl{L}$ is a tuple
$		\calc{L}{T}{\hby{\ell}}{\wb}{\proves}$
	where $L$ and $T$ are set of processes and types, respectively.
	Also, $\hby{\ell}$, $\wb$, and $\proves$ 
	denote a transition semantics, a typed process equivalence, and a type system for $L$ processes, respectively. 
\end{definition}

Since we study subcalculi of $\HOp$, 
the typed calculi considered here 
use the same 
  type system (as in \S\,\ref{s:types}),
 transition semantics (cf. Def.~\ref{d:tlts}) with labels $\ell$ (as in  \S\,\ref{ss:lts}), 
 and behavioral equivalence (cf. Def.~\ref{d:bisim}). 
  Thus, in the following, when writing $\tyl{L}_i$ we tacitly assume the existence of appropriate 
  $L_i$ and $T_i$, keeping all other elements unchanged.
 We now define the notion of encoding over typed calculi.

\begin{definition}[Typed Encoding]\rm
	Let  $\tyl{L}_1$ % = \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1}$
	and $\tyl{L}_2$ % =  \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$ 
	be typed calculi. % as in Definition~\ref{d:tcalculus}.
	Given mappings $\map{\cdot}: L_1 \to L_2$, 
	$\mapt{\cdot}: T_1 \to T_2$, and 
	$\mapa{\cdot}: \ell \to \ell^{\,m}$, 
	we write 
	%$\enc{\cdot}{\cdot}: \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1} \longrightarrow \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$
%	for the encoding from $\calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1}$ to $\calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$.
	$\enco{\map{\cdot}, \mapt{\cdot}, \mapa{\cdot}} : \tyl{L}_1 \to \tyl{L}_2$
	to denote the \emph{typed encoding} of $\tyl{L}_1$ into $\tyl{L}_2$.
\end{definition}

Our notion of encoding considers a mapping on processes, 
% mapping $\map{\cdot}$,
a mapping on types, % $\mapt{\cdot}$, 
and a mapping %$\mapa{\cdot}$ 
from transition labels 
into \emph{sets} of transition labels.
We will often assume that  $\mapt{\cdot}$ extends to typing environments as expected.
As we will define several typed encodings,  
in the following we use number decorations on these mappings, to distinguish them.






%\subsection{Encoding Properties}
%We use the following labeled transitions:
%\begin{enumerate}
%\item Strong case: $\Gamma; \emptyset; \Delta_1 \hby{\ell} \Delta_1' \proves P_1 \hby{\ell} P_2$ \\
%(With the new command: $\stytra{\Gamma}{\ell}{\Delta_1}{P_1}{\Delta'_1}{P_2}$)
%\item Weak case: $\Gamma; \emptyset; \Delta_1 \Hby{ \ell} \Delta_1' \proves P_1 \Hby{ \ell} P_2$ \\
%(With the new command: $\wtytra{\Gamma}{\ell}{\Delta_1}{P_1}{\Delta'_1}{P_2}$)
%\item Using the command for weak bisimilarity:
%$\wbb{\Gamma}{\ell}{\Delta_1}{P_1}{\Delta'_1}{P_2}$.
%
%\end{enumerate}

We require that a {\em good} typed encoding should 
preserve not only the syntax but
also the operational, typing and behavioural
semantics. 

% ----> DK: The next notation is already defined
%\begin{notation}[Typed Equivalence]\rm
%	Let $P$ and $Q$ be two well-typed processes, i.e., 
%	there exist $\Gamma, \Sigma_1, \Sigma_2$ such that 
%	$\Gamma; \emptyset; \Sigma_1 \proves P \hastype \Proc$ 
%	and
%	$\Gamma; \emptyset; \Sigma_2 \proves Q \hastype \Proc$.
%	Then, to denote the fact that 
%	$P$ and $Q$ are related by behavioral equivalence $\wb$, we shall write
%	%Then we adopt the following notational convention:
%	\[
%		\Gamma; \Sigma_1 \wb \Sigma_2 \proves P \wb Q.
%	\]
%\end{notation}

\begin{definition}[Semantic Preserving Encoding]\rm
	\label{def:ep}
	We say that $\enco{\map{\cdot}, \mapt{\cdot}, \mapa{\cdot}}: \tyl{L}_1 \to \tyl{L}_2$ is a \emph{semantic preserving encoding}
	if it satisfies the following properties:
	
	\begin{enumerate}[1.]
		\item \emph{Type preservation}:
		if
			$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then 
			$\mapt{\Gamma}; \emptyset; \mapt{\Delta} \proves \map{P} \hastype \Proc$,  
			for any   $P$ in $L_1$.

		\item \emph{Operational Correspondence}: If $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then
		\begin{enumerate}[-]
%			\item	Completeness: \\
%			    If $P \red_1 P'$ then $\exists\, \Delta'$ s.t.
%				$\map{P} \Red_2 \map{P'}$ and
%				$\mapt{\Gamma}; \emptyset; \mapt{\Delta'} \proves_2 \map{P'} \hastype \Proc$.
			\item	Completeness: 
			   If  $\stytra{\Gamma}{\ell_1}{\Delta_1}{P}{\Delta'_1}{P'}$
			   then \\ $\exists \ell_2$ s.t. 
			    $\wtytra{\mapt{\Gamma}}{\ell_2}{\mapt{\Delta_1}}{\map{P}}{\mapt{\Delta'_1}}{\map{P'}}$
			    and $\ell_2 = \mapa{\ell_1}$.
			    				
%			\item Soundness : \\
%			    If $\map{P} \red_2 Q$ then
%				$\exists P'$ s.t. $P \red_1 P'$ and 
%				$\mapt{\Gamma}; \mapt{\Delta_1} \wb_2 \mapt{\Delta_2} \proves_2 \map{P'} \wb_2 Q$.
				
			\item Soundness:   
			If  $\wtytra{\mapt{\Gamma}}{\ell_2}{\mapt{\Delta_1}}{\map{P}}{\mapt{\Delta'_1}}{Q}$
			   then $\exists \ell_1, P'$ s.t.  \\
			    (i)~$\stytra{\Gamma}{\ell_1}{\Delta_1}{P}{\Delta'_1}{P'}$,
			    (ii)~$\ell_2 = \mapa{\ell_1}$, and
			    (iii)~$\wbb{\mapt{\Gamma}}{\ell}{\mapt{\Delta'_1}}{\map{P'}}{\mapt{\Delta'_1}}{Q}$.
		\end{enumerate}
		
		\item \emph{Full Abstraction:} \\
%		$\Gamma; \Delta_1 \wb \Delta_2 \proves P \wb Q $ if and only if $\mapt{\Gamma}; \mapt{\Delta_1} \wb \mapt{\Delta_2} \proves \map{P} \wb \map{Q} $.
		\wbb{\Gamma}{}{\Delta_1}{P}{\Delta_2}{Q}
		if and only if
		\wbb{\mapt{\Gamma}}{}{\mapt{\Delta_1}}{\map{P}}{\mapt{\Delta_2}}{\map{Q}}.
	\end{enumerate}
\end{definition}

\begin{remark}\label{r:multilabels}
We  assume that if 
$P \hby{\ell} P'$ and $\mapa{\ell} = \{\ell_1, \ell_2,  \cdots, \ell_m\}$ then
$\map{P} \Hby{\mapa{\ell}} \map{P'}$
should be understood as
$\map{P} \Hby{\ell_1} P_1 \Hby{\ell_2} P_2 \cdots \Hby{\ell_m} P_m =  \map{P'}$,
for some
$P_1, P_2, \ldots, P_m$.
This is useful for the encoding of polyadic into monadic communication.
\end{remark}

We show that the composition of encodings is closed on the above properties.

\begin{proposition}[Composability of Semantic Preserving Encodings]
	Let 
	$\enco{\map{\cdot}^{1}, \mapt{\cdot}^{1}, \mapa{\cdot}^{1}}: \tyl{L}_1 \to \tyl{L}_2$
	and 
	$\enco{\map{\cdot}^{2}, \mapt{\cdot}^{2}, \mapa{\cdot}^{2}}: \tyl{L}_2 \to \tyl{L}_3$
%	$\enco{\cdot}{\cdot}{1}: \tyl{L}_1 \to \tyl{L}_2$ and $\encod{\cdot}{\cdot}{2}: \tyl{L}_2 \to \tyl{L}_3$
	be two semantic preserving encodings.
	Then their composition, denoted 
	$\enco{\map{\cdot}^{1} \circ \map{\cdot}^{2}, \mapt{\cdot}^{1} \circ \mapt{\cdot}^{2}, \mapa{\cdot}^{1}\circ \mapa{\cdot}^{2}}: \tyl{L}_1 \to \tyl{L}_3$
	is also a semantic preserving encoding.
\end{proposition}

\begin{proof}
	Straightforward application of the definition of each property.
\end{proof}

\section{Positive Expressiveness Results}
In this section we present a study of the expressiveness of $\HOp$ and its subcalculi. 
We present four encodings:
\begin{enumerate}[1.]
\item Polyadic into Monadic Communication (\S\,\ref{ss:polmon})
\item Finite First-Order Communication into Higher-Order Communication (\S\,\ref{ss:ffotoho})
\item  First-Order Communication (with Recursion) into Higher-Order  (\S\,\ref{ss:fullfotoho})
\item Higher-Order Communication into First-Order Communication (\S\,\ref{ss:hotofo})
\end{enumerate}
In each case, encoding correctness is supported by type preservation and operational correspondence statements.
Full abstraction results are conjectured, for the moment.

\begin{comment}
\subsection{Languages Under Consideration}
We consider the following variants of \HOp:
\begin{enumerate}[-]
	\item	\HO: the second and third lines of the syntax of processes in Fig.~\ref{fig:syntax} (pure higher-order, monadic communication).
	\item	\sesp: the first and third lines of the syntax of processes in Fig.~\ref{fig:syntax} (first-order, monadic communication).
	\item	\sespnr: the finite sub-calculus of \sesp, i.e., name passing without recursion.
	\item	$\HO^{+\mathsf{p}}$: The polyadic \HO, i.~e.\ without polyadicity (polyadic abstraction/application).
	\item	$\sesp^{+\mathsf{p}}$: The polyadic \sesp, i.~e.\ with polyadicity (name passing)
	\item	$\HOp^{-\mathsf{p}}$: The monadic \HOp.
%	\item \pHOpnr: the finite variant of \pHOp 
%	\item \psesp: the variant of \sesp with polyadic communication.
%	\item \psespnr: the finite variant of \psesp with polyadic communication.
\end{enumerate}
\noindent
In the following we write $\pmap{\cdot}{i}$
and $\tmap{\cdot}{i}$ 
for mappings of processes and types, respectively.
Since we always consider variants and fragments of \HOp, the 
reduction semantics $\red$, the typed behavioral equivalence $\wb$,
and the type system $\proves$ are the same for all languages.
\end{comment}

\subsection*{Preliminaries}

The following result may be related to Lemma~\ref{l:invariant}: \jp{TO BE ADJUSTED with new typed LTS!}

\begin{lemma}[Inversion for (Untyped) Transitions]
\begin{enumerate}[1.]
% output
\item If $\Gamma;\, \emptyset;\, \Delta_1 \cat \Delta_2 \cat k:\btout{U}S \proves \bout{k}{V}P' \hastype \Proc$
and $\Gamma;\, \emptyset;\, \Delta_2 \cat k:S \proves V \hastype U$ then \\
$\bout{k}{V}P' \by{\bactout{k}{V}} P'$
and $\Gamma;\, \emptyset;\, \Delta_1 \proves P' \hastype \Proc$.

\item If $\Gamma;\, \emptyset;\, \Delta_1 \cat \Delta_2 \cat k:\btout{U}S \proves \bout{k}{V}P' \hastype \Proc$
and $\Gamma;\, \emptyset;\, \Delta_2 \proves V \hastype U$ (with $k:S \not\in \Delta_2$) then \\
$\bout{k}{V}P' \by{\bactout{k}{V}} P'$
and $\Gamma;\, \emptyset;\, \Delta_1 \cat k:S \proves P' \hastype \Proc$.

% input
\item If $\Gamma;\, \emptyset;\, \Delta \cat k:\btinp{\mytilde{C}}S \proves \binp{k}{\mytilde{x}}P' \hastype \Proc$
 then \\
$\binp{k}{\mytilde{x}}P' \by{\bactinp{k}{\mytilde{m}}} P'\subst{\mytilde{m}}{\mytilde{x}}$
and $\Gamma;\, \emptyset;\, \Delta \cat k:S \cat \mytilde{m}:\mytilde{C} \proves P'\subst{\mytilde{m}}{\mytilde{x}} \hastype \Proc$


\item If $\Gamma;\, \emptyset;\, \Delta_1 \setminus \Delta_2 \cat k:\btinp{L}S \proves \binp{k}{X}P' \hastype \Proc$
and
$\Gamma;\, \emptyset;\, \Delta_2   \proves X \hastype L$
 then \\
$\binp{k}{X}P' \by{\bactinp{k}{V}} P'\subst{V}{X}$
and $\Gamma;\, \emptyset;\, \Delta_1 \cat k:S \proves P'\subst{V}{X} \hastype \Proc$

% branch
\item If $\Gamma;\, \emptyset;\, \Delta \cat k:\btbra{l_i:S_i}_{i \in I} \proves \bbra{k}{l_i : P_i}_{i \in I}  \hastype \Proc$
 then, for any $j \in I$, we have \\
$\bbra{k}{l_i : P_i}_{i \in I} \by{\bactbra{k}{l_j}} P_j $
and $\Gamma;\, \emptyset;\, \Delta \cat k:S_j   \proves P_j \hastype \Proc$

% selecy
\item If $\Gamma;\, \emptyset;\, \Delta \cat k:\btsel{l_i:S_i}_{i \in I} \proves \bsel{k}{l_j} P_j  \hastype \Proc$
 then \\
$\bsel{k}{l_j} P_j \by{\bactsel{k}{l_j}} P_j $
and $\Gamma;\, \emptyset;\, \Delta \cat k:S_j   \proves P_j \hastype \Proc$

% bound output
\item Suppose (i)~$\Gamma;\, \emptyset;\, (\Delta_1 \cat \Delta_2) \setminus \{k:S_0, s:T\} \cat k:\btout{U}S_0 
\proves \news{s}\bout{k}{V}P' \hastype \Proc$, \\
(ii)~$\Gamma;\, \emptyset;\, \Delta_2 \cat \dual{s}:S \proves V \hastype U$ (with $S \dualof T$),
and (iii)~$\{k:S_0, s:T\} \in \Delta_1 \cat \Delta_2$. \\
Then 
$\news{s}\bout{k}{V}P' \by{\news{s}\bactout{k}{V}} P'$
and $\Gamma;\, \emptyset;\, \Delta^* \proves P' \hastype \Proc$, with \\
$(\Delta^* = \Delta_1 \cat k:S_0 \cat s:T) \lor (\Delta^* = \Delta_1 \cat k:S_0) \lor
(\Delta^* = \Delta_1 \cat  s:T) \lor (\Delta^* = \Delta_1)$.


% bound output
\item Suppose (i)~$\Gamma;\, \emptyset;\, \Delta \cat k:\btout{U}S_0 
\proves \news{s}\bout{k}{V}P' \hastype \Proc$
(with $\{k:S_0, s:T\} \not\subseteq \Delta$), 
(ii)~$\Gamma;\, \emptyset;\, \Delta_2 \cat \dual{s}:S \proves V \hastype U$ (with $S \dualof T$),
and (iii)~$\Delta_2 \subseteq \Delta$. 
Then $\news{s}\bout{k}{V}P' \by{\news{s}\bactout{k}{V}} P'$ and \\
$\Gamma;\, \emptyset;\, \Delta^* \proves P' \hastype \Proc$, with \\
$(\Delta^* = \Delta \setminus \Delta_2 \cat k:S_0 \cat s:T) \lor (\Delta^* = \Delta \setminus \Delta_2 \cat k:S_0) \lor
(\Delta^* = \Delta \setminus \Delta_2 \cat  s:T) \lor (\Delta^* = \Delta \setminus \Delta_2)$.


\end{enumerate}
\end{lemma}

\subsection{Encoding Polyadic Semantics (\HOp) to Monadic Semantics ($\HOp^{-\mathsf{p}}$)}\label{ss:polmon}

%In the extension of \HOp with 
%polyadic communication, denoted \pHOp, 
%one may pass in each synchronization 
%a tuple of values of length $n$, rather than a just single value.
%Thus, e.g., for $n = 2$ one would have
%%
%\begin{eqnarray*}
%	\bout{n}{m_1, m_2} P \Par \binp{\dual{n}}{x_1,x_2} Q  & \red &  P \Par Q \subst{m_1, m_2}{x_1, x_2} \\
%	\bout{n}{\abs{x_1, x_2}{P_1}} P \Par \binp{\dual{s}}{\X} Q & \red & P \Par Q \subst{\abs{x_1,x_2}{P_1}}{\X}
%\end{eqnarray*}
%%
%with $\appl{X}{k_1,k_2} \subst{\abs{x_1,x_2}{Q}}{\X}  =  Q \subst{k_1,k_2}{x_1,x_2} $.
%Thus, 
%\pHOp features tuple passing in intra-session (linear) communication,
%but also in abstractions/applications. 
%The session type system for \pHOp is an orthogonal
%extension of that in \S\,\ref{s:types}.
%The type syntax for values is extended as follows,
%where $\tilde{S}$ stands for a sequence $S_1, \ldots, S_n$ of 
%session types:
%
%\begin{eqnarray*}
%	U \bnfis  & \tilde{S} \bnfbar \lhot{\tilde{S}} \bnfbar \shot{\tilde{S}} \bnfbar \chtype{S}
%\end{eqnarray*}
%
%The syntax of session types would be kept unchanged.
%Typing rules require straightforward extensions. 
%For instance, the following rules would type 
%abstraction and application in the biadic case ($n = 2$):
%\[
%\trule{Abs2}~~\tree{
%			\Gamma; \Lambda; \Sigma \cat x_1: S_1, x_2: S_2 \proves P \hastype \Proc
%		}{
%			\Gamma; \Lambda; \Sigma \proves \abs{x_1, x_2}{P} \hastype \lhot{(S_1, S_2)}
%		}
%		\quad
%		\trule{App2}~~\tree{
%		\begin{array}{c}
%		(U = \lhot{(S_1,S_2)}) \lor (U = \shot{(S_1,S_2)}) \\
%		\Gamma; \Lambda; \Sigma \proves X \hastype U  \\
%		\Gamma; \Lambda_1; \Sigma_1 \proves k_1 \hastype S_1 \quad 		
%		\Gamma; \Lambda_2; \Sigma_2 \proves k_2 \hastype S_2
%		\end{array}
%		}{
%			\Gamma; \Lambda \cup  \Lambda_1 \cup \Lambda_2; \Sigma \cup \Sigma_1 \cup \Sigma_2 \proves \appl{X}{k_1,k_2} \hastype \Proc
%		} 
%\]

In the untyped $\pi$-calculus, polyadic communication
can be encoded into monadic name passing by first generating a fresh channel and then 
performing $n$ monadic synchronizations on that channel. 
In session-typed $\pi$-calculi this encoding is even more direct, 
thanks to the linearity and non-interference  of session endpoints~\cite{VascoFun}.
%The extension of the (monadic) session type system given in \S\,\ref{s:types}
%to handle polyadic communication is straightforward and follow expected lines.
%For this reason, we do not present a typing system for \pHOp in full detail; rather, 
%we shall define a syntactic transformation of \pHOp into \HOp, rather than as a typed encoding.
%\footnote{The definition of a polyadic semantics would only add visual clutter to our presentation,
%as all results extend easily from monadic to polyadic communication.}
Below we  define an encoding of polyadic semantics to monadic semantics.
Using this encoding, %Because of the polyadic to monadic encoding %, denoted  $\auxmap{\cdot}{\mathsf{p}}$,
we may focus on monadic session processes,
and rely on polyadic constructs simply as convenient syntactic sugar.
In fact, we shall rely on polyadicity to encode recursive behaviors.
%
\begin{definition}[Polyadic Into Monadic]\label{d:enc:poltomon}
Let 
$\enco{\map{\cdot}^{\mathsf{p}}, \mapt{\cdot}^{\mathsf{p}}, \mapa{\cdot}^{\mathsf{p}}}: \HOp \to \HOp^{-\mathsf{p}}$
be a typed encoding where
	%$\auxmap{\cdot}{\mathsf{p}}:\pHOp \to \HOp$ as
\begin{figure}[t]
\[
	\begin{array}{rcl}
		\map{\bout{k}{k_1, \cdots, k_m} P}^{\mathsf{p}}
		&\defeq&
		\bout{k}{k_1} \cdots ;  \bout{k}{k_m} \map{P}^{\mathsf{p}}
		\\
			\map{\binp{k}{x_1, \cdots, x_m} P}^{\mathsf{p}}
		&\defeq&
		\binp{k}{x_1} \cdots ; \binp{k}{x_m}  \map{P}^{\mathsf{p}}
		\\
		\map{\bbout{k}{\abs{x_1, \cdots, x_m} Q} P}^{\mathsf{p}}
		&\defeq&
		\bbout{k}{\abs{z}\binp{z}{x_1} \cdots ; \binp{z}{x_m} \map{Q}^{\mathsf{p}}} \map{P}^{\mathsf{p}}
		\\ 
		\map{\appl{X}{k_1, \cdots, k_m}}^{\mathsf{p}}
		&\defeq&
		\newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{k_1} \cdots ; \bout{\dual{s}}{k_m} \inact} 
        \\ % typed mapping starts here
		\tmap{\btout{S_1, \cdots, S_m}S}{\mathsf{p}}
		&\defeq&
		\btout{\tmap{S_1}{\mathsf{p}}} \cdots ; \btout{\tmap{S_m}{\mathsf{p}}}\tmap{S}{\mathsf{p}}
		\\
		\tmap{\btinp{S_1, \cdots, S_m}S}{\mathsf{p}}
		&\defeq&
		\btinp{\tmap{S_1}{\mathsf{p}}} \cdots ; \btinp{\tmap{S_m}{\mathsf{p}}}\tmap{S}{\mathsf{p}}
		\\
		\tmap{\bbtout{L} S}{\mathsf{p}}
		&\defeq&
		\bbtout{\mapt{L}^{\mathsf{p}}}\mapt{S}^{\mathsf{p}}
		\\
		\tmap{\bbtinp{L} S}{\mathsf{p}}
		&\defeq&
		\bbtinp{\mapt{L}^{\mathsf{p}}}\mapt{S}^{\mathsf{p}}
		\\
%		\tmap{\bbtout{\shot{(C_1, \cdots, C_m)}} S}{\mathsf{p}}
%		&\defeq&
%		\bbtout{
%		\shot{\big(\btinp{\tmap{C_1}{\mathsf{p}}} \cdots; \btinp{\tmap{C_m}{\mathsf{p}}}\tinact\big)}}\mapt{S}^{\mathsf{p}}
%		\\
%		\tmap{\bbtinp{\shot{(C_1, \cdots, C_m)}} S}{\mathsf{p}}
%		&\defeq&
%		\bbtinp{
%		\shot{\big(\btinp{\tmap{C_1}{\mathsf{p}}} \cdots; \btinp{\tmap{C_m}{\mathsf{p}}}\tinact\big)}}\mapt{S}^{\mathsf{p}}
%		\\
		\tmap{\shot{(C_1, \cdots, C_m)}}{\mathsf{p}}
		&\defeq&
		\shot{\big(\btinp{\tmap{C_1}{\mathsf{p}}} \cdots; \btinp{\tmap{C_m}{\mathsf{p}}}\tinact\big)}
		\\
		\tmap{\lhot{(C_1, \cdots, C_m)}}{\mathsf{p}}
		&\defeq&
		\lhot{\big(\btinp{\tmap{C_1}{\mathsf{p}}} \cdots; \btinp{\tmap{C_m}{\mathsf{p}}}\tinact\big)}
		\\
%		\tmap{\lhot{(C_1, \cdots, C_m)}}{\mathsf{p}}
%		&\defeq&
%		\lhot{\big(\btinp{\tmap{C_1}{\mathsf{p}}} \cdots \btinp{\tmap{C_m}{\mathsf{p}}}\tinact\big)}
%		\\
%		\tmap{\shot{(C_1, \cdots, C_m)}}{\mathsf{p}}
%		&\defeq&
%		\shot{\big(\btinp{\tmap{C_1}{\mathsf{p}}} \cdots \btinp{\tmap{C_m}{\mathsf{p}}}\tinact\big)}
%		\\ % action mapping starts here
		\mapa{\bactout{k}{k_1, \ldots, k_m}}^\mathsf{p} &\defeq&   \big\{\bactout{k}{k_1}, \cdots, \bactout{k}{k_m}\big\} \\
		\mapa{\bactinp{k}{k_1, \ldots, k_m}}^\mathsf{p} &\defeq&   \big\{\bactinp{k}{k_1}, \cdots, \bactinp{k}{k_m} \big\}\\
		\mapa{\bactout{k}{\abs{x_1, \ldots, x_m}{P}} }^\mathsf{p} &\defeq&  \bactout{k}{\abs{z}\binp{z}{x_1} \cdots ; \binp{z}{x_m} \map{P}^{\mathsf{p}}} \\
		\mapa{\bactinp{k}{\abs{x_1, \ldots, x_m}{P}} }^\mathsf{p} &\defeq&  \bactinp{k}{\abs{z}\binp{z}{x_1} \cdots ; \binp{z}{x_m} \map{P}^{\mathsf{p}}} 
	\end{array}
\]
\caption{\label{f:enc:poltomon}
Typed encoding of polyadic into monadic communication (cf.~Defintion \ref{d:enc:poltomon}). 
Mappings 
$\map{\cdot}^\mathsf{p}$,
$\mapt{\cdot}^\mathsf{p}$, 
and 
$\mapa{\cdot}^\mathsf{p}$
are homomorphisms for the other processes/types/labels. 
}
\end{figure}
mappings $\map{\cdot}^{\mathsf{p}}$, $\mapt{\cdot}^{\mathsf{p}}$, $\mapa{\cdot}^{\mathsf{p}}$
are 
as in Fig.~\ref{f:enc:poltomon}.
	%\jp{I prefer to be explicit in the encoding of polyadic abstraction/applications. Previous version is commented.}
\end{definition}
%
The encoding is simple:
passing an $m$-tuple of names over a session channel $k$ is represented by 
a $m$ exchanges along channel $k$.
The output of an abstraction with $m$ bound variables $x_1, \ldots, x_m$ is represented by
outputting an abstraction with a single bound variable $z$,
which is used as the subject for receiving $x_1, \ldots, x_m$ individually. 
Accordingly, 
%When we are dealing with an abstraction over a list of bound variables,
%then we create a new abstraction name and we use it to receive in a polyadic
%way the list of names on the abstraction. Similarly 
the encoding of a polyadic application  instantiates
the abstraction subject with a freshly generated session name $s$, which will be used  
to the names 
$k_1, \ldots, k_m$
that are going to be applied on the abstraction.
Observe how $\mapa{\cdot}^{\mathsf{p}}$ maps polyadic labels for input and output into (ordered) sets of
monadic labels. Also, note that we do not allow polyadic mapping on shared names.
The polyadic mapping, as presented here, is sound only on session names.
%The semantics might break if we apply this mapping on shared names.

%\begin{proposition}
%	$\Gamma; \emptyset; \Sigma \proves \map{P}^{p} \hastype \Proc$
%\end{proposition}

\begin{proposition}[Type Preservation, Polyadic to Monadic]\label{prop:typepresp}
Let $P$ be an  $\HOp$ process.
If			$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then 
			$\mapt{\Gamma}^{\mathsf{p}}; \emptyset; \mapt{\Delta}^{\mathsf{p}} \proves \map{P}^{\mathsf{p}} \hastype \Proc$. 
\end{proposition}

\begin{proof}
By induction on the inference $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$.
Details in \S\,\ref{app:polmon}.
	\qed
\end{proof}

\begin{proposition}\label{p:poltomo}
Let $P$ be a well-typed process.
\begin{enumerate}[$-$]
\item If $\map{P\subst{k_1,\cdots, k_m}{x_1, \cdots, x_m}}^{\mathsf{p}} = \map{P}^{\mathsf{p}}\subst{k_1}{x_1}\cdots\subst{k_m}{x_m}$.


\item If $\map{P\subst{\abs{x_1, \cdots, x_m} Q}{X}}^{\mathsf{p}} = \map{P}^{\mathsf{p}}\subst{\abs{z}\binp{z}{x_1} \cdots ; \binp{z}{x_m} \map{Q}^{\mathsf{p}}}{X}$.

\end{enumerate}
\end{proposition}
\begin{proof}
Immediate from the definition of $\map{\cdot}^{\mathsf{p}}$ (cf. Def.~\ref{d:enc:poltomon}).
	\qed
\end{proof}


\begin{proposition}[Operational Correspondence, Polyadic to Monadic]\label{p:ocpotomo}
Let $P$ be an  $\HOp$ process.
If $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then
		\begin{enumerate}[1.]
			\item	 
			   If  $\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$
			   then either
			   \begin{enumerate}[a)]
					\item $\exists \ell'$ s.t. 
					$\mapa{\ell_1} = \ell'$ and 
			    $\wtytra{\mapt{\Gamma}^{\mathsf{p}}}{\ell'}{\mapt{\Delta}^{\mathsf{p}}}{\map{P}}{\mapt{\Delta'}^{\mathsf{p}}}{\map{P'}}$.
			    
			    	\item $\exists \ell'_1, \cdots, \ell'_n, R_1, \cdots, R_n$ s.t.
				    $\map{P} \Hby{\ell'_1} R_1, R_1 \Hby{\ell'_2} R_2, \ldots, R_{n-1} \Hby{\ell'_n} R_n = \map{P'}^{\mathsf{p}}$.
				    %and \\ $\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\mapt{\Delta'}^{\mathsf{p}}}{\map{P'}^{\mathsf{p}}}{\mapt{\Delta'}^{\mathsf{p}}}{R_n}$.
					\end{enumerate}
			   
			   
			    
			\item   
			If  $\stytra{\mapt{\Gamma}^{\mathsf{p}}}{\ell'_1}{\mapt{\Delta}^{\mathsf{p}}}{\map{P}}{\mapt{\Delta'}^{\mathsf{p}}}{R}$
			   then 
			   $\exists \ell_1, P'$ s.t.  
			   $\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$
			   and 
			   either
			   		\begin{enumerate}[a)]
					\item   
			      $\ell'_1 = \mapa{\ell_1}^{\mathsf{p}}$ ~~and~~ 
			    $\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\mapt{\Delta'}^{\mathsf{p}}}{\map{P'}^{\mathsf{p}}}{\mapt{\Delta'}^{\mathsf{p}}}{R}$.
			   		
					\item $\exists \ell'_2, \ldots, \ell'_n, R_2, \ldots, R_n$ s.t. 
					(i) $R \hby{\ell'_2} R_2   \cdots  R_{n-1} \hby{\ell'_n} R_n$,  
					(ii)~$\{\ell'_1, \ell'_2, \cdots, \ell'_n\} = \mapa{\ell_1}^{\mathsf{p}}$, \\ and 
					(iii)~$\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\mapt{\Delta'}^{\mathsf{p}}}{\map{P'}^{\mathsf{p}}}{\mapt{\Delta'}^{\mathsf{p}}}{R_n}$.
					\end{enumerate}


%			\item   
%			If  $\wtytra{\mapt{\Gamma}^{\mathsf{p}}}{\ell_2}{\mapt{\Delta_1}^{\mathsf{p}}}{\map{P}}{\mapt{\Delta'_1}^{\mathsf{p}}}{Q}$
%			   then $\exists \ell_1, P$ s.t.  
%			    (i)~$\stytra{\Gamma}{\ell_1}{\Delta_1}{P}{\Delta'_1}{P'}$, \\
%			    (ii)~$\ell_2 = \mapa{\ell_1}^{\mathsf{p}}$, 
%			    (iii)~$\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\mapt{\Delta'_1}^{\mathsf{p}}}{\map{P'}^{\mathsf{p}}}{\mapt{\Delta'_1}^{\mathsf{p}}}{Q}$.


			    \end{enumerate}
\end{proposition}

\begin{proof}
By transition induction.
%, considering Remark~\ref{r:multilabels} for weak transitions. All cases are easy;
%we only remark that the additional $\tau$-transitions induced by the encoding 
%are directly associated to the polyadicity involved. This is particularly relevant
%when $\ell_1 = \bactinp{n}{\abs{\tilde{x}}{P}}$, for the encoding of a polyadic application involves
%as many $\tau$-transitions (i.e., synchronizations on the restricted name $s$) 
%as polyadic parameters are involved.	\\
We consider parts (1) and (2) separately: \\
\noi \textbf{Part (1)}. We consider two non-trivial cases, using biadic communication:
\begin{enumerate}[1.]

%% Biadic Output 
\item Case  $P =\bout{k}{k_1, k_2} P'$ and $\ell_1 = \bactout{k}{k_1, k_2}$. 
We show that this case falls under part (b) of the thesis.
By assumption, $P$ is well-typed. 
As one particular possibility, we may have:
			\[
				\tree{
					\Gamma; \emptyset; \Delta_0 \cat k:S  \proves  P' \hastype \Proc \quad 
					\Gamma ; \emptyset ; k_1{:} S_1 \cat k_2{:}S_2 \proves  k_1,k_2 \hastype S_1,S_2}{
					\Gamma; \emptyset; \Delta_0 \cat k_1{:}S_1 \cat k_2{:}S_2 \cat k:\btout{S_1,S_2}S \proves  
					\bout{k}{k_1,k_2} P' \hastype \Proc}
			\]
for some $\Gamma, S, S_1, S_2, \Delta_0$, 
such that $\Delta = \Delta_0 \cat k_1{:}S_1 \cat k_2{:}S_2 \cat k:\btout{S_1,S_2}S$.
We may then have the following typed transition
$$
\stytra{\Gamma}{\ell_1}{\Delta_0 \cat k_1{:}S_1 \cat k_2{:}S_2 \cat k:\btout{S_1,S_2}S}{\bout{k}{k_1, k_2} P'}{\Delta_0 \cat k{:}S}{P'}
$$
The encoding of the source judgment for $P$ is as follows:
$$
\mapt{\Gamma}^{\mathsf{p}}; \emptyset; \mapt{\Delta_0 \cat k_1{:}S_1 \cat k_2{:}S_2 \cat k:\btout{S_1,S_2}S}^{\mathsf{p}} \proves \map{\bout{k}{k_1, k_2} P'}^{\mathsf{p}} \hastype \Proc
$$
which, using Def.~\ref{d:enc:poltomon}, can be expressed as 
$$
\mapt{\Gamma}^{\mathsf{p}}; \emptyset; \mapt{\Delta_0} 
\cat k_1{:}\mapt{S_1}^{\mathsf{p}} \cat k_2{:}\mapt{S_2}^{\mathsf{p}} 
\cat k:\btout{\mapt{S_1}^{\mathsf{p}}}\btout{\mapt{S_2}^{\mathsf{p}}}\mapt{S}^{\mathsf{p}}
\proves 
\bout{k}{k_1}\bout{k}{k_2} \map{P'}^{\mathsf{p}} 
\hastype \Proc
$$
Now, $\mapa{\ell_1}^{\mathsf{p}} = \{ \bactout{k}{k_1 }, \bactout{k}{ k_2}\}$. 
It is immediate to infer the following typed transitions for $\map{P}^{\mathsf{p}}  = \bout{k}{k_1}\bout{k}{k_2} \map{P'}^{\mathsf{p}} $:
\begin{eqnarray*}
& & \mapt{\Gamma}^{\mathsf{p}}; 
\mapt{\Delta_0} \cat  k_1{:}\mapt{S_1}^{\mathsf{p}} \cat k_2{:}\mapt{S_2}^{\mathsf{p}} \cat
k:\btout{\mapt{S_1}^{\mathsf{p}}}\btout{\mapt{S_2}^{\mathsf{p}}}\mapt{S}^{\mathsf{p}}
\proves 
\bout{k}{k_1}\bout{k}{k_2} \map{P'}^{\mathsf{p}}  \\
& \hby{\bactout{k}{k_1}} & 
\mapt{\Gamma}^{\mathsf{p}}; \mapt{\Delta_0} \cat  k_2{:}\mapt{S_2}^{\mathsf{p}} \cat
k:\btout{\mapt{S_2}^{\mathsf{p}}}\mapt{S}^{\mathsf{p}}
\proves 
\bout{k}{k_2} \map{P'}^{\mathsf{p}} \\
& \hby{\bactout{k}{k_2}} & 
\mapt{\Gamma}^{\mathsf{p}}; \mapt{\Delta_0}  \cat k{:}\mapt{S}^{\mathsf{p}}
\proves 
 \map{P'}^{\mathsf{p}} \\
 & = & 
 \mapt{\Gamma}^{\mathsf{p}}; \mapt{\Delta_0 \cat
k:S }^{\mathsf{p}}
\proves 
 \map{P'}^{\mathsf{p}}
\end{eqnarray*}
which concludes the proof for this case.

%% Biadic Abstraction Output 
\item Case  $P = \bbout{k}{\abs{x_1, x_2} Q} P' $ and $\ell_1 = \bactout{k}{\abs{x_1, x_2}{Q}}$. 
We show that this case falls under part (a) of the thesis.
By assumption, $P$ is well-typed. 
We may have:
			\[
				\tree{
					\Gamma; \emptyset; \Delta_0 \cat k:S  \proves  P' \hastype \Proc \quad 
					\Gamma ; \emptyset ; \Delta_1 \proves  \abs{x_1,x_2}Q \hastype \lhot{(C_1,C_2)}}{
					\Gamma; \emptyset; \Delta_0 \cat \Delta_1 \cat k:\btout{\lhot{(C_1,C_2)}}S \proves  
					\bout{k}{\abs{x_1,x_2}Q} P' \hastype \Proc}
			\]
for some $\Gamma, S, C_1, C_2, \Delta_0, \Delta_1$, 
such that $\Delta = \Delta_0 \cat \Delta_1 \cat  k:\btout{\lhot{(C_1,C_2)}}S$.
(For simplicity, we consider only the case of a linear function.)
We may have the following typed transition:
$$
\stytra{\Gamma}{\ell_1}{\Delta_0 \cat \Delta_1 \cat k:\bbtout{\lhot{(C_1, C_2)}}S}{\bbout{k}{\abs{x_1, x_2} Q} P' }{\Delta_0 \cat k{:}S}{P'}
$$
The encoding of the source judgment is
$$
\mapt{\Gamma}^{\mathsf{p}}; \emptyset; \mapt{\Delta_0 \cat \Delta_1 \cat k:\bbtout{\lhot{(C_1, C_2)}}S}^{\mathsf{p}} \proves \map{\bbout{k}{\abs{x_1, x_2} Q} P' }^{\mathsf{p}} \hastype \Proc
$$
which, using Def.~\ref{d:enc:poltomon}, can be equivalently expressed as 
$$
\mapt{\Gamma}^{\mathsf{p}}; \emptyset; \mapt{\Delta_0 \cat \Delta_1} \cat
%k:\btout{\mapt{S_1}^{\mathsf{p}}}\btout{\mapt{S_2}^{\mathsf{p}}}\mapt{S}^{\mathsf{p}}
k:\bbtout{
		\lhot{\big(\btinp{\tmap{C_1}{\mathsf{p}}}\btinp{\tmap{C_2}{\mathsf{p}}}\tinact\big)}}\mapt{S}^{\mathsf{p}}
\proves 
\bbout{k}{\abs{z}\binp{z}{x_1} \binp{z}{x_2} \map{Q}^{\mathsf{p}}} \map{P'}^{\mathsf{p}}
\hastype \Proc
$$

Now, $\mapa{\ell_1}^{\mathsf{p}} = \bactout{k}{\abs{z}\binp{z}{x_1}\binp{z}{x_2} \map{Q}^{\mathsf{p}}}$. 
It is immediate to infer the following typed transition for $\map{P}^{\mathsf{p}}  = \bbout{k}{\abs{z}\binp{z}{x_1} \binp{z}{x_2} \map{Q}^{\mathsf{p}}} \map{P'}^{\mathsf{p}}$:
\begin{eqnarray*}
& & \mapt{\Gamma}^{\mathsf{p}}; \mapt{\Delta_0 \cat \Delta_1} \cat
%k:\btout{\mapt{S_1}^{\mathsf{p}}}\btout{\mapt{S_2}^{\mathsf{p}}}\mapt{S}^{\mathsf{p}}
k:\bbtout{
		\lhot{\big(\btinp{\tmap{C_1}{\mathsf{p}}}\btinp{\tmap{C_2}{\mathsf{p}}}\tinact\big)}}\mapt{S}^{\mathsf{p}}
\proves 
\bbout{k}{\abs{z}\binp{z}{x_1} \binp{z}{x_2} \map{Q}^{\mathsf{p}}} \map{P'}^{\mathsf{p}} \\
& \hby{\mapa{\ell_1}^{\mathsf{p}}} & 
\mapt{\Gamma}^{\mathsf{p}}; \mapt{\Delta_0} \cat
k:\mapt{S}^{\mathsf{p}}, \,
\proves 
\map{P'}^{\mathsf{p}} \\
 & = & 
 \mapt{\Gamma}^{\mathsf{p}}; 
 \mapt{\Delta_0 \cat k:S}^{\mathsf{p}}
\proves 
 \map{P'}^{\mathsf{p}}
\end{eqnarray*}
which concludes the proof for this case.
\end{enumerate}

\noi \textbf{Part (2)}. We consider some non-trivial cases, using biadic communication:
\begin{enumerate}[1.]

%% Biadic Input 
\item Case $P =  \binp{k}{x_1, x_2} P' $, 
$\map{P}^{\mathsf{p}} = 
		\binp{k}{x_1}  \binp{k}{x_2}  \map{P'}^{\mathsf{p}}$.
		We show that this case falls under part~(b) of the thesis (cf. Prop.~\ref{p:ocpotomo}). 		
%		and $\ell_2 = \bactinp{k}{k_1}, \bactinp{k}{k_2}$. Then w
		We have  the following typed transitions for $\map{P}^{\mathsf{p}}$, for some $S$, $S_1$, $S_2$, and $\Delta$:
\begin{eqnarray*}
& & \mapt{\Gamma}^{\mathsf{p}}; 
\mapt{\Delta}^{\mathsf{p}} \cat 
k:\btinp{\tmap{S_1}{\mathsf{p}}}\btinp{\tmap{S_2}{\mathsf{p}}}\tmap{S}{\mathsf{p}} \cat
\proves 
\binp{k}{x_1} \binp{k}{x_2}\map{P'}^{\mathsf{p}} \\
& \hby{\bactinp{k}{k_1}} & 
\mapt{\Gamma}^{\mathsf{p}}; 
\mapt{\Delta}^{\mathsf{p}} \cat 
k:\btinp{\tmap{S_2}{\mathsf{p}}}\tmap{S}{\mathsf{p}} \cat
k_1:\mapt{S_1}^{\mathsf{p}}
\proves 
\binp{k}{x_2}\map{P'}^{\mathsf{p}} \subst{k_1}{x_1} \\
& \hby{\bactinp{k}{k_2}} & 
\mapt{\Gamma}^{\mathsf{p}}; 
\mapt{\Delta}^{\mathsf{p}} \cat k:\tmap{S}{\mathsf{p}} \cat
k_1:  \mapt{S_1}^{\mathsf{p}} \cat
k_2: \mapt{S_2}^{\mathsf{p}}
\proves 
\map{P'}^{\mathsf{p}} \subst{k_1}{x_1}\subst{k_2}{x_2} = Q
\end{eqnarray*}
Observe that the substitution lemma (Lemma~\ref{lem:subst}(1)) has been used twice.
%Considering Remark~\ref{r:multilabels} 
It is then immediate to infer the label for the source transition:
$\ell_1 = \bactinp{k}{k_1,k_2}$. Indeed, $\mapa{\ell_1}^{\mathsf{p}} = \{\bactinp{k}{k_1}, \bactinp{k}{k_2}\}$.
Now, in the source term $P$ we can infer the following transition:
$$
\stytra{\Gamma}{\ell_1}{\Delta \cat k:\btinp{S_1, S_2}S}{\binp{k}{x_1, x_2} P' }{\Delta\cat k{:}S \cat k_1:S_1 \cat k_2:S_2}{P'\subst{k_1,k_2}{x_1, x_2}}
$$
We now observe that, by
letting
 $\Delta^* = \mapt{\Delta}^{\mathsf{p}}\cat k:\tmap{S}{\mathsf{p}}, \,
k_1:  \mapt{S_1}^{\mathsf{p}} \cat
k_2: \mapt{S_2}^{\mathsf{p}}$, we have the desired conclusion:
$$\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\Delta^*}{\map{P'\subst{k_1,k_2}{x_1, x_2}}^{\mathsf{p}}}{\Delta^*}{Q}$$

%% Biadic Abstraction Output 
\item Case $P =  \bbout{k}{\abs{x_1,x_2} Q} P' $, 
$\map{P}^{\mathsf{p}} = 
		\bbout{k}{\abs{z}\binp{z}{x_1}\binp{z}{x_2} \map{Q}^{\mathsf{p}}} \map{P'}^{\mathsf{p}}$.
		We show that this case falls under part~(a) of the thesis (cf. Prop.~\ref{p:ocpotomo}). 
		We have the following  typed transition, for some $S$, $C_1$, $C_2$, and $\Delta$:
\begin{eqnarray*}
& & \mapt{\Gamma}^{\mathsf{p}}; 
\mapt{\Delta}^{\mathsf{p}}\cat k:\tmap{\bbtout{\lhot{(C_1,  C_2)}} S}{\mathsf{p}}
\proves 
\bbout{k}{\abs{z}\binp{z}{x_1}\binp{z}{x_2} \map{Q}^{\mathsf{p}}} \map{P'}^{\mathsf{p}} \\
& \hby{\ell'_1} & 
\mapt{\Gamma}^{\mathsf{p}}; 
\mapt{\Delta}^{\mathsf{p}}\cat k:\tmap{ S}{\mathsf{p}} 
\proves 
\map{P'}^{\mathsf{p}} = Q
\end{eqnarray*}
where
$\ell'_1 = \bactout{k}{\abs{z}\binp{z}{x_1} \binp{z}{x_2} \map{Q}^{\mathsf{p}}}$.
For simplicity, we consider only the case of linear functions.
It is then immediate to infer the label for the source transition:
$\ell_1 = \bactout{k}{\abs{x_1,  x_2}{Q}} $. 
Now, in the source term $P$ we can infer the following transition:
$$
\stytra{\Gamma}{\ell_1}{\Delta\cat k:\bbtout{\lhot{(C_1,  C_2)}} S}{ \bbout{k}{\abs{x_1,x_2} Q} P'}{\Delta\cat k{:}S}{P'}
$$
Then we have the desired conclusion:
$$\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\mapt{\Delta\cat k:S}^{\mathsf{p}}}{\map{P'}^{\mathsf{p}}}{\mapt{\Delta\cat k:S}^{\mathsf{p}}}{Q}$$


%% Biadic Abstraction Input 
\item Case $P =  \binp{k}{X} P' $, 
$\map{P}^{\mathsf{p}} = 
		\binp{k}{X} \map{P'}^{\mathsf{p}}$.
		We show that this case also falls under part~(a) of the thesis (cf. Prop.~\ref{p:ocpotomo}). 
We have  the following typed transition, for some $S$, $C_1$, $C_2$, and $\Delta$:
\begin{eqnarray*}
& & \mapt{\Gamma}^{\mathsf{p}}; 
\mapt{\Delta}^{\mathsf{p}}\cat k:\tmap{\bbtinp{\shot{(C_1,  C_2)}} S}{\mathsf{p}}
\proves 
\binp{k}{X} \map{P'}^{\mathsf{p}} \\
& \hby{\ell'_1} & 
\mapt{\Gamma}^{\mathsf{p}}; 
\mapt{\Delta}^{\mathsf{p}}\cat k:\tmap{ S}{\mathsf{p}} 
\proves 
\map{P'}^{\mathsf{p}}\subst{\abs{z}\binp{z}{x_1} \binp{z}{x_2} \map{Q}^{\mathsf{p}}}{X} = Q
\end{eqnarray*}
where 
 $\ell'_1 = \bactinp{k}{\abs{z}\binp{z}{x_1} \binp{z}{x_2} \map{Q}^{\mathsf{p}}} $. 
For simplicity, we consider only the case of shared functions.
It is then immediate to infer the label for the source transition:
$\ell_1 = \bactinp{k}{\abs{x_1,  x_2}{Q}} $. 
Now, in the source term $P$ we can infer the following transition:
$$
\stytra{\Gamma}{\ell_1}{\Delta\cat k:\bbtinp{\shot{(C_1, C_2)}} S}{ \binp{k}{X} P'}{\Delta\cat k{:}S}{P'\subst{\abs{x_1,  x_2}{Q}}{X}}
$$
Then we have the desired conclusion:
$$\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\mapt{\Delta\cat k:S}^{\mathsf{p}}}{\map{P'\subst{\abs{x_1,  x_2}{Q}}{X}}^{\mathsf{p}}}{\mapt{\Delta\cat k:S}^{\mathsf{p}}}{Q}$$
We omit the (easy) conductive argument supporting the last claim,
which uses Prop.~\ref{p:poltomo}.
We content ourselves with noticing that the key difference between 
${\map{P'\subst{\abs{x_1,  x_2}{Q}}{X}}^{\mathsf{p}}}$
and $Q$ consists in the $\tau$-transitions present in $Q$  and absent in ${\map{P'\subst{\abs{x_1,  x_2}{Q}}{X}}^{\mathsf{p}}}$, which are induced   by the monadic representation of polyadic communication.
\end{enumerate}
\qed
\end{proof}

\begin{conjecture}[Full Abstraction: Polyadic / Monadic Communication]
\begin{enumerate}[a)]
\item
If
$\wbb{ \Gamma}{\ell}{\Delta_1}{ P }{ \Delta_2}{Q}$
then
$\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\mapt{\Delta_1}^{\mathsf{p}}}{\map{P}^{\mathsf{p}}}{\mapt{\Delta_2}^{\mathsf{p}}}
{\map{Q}^{\mathsf{p}}}$.
\item  
If 
$\wbb{\mapt{\Gamma}^{\mathsf{p}}}{\ell}{\mapt{\Delta_1}^{\mathsf{p}}}{\map{P}^{\mathsf{p}}}{\mapt{\Delta_2}^{\mathsf{p}}}
{\map{Q}^{\mathsf{p}}}$
then 
$\wbb{ \Gamma}{\ell}{\Delta_1}{ P }{ \Delta_2}{Q}$.
\end{enumerate}
While (a) is  completeness (non trivial), (b) is soundness  (easy in principle).
\end{conjecture}

In the light of the tight operational correspondence for the polyadic/monadic encoding,
in the following we restrict to consider monadic communications.

\subsection{Encoding $\sessp^{-\mu}$  into \HO}\label{ss:ffotoho}

We now show that the subcalculus $\HO$ is expressive enough to
represent the $\sessp$ calculus, i.e., a standard  session calculus with first-order communication.


The name passing semantics of $\sessp$ have a rather straightforward
encoding from to $\HO$.
On the other hand to achieve the encoding of the recursion semantic
of $\sessp$, we need to extend
to the polyadic version of $\sessp$ as an intermediate step in order
to give a sound encoding of the recursion semantics to $\HO$.

We first encode the name passing semantics.
%Below, we use $n$ to stand for either a linear channel $k'$ or a shared name $a$.

\begin{definition}[Finite First-Order into Higher-Order]\label{d:enc:fotoho}
   Let  $\enco{\map{\cdot}^{1}, \mapt{\cdot}^{1}, \mapa{\cdot}^{1}}: \sessp^{-\mu} \to \HO$ be a typed encoding where
%	Define $\encod{\cdot}{\cdot}{1}: \sessp^{-\mu} \to \HO$  as follows:
\begin{figure}[t]
	\[
	\begin{array}{rcl}
		\pmap{\bout{k}{k'} P}{1}		&\defeq&	\bbout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{k'}} } \pmap{P}{1} \\
		\pmap{\binp{k}{x} Q}{1}			&\defeq&	\binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{Q}{1}}} \inact} \\
		\tmap{\btout{T} {S} }{1}		&\defeq&	\btout{\lhot{\btinp{\lhot{\tmap{T}{1}}}\tinact}} \tmap{S}{1}  \\
		\tmap{\btinp{T} S }{1}		&\defeq&	\btinp{\lhot{\btinp{\lhot{\tmap{T}{1}}}\tinact}} \tmap{S}{1} \\
		\tmap{\bbtout{\chtype{T}}{S}}{1}	&\defeq&	\btout{\shot{\btinp{\shot{\chtype{\tmap{T}{1}}}}\tinact}} \tmap{S}{1}  \\
		\tmap{\bbtinp{\chtype{T}}{S}}{1}	&\defeq&	\btinp{\shot{\btinp{\shot{\chtype{\tmap{T}{1}}}}\tinact}} \tmap{S}{1}  \\
		\mapa{\bactout{k}{k_1}}^{1} &\defeq&   \bactout{k}{\abs{z}{\,\binp{z}{X} \appl{X}{k_1}}\, } \\
		\mapa{\bactinp{k}{k_1}}^{1} &\defeq&   \bactinp{k}{\abs{z}{\,\binp{z}{X} \appl{X}{k_1}}\, }
	\end{array}
	\]
	\caption{\label{f:enc:fotoho}
Typed encoding of first-order communication into higher-order communication (cf.~Defintion~\ref{d:enc:fotoho}).
Mappings 
$\map{\cdot}^1$,
$\mapt{\cdot}^1$, 
and 
$\mapa{\cdot}^1$
are homomorphisms for the other processes/types/labels. 
}
\end{figure}
mappings $\map{\cdot}^{1}$, $\mapt{\cdot}^{1}$, $\mapa{\cdot}^{1}$
%are homomorphisms for the other processes/types/labels. 
are 
as in Fig.~\ref{f:enc:fotoho}.
\end{definition}

In the higher-order setting, a name $k$ is being passed as an input
guarded abstraction. The input prefix receives an abstraction and
continues with the application of $k$ over the received abstraction.
On the reception side $\binp{s}{x} P$ 
the encoding develops a mechanism that will receive
the input guarded abstraction, apply it on a fresh endpoint $s$ and use
the dual endpoint $\dual{s}$ to send the continuation $P$ as the abstraction
$\abs{x}{P}$. Name substitution is then achieved as application.

\begin{proposition}[Type Preservation, First-Order into Higher-Order]\label{prop:typepres1}
Let $P$ be a  $\sessp^{-\mu}$ process.
If			$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then 
			$\mapt{\Gamma}^{1}; \emptyset; \mapt{\Delta}^{1} \proves \map{P}^{1} \hastype \Proc$. 
\end{proposition}

\begin{proof}
By induction on the inference $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$. Details in \S\,\ref{app:enc_sesspnr_to_ho} (Page~\pageref{app:enc_sesspnr_to_ho}).
	\qed
\end{proof}

\begin{proposition}[Operational Correspondence, First-Order into Higher-Order]
\label{p:opcorrfho}
Let $P$ be a  $\sessp^{-\mu}$ process.
If $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then
		\begin{enumerate}[1.]
			\item	 
			   If  $\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$
			   then  $\exists \ell_2$ s.t. \\
			    $\wtytra{\mapt{\Gamma}^{1}}{\ell_2}{\mapt{\Delta}^{1}}{\map{P}^{1}}{\mapt{\Delta'}^{1}}{\map{P'}^{1}}$
			    and $\ell_2 = \mapa{\ell_1}^{1}$.
			\item   
			If  $\wtytra{\mapt{\Gamma}^{1}}{\ell_2}{\mapt{\Delta}^{1}}{\map{P}^{1}}{\mapt{\Delta'}^{1}}{Q}$
			   then $\exists \ell_1, P'$ s.t.  \\
			    (i)~$\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$,
			    (ii)~$\ell_2 = \mapa{\ell_1}^{1}$, 
			    (iii)~$\wbb{\mapt{\Gamma}^{1}}{\ell}{\mapt{\Delta'}^{1}}{\map{P'}^{1}}{\mapt{\Delta'}^{1}}{Q}$.
			    \end{enumerate}
\end{proposition}

\begin{proof}
By transition induction. We consider parts (1) and (2) separately: \\
\noi \textbf{Part (1)}. We consider the two most interesting cases, the rest is similar or simpler:
\begin{enumerate}[1.]
%%  Output 
\item Case  $P =\bout{k}{k_1} P'$ and $\ell_1 = \bactout{k}{k_1}$. By assumption, $P$ is well-typed. 
We may have:
			\[
				\tree{
					\Gamma; \emptyset; \Delta_0 \cat k:S  \proves  P' \hastype \Proc \quad 
					\Gamma ; \emptyset ; \{k_1{:} T\}  \proves   k_1 \hastype T }{
					\Gamma; \emptyset; \Delta_0 \cat k_1{:}T \cat k:\btout{T}S \proves \bout{k}{k_1} P' \hastype \Proc}
			\]
for some $\Gamma, S, T, \Delta_0$, 
such that $\Delta = \Delta_0 \cat k_1{:}T  \cat k:\btout{T}S$.
We may then have the following transition:
$$
\stytra{\Gamma}{\ell_1}{\Delta_0 \cat k_1{:}T  \cat k:\btout{T}S}{\bout{k}{k_1} P'}{\Delta_0 \cat k{:}S }{P'}
$$
The encoding of the source judgment for $P$ is as follows:
$$
\mapt{\Gamma}^{1}; \emptyset; \mapt{\Delta_0 \cat k_1{:}T  \cat k:\btout{T}S}^{1} \proves \map{\bout{k}{k_1} P'}^{1} \hastype \Proc
$$
which, using Def.~\ref{d:enc:fotoho} can be expressed as 
$$
\mapt{\Gamma}^{\mathsf{p}}; \emptyset; \mapt{\Delta_0} 
\cat k_1{:}\mapt{T}^{1} 
\cat k: \btout{\lhot{\btinp{\lhot{\tmap{T}{1}}}\tinact}} \tmap{S}{1}
\proves 
\bbout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{k_1}} } \pmap{P}{1}
\hastype \Proc
$$
Now, $\mapa{\ell_1}^{1} = \bactout{k}{\abs{z}{\,\binp{z}{X} \appl{X}{k_1}}\, } $. 
We may infer the following typed transition for $\map{P}^{1}$:
\begin{eqnarray*}
& & \mapt{\Gamma}^{1}; \emptyset; \mapt{\Delta}^{1} 
\proves 
\bbout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{k_1}} } \pmap{P}{1}
\hastype \Proc \\
& \hby{\mapa{\ell_1}^{1}} & \mapt{\Gamma}^{1}; \emptyset; \mapt{\Delta_0}^{1} 
\cat k:  \tmap{S}{1}
\proves  \pmap{P}{1}
\hastype \Proc \\
& = & \mapt{\Gamma}^{1}; \emptyset; \mapt{\Delta_0 \cat k:  S}^{1}
\proves  \pmap{P}{1}
\hastype \Proc 
\end{eqnarray*}
from which the thesis follows easily.

\item Case $P = \binp{k}{x} Q$	and $\ell_1 = \bactinp{k}{k_1}$.
By assumption $P$ is well-typed.
We may have:
			\[
				\tree{
					\Gamma; \emptyset; \Delta_0 \cat x{:} T \cat k:S  \proves  Q \hastype \Proc \quad 
					\Gamma ; \emptyset ; \{x{:} T\}  \proves   x\hastype T }{
					\Gamma; \emptyset; \Delta_0 \cat   k:\btinp{T}S \proves \binp{k}{x} Q \hastype \Proc}
			\]
for some $\Gamma, S, T, \Delta_0$, 
such that $\Delta = \Delta_0 \cat k:\btinp{T}S$.
We may infer the following typed transition
$$
\Gamma; \emptyset; \Delta_0 \cat   k:\btinp{T}S \proves \binp{k}{x} Q \hastype \Proc
\hby{\bactinp{k}{k_1}}
\Gamma; \emptyset; \Delta_0 \cat   k:S \cat k_1:T \proves   Q\subst{k_1}{x} \hastype \Proc
$$
The encoding of the source judgment for $P$ is as follows:
\begin{eqnarray*}
& & \mapt{\Gamma}^{1}; \emptyset; \mapt{ \Delta_0 \cat   k:\btinp{T}S }^{1} \proves 
\map{P}^{1}
\hastype \Proc \\
& = & \mapt{\Gamma}^{1}; \emptyset; \mapt{ \Delta_0 }^{1} \cat   k: \btinp{\lhot{\btinp{\lhot{\tmap{T}{1}}}\tinact}} \tmap{S}{1} \proves 
\binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{Q}{1}}} \inact}
\hastype \Proc
\end{eqnarray*}
Now, 
 $\mapa{\ell_1}^{1} = 
\bactinp{k}{\abs{z}{\,\binp{z}{X} \appl{X}{k_1}}\, }
$
and is immediate to infer the following 
transition for $\map{P}^{1}$:
\begin{eqnarray*}
&  & \mapt{\Gamma}^{1}; \emptyset; \mapt{ \Delta_0 }^{1} \cat   k: \btinp{\lhot{\btinp{\lhot{\tmap{T}{1}}}\tinact}} \tmap{S}{1} \proves 
\binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{Q}{1}}} \inact}
\hastype \Proc \\
& \hby{\mapa{\ell_1}^{1}}  & \mapt{\Gamma}^{1}; \emptyset; \mapt{ \Delta_0 }^{1} \cat   
k:  \tmap{S}{1} \cat k_1:  \tmap{T}{1} \proves 
 \newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{Q}{1}}} \inact}\subst{\abs{z}{\,\binp{z}{X} \appl{X}{k_1}}}{X}
\hastype \Proc 
\end{eqnarray*}
Let us write $R$ to stand for $\newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{Q}{1}}} \inact}\subst{\abs{z}{\,\binp{z}{X} \appl{X}{k_1}}}{X}$.
At this point it is not difficult to infer the 
desired conclusion, using conductive arguments:
$$\wbb{\mapt{\Gamma}^{1}}{\ell}{\mapt{\Delta\cat k:S \cat k_1:T}^{\mathsf{p}}}{\map{Q\subst{k_1}{x}}^{1}}{\mapt{\Delta\cat k:S \cat k_1:T}^{\mathsf{p}}}{R}$$
\end{enumerate}

\noi \textbf{Part (2)}. We consider two non-trivial cases, the rest is similar or simpler:
\begin{enumerate}[1.]
%%%%%%%%%%%
%%  Output 
%%%%%%%%%%%
\item Case $P = \bout{k}{k'} P'$.
%,  $\map{P}^{1} = \bbout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{k'}} } \pmap{P'}{1}$.
Then 
we have: % the following typed transition for $\map{P}^{1}$:
$$
\mapt{\Gamma}^{1};\, \emptyset;\, \mapt{\Delta_0}^{1} \cat 
k: \btout{\lhot{\btinp{\lhot{\tmap{T}{1}}}\tinact}} \tmap{S}{1} 
\proves 
 \bbout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{k'}} } \pmap{P'}{1} 
 \hastype \Proc
$$
for some $T, S$, and $\Delta_0$. 
We may infer the following typed transition for $\pmap{P}{1}$:
\begin{eqnarray*}
& & \mapt{\Gamma}^{1};\, \mapt{\Delta_0}^{1} \cat k: \btout{\lhot{\btinp{\lhot{\tmap{T}{1}}}\tinact}} \tmap{S}{1} 
\proves 
 \bbout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{k'}} } \pmap{P'}{1} 
 \\
%& & \bbout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{k'}} } \pmap{P'}{1} \hby{\bactout{k}{\abs{z}{\,\binp{z}{X} \appl{X}{k'}}}} \pmap{P'}{1}  \\
&\hby{\ell_2}& 
\mapt{\Gamma}^{1};\, \mapt{\Delta_0}^{1} \cat k: \tmap{S}{1} 
\proves  \pmap{P'}{1} 
\end{eqnarray*}
with $\ell_2 = \bactout{k}{\abs{z}{\,\binp{z}{X} \appl{X}{k'}}}$.
Now, in the source term $P$ we can infer the following transition 
$$
\Gamma;\,  \Delta_0 \cat k:\btout{T} S \proves \bout{k}{k'} P'
 \hby{\bactout{k}{k'}} 
 \Gamma;\,  \Delta_0 \cat k: S \proves P'
$$
and thus the thesis follows easily by noticing that 
$\mapa{\bactout{k}{k'}}^{1} = \bactout{k}{\abs{z}{\,\binp{z}{X} \appl{X}{k'}}}$.


%%%%%%%%%%%
%% Input
%%%%%%%%%%%
\item Case $P = \binp{k}{x} Q$.
Then we have
$$
\mapt{\Gamma}^{1};\, \emptyset;\, \mapt{\Delta_0}^{1} \cat 
k: \btinp{\lhot{\btinp{\lhot{\tmap{T}{1}}}\tinact}} \tmap{S}{1}
\proves
 \binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{Q}{1}}} \inact}
 \hastype \Proc
 $$
for some $T$, $S$, $\Delta_0$.
We may infer the following typed transitions for $\pmap{P}{1}$:
\begin{eqnarray*}
& & 
\mapt{\Gamma}^{1};\, %\emptyset;\, 
\mapt{\Delta_0}^{1} \cat 
k: \btinp{\lhot{\btinp{\lhot{\tmap{T}{1}}}\tinact}} \tmap{S}{1}
\proves
 \binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{Q}{1}}} \inact} \\
 & \hby{\ell_2} & 
\mapt{\Gamma}^{1};\, %\emptyset;\, 
\mapt{\Delta_0}^{1} \cat 
k:\tmap{S}{1}
\cat k_1:\tmap{T}{1}
\proves
  \newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{Q}{1}}} \inact} \subst{\abs{z}\binp{z}{X}\appl{X}{k_1}}{X} \\
 & = & 
\mapt{\Gamma}^{1};\, %\emptyset;\, 
\mapt{\Delta_0}^{1} 
\cat k:\tmap{S}{1}
\cat k_1:\tmap{T}{1}
\proves
  \newsp{s}{\binp{s}{X}\appl{X}{k_1} \Par \bbout{\dual{s}}{\abs{x}{\pmap{Q}{1}}} \inact}  \\
 & \hby{\tau} & 
\mapt{\Gamma}^{1};\, %\emptyset;\, 
\mapt{\Delta_0}^{1} 
\cat k:\tmap{S}{1}
\cat k_1:\tmap{T}{1}
\proves
 \pmap{Q}{1}\subst{k_1}{x}   
  \end{eqnarray*} 
with $\ell_2 = \bactinp{k}{\abs{z}{\,\binp{z}{X} \appl{X}{k_1}}}$.
Now, in the source term $P$ we can infer the following transition 
$$
\Gamma;\,  \Delta_0 \cat k:\btinp{T} S \proves \binp{k}{x} P'
 \hby{\bactinp{k}{k_1}} 
 \Gamma;\,  \Delta_0 \cat k: S \cat k_1: T \proves P'\subst{k_1}{x}
$$
and the thesis follows easily by noticing that 
$\mapa{\bactinp{k}{k_1}}^{1} = \bactinp{k}{\abs{z}{\,\binp{z}{X} \appl{X}{k_1}}}$.

\end{enumerate}
\qed
\end{proof}

%\begin{conjecture}[Full Abstraction]
%\begin{enumerate}[a)]
%\item
%If
%$\wbb{ \Gamma}{\ell}{\Delta_1}{ P }{ \Delta_2}{Q}$
%then
%$\wbb{\mapt{\Gamma}^{1}}{\ell}{\mapt{\Delta_1}^{1}}{\map{P}^{1}}{\mapt{\Delta_2}^{1}}
%{\map{Q}^{1}}$.
%\item  
%If 
%$\wbb{\mapt{\Gamma}^{1}}{\ell}{\mapt{\Delta_1}^{1}}{\map{P}^{1}}{\mapt{\Delta_2}^{1}}
%{\map{Q}^{1}}$
%then 
%$\wbb{ \Gamma}{\ell}{\Delta_1}{ P }{ \Delta_2}{Q}$.
%\end{enumerate}
%While (a) is  completeness, (b) is soundness.
%
%\end{conjecture}

\begin{comment}
\begin{proof}[Sketch]
	We must show completeness and soundness properties. 
	For completeness, it suffices to consider source process
	$P_0 = \bout{k}{k'} P \Par \binp{k}{x} Q$. We have that
%
	\[
		P_0 \red P \Par Q\subst{k'}{x}.
	\]
%
	By the definition of encoding we have:
	\begin{eqnarray*}
		\pmap{P_0}{1} & = & \bbout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{k'}} } \pmap{P}{1} \Par \binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact}  \\
		& \red & \pmap{P}{1} \Par \newsp{s}{\appl{X}{s} \subst{\abs{z}{\,\binp{z}{X} \appl{X}{k'}}}{X} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact} \\
		& = & \pmap{P}{1} \Par \newsp{s}{\,\binp{s}{X} \appl{X}{k'} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact} \\
		& \red & \pmap{P}{1} \Par \appl{X}{k'} \subst{\abs{x} \pmap{Q}{1}}{X} \Par \inact \\
		& \scong & \pmap{P}{1} \Par \pmap{Q}{1}\subst{k'}{x}  
	\end{eqnarray*}
	For soundness, it suffices to notice that the encoding does not add new visible actions:
	the additional synchronizations induced by the encoding always occur on private (fresh) names.
	We assume weak bisimilarities, which abstract from internal actions used by the encoding,
	and so  constructing a relation witnessing behavioral equivalence is easy.
	\qed
\end{proof}
\end{comment}

%\subsection{Polyadic Into Monadic}
%The encoding from $\psesp$ to $\sesp$ is easier than the
%encoding of polyadic $\pi$-calculus in the $\pi$-calculus because
%we have linear session endpoints.
%
%\begin{definition}[$\psesp$ to $\sesp$]
%	We write $\encod{\cdot}{\cdot}{2}:\psesp \to \sesp$ whenever
%
%	\begin{tabular}{c}
%			$\map{\bout{k}{k'_1, \cdots, k'_n} P}^{2} \defeq \bout{k}{k'_1} \cdots ;  \bout{k}{k'_n}
%			\pmap{P}{2}$\\
%			$\map{\binp{k}{x_1, \cdots, x_n} P}^{2} \defeq \binp{k}{x_1} \cdots ; \binp{k}{x_n}  \pmap{P}{2}$ \\
%			$\tmap{\btout{S_1, \cdots, S_n} S}{2} \defeq \bbtout{\tmap{S_1}{2}} \cdots; \bbtout{\tmap{S_n}{2}} \tmap{S}{2}$\\
%			$\tmap{\btinp{S_1, \cdots, S_n} S}{2} \defeq \bbtinp{\tmap{S_1}{2}} \cdots; \bbtinp{\tmap{S_n}{2}} \tmap{S}{2}$
%%		\end{tabular}
%%		& \quad &
%%		\begin{tabular}{l}
%%			$\tmap{\btout{S_1 \cat \tilde{S}} S}{2} \defeq \btout{S_1} \tmap{\btout{\tilde{S}} S}{2}$\\
%%			$\tmap{\btinp{S_1 \cat \tilde{S}} S}{2} \defeq \btinp{S_1} \tmap{\btinp{\tilde{S}} S}{2}$
%%		\end{tabular}
%	\end{tabular}
%\end{definition}
%
%Polyadic name sending (resp.\ receive) is encoded as sequence of
%send (resp.\ receive) operations. Linearity of session endpoints
%ensures no race conditions, thus the encoding is sound.
%
%The encoding of the polyadic $\sesp$ semantics is as simple as the
%composition of the two former encodings.
%
%\begin{definition}[Encoding from $\psespnr$ to $\HO$]
%	We define $\encod{\cdot}{\cdot}{3}: \psespnr \longrightarrow \HO$
%	as $\encod{\cdot}{\cdot}{3} = \encod{\cdot}{\cdot}{1} \cat \encod{\cdot}{\cdot}{2}$.	
%\end{definition}

%So far we have consider name abstractions and applications which are \emph{monadic}.
%We now consider the \emph{polyadic} extension of these constructs, %name abstractions and applications.
%written $\abs{x_1, \ldots, x_n} P$ and $\appl{X}{k_1, \ldots, k_n}$, respectively.
%Next we give the encoding from $\HOp$ with polyadic name abstraction to $\HOp^{p}$.
%
%\begin{definition}[Encoding from $\pHOpnr$ to $\pHOp$]
%
%	\begin{tabular}{lcl}
%		$\map{\bout{k}{\abs{\tilde{x}} P_1} P_2}^4$ &$\defeq$& $\bout{k}{\abs{z} \binp{z}{\tilde{x}} \map{P_1}^4} \map{P_2}^4$\\
%		$\map{\appl{X}{\tilde{k}}}$ &$\defeq$& $\newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\tilde{k}} \inact}$
%	\end{tabular}
%\end{definition}

%We compose the latter encoding with the generalisation $\map{\cdot}^3 : \HOp^{p-\mu} \longrightarrow \HO$
%of the encoding $\map{\cdot}^3 : \sesp^{p-\mu} \longrightarrow \HO$ to get a translation
%of $\HOp^{pa-\mu}$ to $\HO$.
%
%\begin{definition}[Encoding from $\HOp^{pa-\mu}$ to $\HO$]
%	We define $\encod{\cdot}{\cdot}{5}: \HOp^{pa-\mu} \longrightarrow \HO$
%	as $\encod{\cdot}{\cdot}{5} = \encod{\cdot}{\cdot}{4} \cat \encod{\cdot}{\cdot}{3}$.	
%\end{definition}




\subsection{Encoding Recursion into Abstraction Passing}\label{ss:fullfotoho}

Encoding the constructs for recursion present in $\sessp$ as process-passing
communication requires to follow the fundamental
principle of copying the process that needs to exhibit recursive behaviour.
The primitive recursor operation creates copies of a process and uses them
as continuations.

We use an example to demostrate our basic intuitions:
%
\begin{example}
	Assume process $P = \recp{X}{\bout{n}{m} \rvar{X}}$. We have
%
	\begin{eqnarray}
		\label{ex:rec1}
		P \scong \bout{n}{m} \recp{X}{\bout{n}{m} \rvar{X}} 
	\end{eqnarray}
%
	\noi The above process emits to its environment infinitely many send actions of channel $m$ along channel $n$.
	Name $n$ includes the recursive
	variable $\rvar{X}$, so the type for $n$ should be recursive.
%
	\[
		\recp{X}{\bout{n}{m} \rvar{X}} \by{\bactout{n}{m}} \recp{X}{\bout{n}{m} \rvar{X}}
	\]
%
	To get a better understanding of how name $n$ is handled
	on such scenarios, consider the process:
	\[
		P \scong \newsp{a}{\bout{a}{n} \inact \Par \recp{X}{\binp{a}{x} \bout{x}{m} (\bout{a}{x} \inact \Par \rvar{X})}}
		%\red \newsp{a}{\bout{n}{m} (\bout{a}{n} \inact \Par \recp{X}{\binp{a}{x} \bout{x}{m} (\bout{a}{x} \inact \Par \rvar{X}))}}
	\]
%
	\noi The above process exhibits the same behaviour as
	process~\ref{ex:rec1}.
	Endpoint $n$ is being passed sequentially on copies of the 
	same process to achieve the effect of infinite sending of value $m$.
%
	\begin{eqnarray*}
		P	&\scong&	\newsp{a}{\bout{a}{n} \inact \Par \recp{X}{\binp{a}{x} \bout{x}{m} (\bout{a}{x} \inact \Par \rvar{X})}}\\
			&\red&		\newsp{a}{\bout{n}{m} (\bout{a}{n} \inact \Par \recp{X}{\binp{a}{x} \bout{x}{m} (\bout{a}{x} \inact \Par \rvar{X}))}}\\
			&\by{\bactout{n}{m}}& \newsp{a}{\bout{a}{n} \inact \Par \recp{X}{\binp{a}{x} \bout{x}{m} (\bout{a}{x} \inact \Par \rvar{X})}}\\
			&\scong&	P
	\end{eqnarray*}
%
	\noi If we want to apply the same principles on higher order semantics we should first
	abstract the recursive process:
%
	\[
		\recp{X}{\binp{a}{x} \bout{x}{m} ( \rvar{X} \Par \bout{a}{x} \inact)}
	\]
%
	\noi as
%
	\[
		V \scong (z) \bout{n}{m} \binp{z}{X} \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\abs{z}{\appl{X}{z}}} \inact}
	\]
%
	So the entire process can be written as:
	\[
		P \scong \newsp{s_1}{\bout{s_1}{V} \inact \Par \binp{\dual{s_1}}{X} \newsp{s_2}{\appl{X}{s_2} \Par \bout{\dual{s_2}}{\abs{z}{\appl{X}{z}}} \inact}}	
	\]
%
	\noi where abstraction $V$ is copied and passed to itself
	infinitely many times:
	\[
		\begin{array}{rcl}
			P &\scong& \newsp{s_1}{\bout{s_1}{V} \inact \Par \binp{\dual{s_1}}{X} \newsp{s_2}{\appl{X}{s_2} \Par \bout{\dual{s_2}}{\abs{z}{\appl{X}{z}}} \inact}} \\
			&\red&
			\newsp{s_2}{\bout{\dual{s_2}}{V} \inact \Par \bout{n}{m} \binp{s_2}{X} \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{{z}{\appl{X}{z}} \inact}}}\\
			&\by{\bactout{n}{m}}&
			\newsp{s_2}{\bout{\dual{s_2}}{V} \inact \Par \binp{s_2}{X} \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\abs{z}{\appl{X}{z}} \inact}}}\\
			&\scong_\alpha&
			P
		\end{array}
	\]
%

	\noi In the typing setting, abstraction $V$ has a linear type:
	\[
		m: U; \es; n: \btout{U} S_1 \tinact \proves
		(z) \bout{n}{m} \binp{z}{X} \newsp{s_2}{\appl{X}{s_2} \Par \bout{\dual{s_2}}{\abs{z{\appl{X}{z}} } \inact} \hastype
		\lhot{S_2}
	\]
	because of the free occurence of session channel $n$ in $V$,
	i.e.\ we cannot apply typing rule $\trule{Prom}$ to the latter
	judgement.

	\noi But when passed, abstraction $V$ is applied in a shared manner, i.e.\ two
	copies of the abstraction are instantiated, thus the whole
	encoding is untypable: 
	\[
		\Gamma; X: \lhot{S_2}; \es \not\proves \newsp{s_2}{\appl{X}{s_2} \Par \bout{\dual{s_2}}{\abs{z} \appl{X}{z}}} \inact}
	\]
%
	\noi The untypability problem would not exist
	provided that the abstraction being passed were not linear.

	\noi A typable solution of the above example would be first to
	define a shared abstraction by replacing the free
	occurence of session name $n$ with an abstraction variable:
%
	\[
		V' = (z, x) \bout{x}{m} \binp{z}{X} \newsp{s}{\appl{X}{s, x} \Par \bout{\dual{s}}{\abs{z, x}{\appl{X}{z, x}} } \inact}
	\]
%
	Abstraction $V'$ can be typed using a shared type:
	\[
		\tree{
			m: U_1; \es; \es \proves
			(z, x) \bout{x}{m} \binp{z}{X} \newsp{s}{\appl{X}{s, x} \Par \bout{\dual{s}}{\abs{z, x}{\appl{X}{z, x}} } \inact}
			\hastype \lhot{U_2}
		}{
			m: U_1; \es; \es \proves
			(z, x) \bout{x}{m} \binp{z}{X} \newsp{s}{\appl{X}{s, x} \Par \bout{\dual{s}}{\abs{z, x}{\appl{X}{z, x}} } \inact}
			\hastype \shot{U_2}
		}~~\trule{Prom}
	\]
%
	\noi and the definition and behaviour of the recursive process, becomes:
%
	\begin{eqnarray*}
		P' &\scong&	\newsp{s_1}{\bout{s_1}{V} \inact \Par \binp{\dual{s_1}}{X} \newsp{s_2}{\appl{X}{s_2, n} \Par \bout{\dual{s_2}}{\abs{z,x}{\appl{X}{z,x}}} \inact}}\\
		&\red&		\newsp{s_2}{\bout{\dual{s_2}}{V} \inact \Par \bout{n}{m} \binp{s_2}{X} \newsp{s}{\appl{X}{s, n} \Par \bout{\dual{s}}{\abs{z, x}{\appl{X}{z, x}}} \inact}}\\
		&\by{\bactout{n}{m}}& \newsp{s_2}{\bout{\dual{s_2}}{V} \inact \Par \binp{s_2}{X} \newsp{s}{\appl{X}{s, n} \Par \bout{\dual{s}}{\abs{z, x}{\appl{X}{z, x}}} \inact}}\\
		&\scong_\alpha& P'
	\end{eqnarray*}
%
	\noi Session channel $n$ is passed and applied
	together with the recursive process.
\end{example}

A preliminary tool to encode the $\sessp$ recursion primitives would be to
provide a mapping from processes to processes with no free names.
We require some auxiliary definitions.
%
\begin{definition}\rm 
	Let $\vmap{\cdot}: 2^{\mathcal{N}} \longrightarrow \mathcal{V}^\omega$
	be a map of sequences names to sequences of variables, defined
	inductively as follows:
%
\[
	\vmap{n} = x_n \qquad \qquad \qquad \vmap{n \cat \tilde{m}} = x_n \cat \vmap{\tilde{m}}
\]
\end{definition}

Given a process $P$, we write $\ofn{P}$ to denote the
\emph{sequence} of free names of $P$, lexicographically ordered.
Intuitively, the following mapping transforms processes
with free session names into abstractions:
%
\begin{definition}\label{d:trabs}\label{d:auxmap}
	Let $\sigma$ be a set of session names.
	Define $\auxmapp{\cdot}{\mathsf{v}}{\sigma}: \HOp \to \HOp$  as in Fig.~\ref{f:auxmap}.
%
\begin{figure}[t]
\[
	\begin{array}{rcl}
		\auxmapp{\news{n} P}{\sigma}{\mathsf{v}} &\bnfis& \news{n} \auxmapp{P}{\mathsf{v}}{{\sigma \cat n}}
		\vspace{1mm} \\

%		\auxmapp{\bout{n}{\abs{x}{Q}} P}{\mathsf{v}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\bout{x_n}{\abs{x,\vmap{\ofn{P}}}{\auxmapp{Q}{\mathsf{v}}{\sigma}}} \auxmapp{P}{\mathsf{v}}{\sigma} & n \notin \sigma\\
%			\bout{n}{\abs{x,\vmap{\ofn{P}}}{\auxmapp{Q}{\mathsf{v}}{\sigma}}} \auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma
%		\end{array}
%		\right.

		\auxmapp{\bout{n}{\abs{x}{Q}} P}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\bout{x_n}{\abs{x}{\auxmapp{Q}{\mathsf{v}}{\sigma}}} \auxmapp{P}{\mathsf{v}}{\sigma} & n \notin \sigma\\
			\bout{n}{\abs{x}{\auxmapp{Q}{\mathsf{v}}{\sigma}}} \auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma
		\end{array}
		\right.
		\vspace{1mm}	\\ 

%		\auxmapp{\bout{n}{m} P}{\mathsf{v}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%		    \bout{n}{m}\auxmapp{P}{\mathsf{v}}{\sigma} & n, m \in \sigma \\
%		    \bout{x_n}{m}\auxmapp{P}{\mathsf{v}}{\sigma} & n \not\in \sigma, m \in \sigma \\
%		    \bout{n}{x_m}\auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma, m \not\in \sigma \\
%		    \bout{x_n}{x_m}\auxmapp{P}{\mathsf{v}}{\sigma} & n, m \not\in \sigma 
%		\end{array}
%		\right.
%		\vspace{1mm} \\ 

		\auxmapp{\binp{n}{X} P}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\binp{x_n}{X} \auxmapp{P}{\mathsf{v}}{\sigma} & n \notin \sigma\\
			\binp{n}{X} \auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma
		\end{array}
		\right.
		\vspace{1mm}	\\ 
%		\auxmapp{\binp{n}{x}P}{\mathsf{v}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%		    \binp{n}{x}\auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma \\
%		    \binp{x_n}{x}\auxmapp{P}{\mathsf{v}}{\sigma} & n \not\in \sigma 
%		\end{array}
%		\right.
%		\vspace{1mm} \\ 
		\auxmapp{\bsel{n}{l} P}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\bsel{x_n}{l} \auxmapp{P}{\mathsf{v}}{\sigma} & n \notin \sigma\\
			\bsel{n}{l} \auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma
		\end{array}
		\right.
		\vspace{1mm} \\
		\auxmapp{\bbra{n}{l_i:P_i}_{i \in I}}{\mathsf{v}}{\sigma} &\bnfis&
		%\auxmapp{\bsel{n}{l} P}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\bbra{x_n}{l_i:\auxmapp{P_i}{\mathsf{v}}{\sigma}}_{i \in I}  & n \notin \sigma\\
			\bbra{n}{l_i:\auxmapp{P_i}{\mathsf{v}}{\sigma}}_{i \in I}  & n \in \sigma
		\end{array}
		\right.
		\vspace{1mm} \\
		\auxmapp{\appl{\X}{n}}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\appl{\X}{x_n} & n \notin \sigma\\
			\appl{\X}{n} & n \in \sigma\\
		\end{array}
		\right. 
%		\auxmapp{\inact}{\mathsf{v}}{\sigma} &\bnfis& \inact\\
%		\auxmapp{P \Par Q}{\mathsf{v}}{\sigma} &\bnfis& \auxmapp{P}{\mathsf{v}}{\sigma} \Par \auxmapp{Q}{\mathsf{v}}{\sigma} 
	\end{array}
\]
\caption{\label{f:auxmap} The auxiliary map (cf. Def.~\ref{d:auxmap}) 
used in the encoding of first-order communication with recursive definitions into higher-order communication (Def.~\ref{d:enc:fotohorec}).
The mapping is defined homomorphically for inaction and parallel composition.}
\end{figure}
\end{definition}

Given a process $P$ with $\fn{P} = m_1, \cdots, m_n$, we are interested in its associated (polyadic) abstraction, which is defined as
$\abs{x_1, \cdots, x_n}{\auxmapp{P}{\mathsf{v}}{\es} }$, where $\vmap{m_j} = x_j$, for all $j \in \{1, \ldots, n\}$.
This transformation from processes into abstractions can be reverted by
using abstraction and application with an appropriate sequence of session names:
%
\begin{proposition}\rm
	Let $P$ be a \HOp process with $\tilde{n} = \ofn{P}$.
	Also, suppose $\tilde{x} = \vmap{\tilde{n}}$.
%	Also, let $A_P$ be the polyadic abstraction $\abs{\tilde{x}}\auxmapp{P}{\mathsf{v}}{\emptyset}$ (cf. Def.~\ref{d:trabs}).
	Then $P \scong \appl{X}{\tilde{n}}\subst{\abs{\tilde{x}}\auxmapp{P}{\mathsf{v}}{\emptyset}}{X}$.
%	$\appl{X}{\smap{\fn{P}}} \subst{(\vmap{\fn{P}}) \map{P}^{\emptyset}}{X} \scong P$
\end{proposition}

\begin{proof}
	The proof is an easy induction on the map $\auxmapp{P}{\mathsf{v}}{\es}$.
	We give a case since other cases are similar.

	\noi - Case: $\auxmapp{\bout{n}{m} P}{\mathsf{v}}{\es} = \bout{x_n}{x_m} \auxmapp{P}{\mathsf{v}}{\es}$

	\noi We rewrite process substitution as:
	$\appl{X}{\tilde{n}} \subst{\abs{\tilde{x}}{\bout{x_n}{y_m} \auxmapp{P}{\mathsf{v}}{\es}}}{X} = (\bout{x_n}{y_m} P) \subst{\tilde{x}}{\tilde{n}}$

	\noi If consider that $x_n, y_m \in \vmap{\tilde{n}}$ then from the definition of $\vmap{\cdot}$ we
	get that $n, m \in \tilde{n}$. Furthermore by the fact that $\tilde{n}$ and $\vmap{\tilde{n}}$ are
	ordered, substitution becomes:
	$\bout{n}{m} \auxmapp{P}{\mathsf{v}}{\es} \subst{\tilde{x}}{\tilde{n}}$.

	\noi The rest of the cases are similar.
	\qed
\end{proof}

We are now ready to define the encoding of $\sessp$
(including constructs for recursion) into strict process-passing.
Thanks to the encoding in \S\,\ref{ss:polmon}, we may use polyadicity in abstraction and application only
as syntactic sugar.
For the sake of completeness, we give again the encodings for 
finite processes and types, as
formalized 
in \S\,\ref{ss:ffotoho}.
%by $\encod{\cdot}{\cdot}{1}: \sessp^{-\mu} \to \HO$.

\begin{definition}[Full First-Order into Higher-Order]\label{d:enc:fotohorec}
	Let $f$ be a function from recursion variables to sequences of name variables.
	%Define $\fencod{\cdot}{\cdot}{2}{f}: \sessp \to \HO$ as
%
Define the typed encoding $\enco{\map{\cdot}^{2}_f, \mapt{\cdot}^{2}, \mapa{\cdot}^{2}}: \sessp \to \HO$,
\begin{figure}[t]
\[
	\begin{array}{rcll}
%		\map{\rec{X}{P}}^{2} &=& \newsp{s}{\binp{s}{\X} \map{P}^{2} \Par \bout{\dual{s}}{\abs{z \cat \vmap{\fn{P}}}{\binp{z}{\X} \map{P}^{\es}}} \inact}\\
%		\map{r}^{2} &=& \newsp{s}{\appl{\X}{s \cat \smap{\fn{P}}} \Par \bout{\dual{s}}{ \abs{z \cat \vmap{\fn{P}}}{\appl{X}{z \cat \vmap{\fn{P}}}}} \inact} \\
		\pmapp{\recp{X}{P}}{2}{f} &\defeq&
		\newsp{s}{\binp{s}{\X} \pmapp{P}{2}{{f,\{\rvar{X}\to \tilde{n}\}}} \Par \bout{\dual{s}}{\abs{\vmap{\tilde{n}}, z } \,{\binp{z}{\X} \auxmapp{\pmapp{P}{2}{{f,\{\rvar{X}\to \tilde{n}\}}}}{\mathsf{v}}{\es}}} \inact} & \quad \tilde{n} = \ofn{P} \\ 
		\pmapp{\rvar{X}}{2}{f} &\defeq& \newsp{s}{\appl{\X}{\tilde{n}, s} \Par \bbout{\dual{s}}{ \abs{\vmap{\tilde{n}},z}\,\,{\appl{X}{ \vmap{\tilde{n}}, z}}} \inact} & \quad \tilde{n} = f(\rvar{X}) \\
		\pmapp{\bout{k}{n} P}{2}{f}	&\defeq&	\bout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{n}} } \pmapp{P}{2}{f} \\
		\pmapp{\binp{k}{x} Q}{2}{f}	&\defeq&	\binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\abs{x}{\pmapp{Q}{2}{f}}} \inact} \\


		\pmapp{\bsel{s}{l} P}{2}{f} &\defeq& \bsel{s}{l} \pmapp{P}{2}{f} \qquad
		\pmapp{\bbra{s}{l_i: P_i}_i \in I}{2}{f} \defeq \bbra{s}{l_i: \pmapp{P_i}{2}{f}}_i \in I\\
		\pmapp{\bout{k}{\abs{\tilde{x}}{Q}} P}{2}{f} &\defeq& \bout{k}{\abs{\tilde{x}}{\pmapp{Q}{2}{f}}} \pmapp{P}{2}{f} \qquad
		\pmapp{\binp{k}{X} P}{2}{f} \defeq \binp{k}{X} \pmapp{P}{2}{f}\\

		\pmapp{P \Par Q}{2}{f} &\defeq& \pmapp{P}{2}{f} \Par \pmapp{Q}{2}{f} \qquad
		\pmapp{\news{n} P}{2}{f} \defeq \news{n} \pmapp{P}{2}{f} \qquad

		\pmapp{\inact}{2}{f} \defeq \inact\\


		\tmap{\btout{S_1} {S} }{2}	&\defeq&	\bbtout{\lhot{\btinp{\lhot{\tmap{S_1}{2}}}\tinact}} \tmap{S}{2}  \\
		\tmap{\btinp{S_1} S }{2}	&\defeq&	\bbtinp{\lhot{\btinp{\lhot{\tmap{S_1}{2}}}\tinact}} \tmap{S}{2} \\
		\tmap{\bbtout{\chtype{S_1}} {S} }{2}	&\defeq&	\bbtout{\shot{\btinp{\shot{\chtype{\tmap{S_1}{2}}}}\tinact}} \tmap{S}{2}  \\
		\tmap{\bbtinp{\chtype{S_1}} {S} }{2}	&\defeq&	\bbtinp{\shot{\btinp{\shot{\chtype{\tmap{S_1}{2}}}}\tinact}} \tmap{S}{2} \\

		\tmap{\btout{L} S}{2} &\defeq& \btout{L} \tmap{S}{2}\\
		\tmap{\btinp{L} S}{2} &\defeq& \btinp{L} \tmap{S}{2}\\
		\tmap{\btsel{l_i: S_i}_{i \in I}}{2} &\defeq& \btsel{l_i: \tmap{S_i}{2}}_{i \in I}\\
		\tmap{\btbra{l_i: S_i}_{i \in I}}{2} &\defeq& \btbra{l_i: \tmap{S_i}{2}}_{i \in I}\\

		\tmap{\vart{t}}{2} &\defeq& {t} \qquad
		\tmap{\trec{t}{S}}{2} \defeq \trec{t}{\tmap{S}{2}} \qquad
		\tmap{\tinact}{2} \defeq \tinact\\

		\mapa{\bactout{n}{m}}^{2} &\defeq&   \bactout{n}{\abs{z}{\,\binp{z}{X} \appl{X}{m}} } \\
		\mapa{\bactinp{n}{m}}^{2} &\defeq&   \bactinp{n}{\abs{z}{\,\binp{z}{X} \appl{X}{m}} } \\

		\mapa{\bactout{n}{\abs{\tilde{x}}{P}}}^{2} &\defeq& \bactout{n}{\abs{\tilde{x}}{\pmapp{P}{2}{\es}}} \qquad
		\mapa{\bactinp{n}{\abs{\tilde{x}}{P}}}^{2} \defeq \bactinp{n}{\abs{\tilde{x}}{\pmapp{P}{2}{\es}}}\\
		\mapa{\tau} &\defeq& \tau
	\end{array}
\]
\caption{\label{f:enc:fotohorec}
Typed encoding of first-order communication into higher-order communication (cf.~Defintion~\ref{d:enc:fotohorec}).
Mappings 
$\map{\cdot}^2$,
$\mapt{\cdot}^2$, 
and 
$\mapa{\cdot}^2$
are homomorphisms for the other processes/types/labels. 
}

\end{figure}
where mappings $\map{\cdot}^{2}$, $\mapt{\cdot}^{2}$, $\mapa{\cdot}^{2}$
are as in Fig.~\ref{f:enc:fotohorec}.
\end{definition}

\begin{remark}
Let $\Delta = \{n_1:S_1, \ldots, n_m:S_m\}$ be a session environment.
Write $\tilde{S}_{\Delta} = S_1, \ldots, S_m$.
	We define  mapping $\mapt{\cdot}^{2}$ on (first-order) shared environments $\Gamma$ as follows:
	\begin{eqnarray*}
	\mapt{\Gamma \cat k:\chtype{S}}^{2} & =  & \mapt{\Gamma}^{2} \cat k:\mapt{\chtype{S}}^{2} \\
	\tmap{\Gamma \cat \rvar{X}:\Delta}{2} & = & \tmap{\Gamma}{2} \cat X:\shot{(\tilde{S}_{\Delta}\,,\,S^*)}\qquad 
		\text{where
	$S^* = \trec{t}{\big((\tilde{S}_{\Delta}\,,\, \btinp{\vart{t}}\tinact)\big)}$}
	\end{eqnarray*}
\end{remark}

%\begin{proposition}\rm
%	Encoding $\fencod{\cdot}{\cdot}{2}{f}: \sessp \to \HO$  
%	is type-preserving (cf. Def.~\ref{def:ep}\,(1)).
%\end{proposition}


\begin{proposition}[Type Preservation, Full First-Order into Higher-Order]\label{prop:typepres2}
Let $P$ be a  $\sessp$ process.
If			$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then 
			$\mapt{\Gamma}^{2}; \emptyset; \mapt{\Delta}^{2} \proves \map{P}_f^{2} \hastype \Proc$. 
\end{proposition}

\begin{proof}
By induction on the inference $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$. 
Details in Appendix~\ref{app:enc_sesp_to_HO}.
	\qed
\end{proof}

%\begin{proposition}\rm
%	Encoding $\fencod{\cdot}{\cdot}{2}{f}: \sessp \to \HO$ 
%	enjoys operational correspondence (cf. Def.~\ref{def:ep}\,(2)).
%\end{proposition}

The following proposition formalizes our strategy  for encoding recursive definitions
as passing of polyadic abstractions:
\begin{proposition}[Operational Correspondence for Recursive Processes]
Let $P$ and $P_1$ be $\sessp$ processes s.t. $P =\recp{X}{P'}$ and $P_1 = P'\subst{\recp{X}{P'}}{\rvar{X}} \scong P$. \\
If $P_1 \hby{\ell} P_2$ then there exist
processes $R_1$, $R_2$,
context $C$, 
action $\ell'$,
and 
mapping $f_1$
such that: 
(1)~$\map{P}_f^{2} \hby{\tau} \map{P'}_{f_1}^{2}\subst{\context{C}{\map{P'}_{f_1}^{2}}}{X} = R_1$; and
(2)~$R_1 \Hby{\ell'} R_2$, with $\ell' = \mapa{\ell}^{2}$.
\end{proposition}

\begin{proof}[Sketch]
Part (1) follows directly from the definition of typed encoding for processes $\map{\cdot}_f^{2}$
(Defintion~\ref{d:enc:fotohorec}).
We have that 
context $\context{C}{\cdot} = \abs{\tilde{m}}\binp{z}{X}\auxmapp{\cdot}{\mathsf{v}}{\sigma}$
(where $\tilde{m} = \ofn{P'},z$)
and
$f_1 = f, \{\rvar{X} \to \ofn{P'}\}$.
Part (2) relies on  Prop.~\ref{p:opcorrfho}.
\qed
\end{proof}

\begin{proposition}[Operational Correspondence, Full First-Order into Higher-Order]
\label{p:auxfullfho}
Let $P$ be a  $\sessp$ process.
If $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then
		\begin{enumerate}[a)]
			\item	 
			   If  $\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$
			   then  $\exists \ell_2$ s.t. \\
			    $\wtytra{\mapt{\Gamma}^{2}}{\ell_2}{\mapt{\Delta}^{2}}{\map{P}_f^{2}}{\mapt{\Delta'}^{2}}{\map{P'}_f^{2}}$
			    and $\ell_2 = \mapa{\ell_1}^{2}$.
			\item   
			If  $\wtytra{\mapt{\Gamma}^{2}}{\ell_2}{\mapt{\Delta}^{2}}{\map{P}^{2}_f}{\mapt{\Delta'}^{2}}{Q}$
			   then $\exists \ell_1, P'$ s.t.  \\
			    (i)~$\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$,
			    (ii)~$\ell_2 = \mapa{\ell_1}^{2}$, 
			    (iii)~$\wbb{\mapt{\Gamma}^{2}}{\ell}{\mapt{\Delta'}^{2}}{\map{P'}_f^{2}}{\mapt{\Delta'}^{2}}{Q}$.
			    \end{enumerate}
\end{proposition}

\begin{proof}[Sketch]
The proof follows similar lines as the proof of Prop.~\ref{p:opcorrfho},
using 
Prop.~\ref{p:auxfullfho} in the extra cases $P =\recp{X}{P'}$ and $P = \rvar{X}$.
	\qed
\end{proof}

\subsection{From $\HO$ to $\sessp$}\label{ss:hotofo}

We now discuss the encodability of  $\HO$ into $\sessp$, 
i.e., how to encode a higher-order calculus with abstraction passing only
into a calculus with name passing only. 
We essentially follow the representability result put forward by 
Sangiorgi~\cite{San92,SaWabook}, but casted in the setting of session-typed communications. 
As we shall see, linearity of session endpoints will play a role in adaptating Sangiorgi's 
encodability strategy into a typed setting. 
Intuitively, such a strategy represents the exchange of a process with the exchange of 
a \emph{trigger}---a freshly generated names. 
Triggers may then be used to activate copies of the process, which now becomes a persistent 
resource represented by an input-guarded replication. In session-based communication, a session name 
is a linear resource and cannot be replicated. Consider the following (naive) adaptation of 
Sangiorgi's strategy in which session names are used are triggers and exchanged processes would be have to used exactly once:
%\begin{definition}[From $\HO$ to $\sesp$. Naive approach]
\[
	\begin{array}{lcl}
		\pmap{\bout{k}{\abs{x}{P_1}} Q}{n} & \defeq &  \newsp{s}{\bout{k}{s} (\pmap{Q}{n} \Par \binp{\dual{s}}{x} \pmap{P_1}{n})} \\
		\pmap{\binp{k}{X} P}{n} & \defeq& \binp{k}{x} \pmap{P}{n}\\
		\pmap{\appl{X}{k}}{n} & \defeq & \bout{x}{k} \inact
	\end{array}
	\]
%\end{definition}
%
%\begin{proposition}
%	Let $\Gamma;\emptyset;\Sigma \proves P \hastype \Proc$ with
%	the typing derivation to use only linear session types. Then
%	$\map{P}^8$ respects the properties of definition~\ref{def:ep}.
%\end{proposition}
%
%\begin{proof}
%	\dk{TODO}
%\end{proof}
(The mapping $\pmap{\cdot}{n}$ would be defined homomorphically for the remaining $\HO$ constructs.)
Although $\pmap{\cdot}{n}$ captures the correct semantics when
dealing with systems that allow only linear process variables,
it suffers from non-typability in the presence
of shared process variables. For instance,
let $P = \bout{n}{\abs{x}{\bout{x}{m}\inact}} \inact \Par \binp{\dual{n}}{X} (\appl{X}{s_1} \Par \appl{X}{s_2})$.
We would have
\[
	\pmap{P}{n} \defeq
	\newsp{s}{\bout{n}{s} \binp{\dual{s}}{x} \bout{x}{m} \inact \Par \binp{\dual{n}}{x} (\bout{x}{s_1} \inact \Par \bout{x}{s_2} \inact)}
\]
The above process is non typable since processes $(\bout{x}{s_1} \inact$ and $\bout{x}{s_2} \inact)$
cannot be put in parallel because they do not have disjoint session environments.

The correct approach would be to use replicated shared names
as triggers instead of session names. 
Below we write $\repl{} P$ as a shorthand notation for $\recp{X}{(P \Par \rvar{X})}$.

\begin{definition}[Higher-Order into First-order]\label{d:enc:hotofo}
	Define $\encod{\cdot}{\cdot}{3}: \HO \to \sessp$ 
	Let $\enco{\map{\cdot}^3, \mapa{\cdot}^3, \mapa{\cdot}^3,}$ be the typed encoding, with mappings 
	$\map{\cdot}^{3}$, $\mapt{\cdot}^{3}$, $\mapa{\cdot}^{3}$ as
	in Fig.~\ref{f:enc:hotofo}.

	\begin{figure}[t]
	\[
	\begin{array}{rcl}
		\pmap{\bout{k}{\abs{x}{Q}} P}{3} & \defeq &  \left\{
		\begin{array}{ll}
			\newsp{a}{\bout{k}{a} (\pmap{P}{3} \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{3})\,} & s \notin \fn{Q} \\
			\newsp{a}{\bout{k}{a} (\pmap{P}{3} \Par \binp{a}{y} \binp{y}{x} \pmap{Q}{3})\,} & \textrm{otherwise} %\dk{Q \textrm{ linear}} \\
		\end{array}
		\right.
		\\
		\pmap{\binp{k}{X} P}{3} &\defeq&  \binp{k}{x} \pmap{P}{3}\\
		\pmap{\appl{X}{k}}{3} & \defeq & \newsp{s}{\bout{x}{s} \bout{\dual{s}}{k} \inact}\\
		\tmap{\btout{\lhot{S}}S_1}{3} & \defeq & \bbtout{\chtype{\btinp{\tmap{S}{3}}\tinact}}\tmap{S_1}{3} \\
		\tmap{\btinp{\lhot{S}}S_1}{3} & \defeq & \bbtinp{\chtype{\btinp{\tmap{S}{3}}\tinact}}\tmap{S_1}{3} \\
		\mapa{\bactout{k}{\abs{ x}{P}} }^3 &  \defeq & \news{a} \bactout{k}{a} \\
		\mapa{\bactinp{k}{\abs{ x}{P}} }^3 &  \defeq & \bactinp{k}{a}
	\end{array}
	\]
	\caption{
Typed encoding of higher-order  into first-order communication (cf.~Defintion~\ref{d:enc:hotofo}).
\label{f:enc:hotofo}
Mappings 
$\map{\cdot}^3$,
$\mapt{\cdot}^3$, 
and 
$\mapa{\cdot}^3$
are homomorphisms for the other processes/types/labels. 
}
\end{figure}
\end{definition}

\begin{proposition}[Type Preservation, Higher-Order into First-Order]\label{prop:typepres3}
Let $P$ be an  $\HO$ process. 
If			$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ then 
			$\mapt{\Gamma}^{3}; \emptyset; \mapt{\Delta}^{3} \proves \map{P}^{3} \hastype \Proc$. 
\end{proposition}

\begin{proof}
By induction on the inference $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$. 
Details in \S\,\ref{app:enc_HO_to_sessp} (Page~\pageref{app:enc_HO_to_sessp}).
	\qed
\end{proof}

\begin{proposition}[Operational Correspondence, Higher-Order into First-Order]
Let $P$ be an  $\HO$ process such that  $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$.
		\begin{enumerate}[a)]
%			\item	 
%			   If  $\stytra{\Gamma}{\bactout{k}{\abs{x}Q}}{\Delta}{P}{\Delta'}{P'}$
%			   then 
%			   $\map{P}^{3} \hby{\news{a}\bactout{k}{a}} \scong \map{P'}^{3} \Par R_a$, \\ where 
%			   either
%			   $R_a = \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{3}$ 
%			   or $R_a = \binp{a}{y} \binp{y}{x} \pmap{Q}{3}$.
			\item	 
			   If  $\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'}$
			   with $\ell_1 = \bactout{k}{\abs{x}Q}$,
			   then 
			   there exist $\Gamma', R$ such that \\
			   $\mapt{\Gamma}^{3};\, \mapt{\Delta}^{3} \proves  \map{P}^{3} 
			   \hby{\mapa{\ell_1}^{3}}
			   \Gamma' \cdot \mapt{\Gamma}^{3};\, \mapt{\Delta'}^{3} \proves \map{P'}^{3} \Par R_a$, 
			   where either \\
			   $R_a = \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{3}$ 
			   or $ R_a = \binp{a}{y} \binp{y}{x} \pmap{Q}{3}$.
			   
%			\item	 
%			   If  $\stytra{\Gamma}{\bactinp{k}{\abs{x}Q}}{\Delta}{P}{\Delta'}{P'\subst{\abs{x}Q}{X}}$
%			   then 
%			   $\map{P}^{3} \hby{ \bactinp{k}{a}} \map{P'}^{3}\subst{a}{x}$.				


			\item	 
			   If  $\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P'\subst{\abs{x}Q}{X}}$
			   with $\ell_1 = \bactinp{k}{\abs{x}Q}$
			   then \\
			   $\mapt{\Gamma}^{3};\, \mapt{\Delta}^{3} \proves  \map{P}^{3} 
			   \hby{\mapa{\ell_1}^{3}}
			   \Gamma';\, \mapt{\Delta'}^{3} \proves  \map{P'}^{3}\subst{a}{x}$, 
			   where $\Gamma' = \mapt{\Gamma}^{3}\subst{a}{x}$.
			   
%			   $\stytra{\mapt{\Gamma}^{3}}{\mapa{\ell_1}^{3}}{\mapt{\Delta}^{3}}{\map{P}^{3}}{\mapt{\Delta'}^{3}}{$.
			   



			\item	 
			   If  $\stytra{\Gamma}{\ell_1}{\Delta}{P}{\Delta'}{P_1 \Par P_2\subst{\abs{x}Q}{X}}$
			   with $\ell_1 = \tau$
			   then \\
			   $\mapt{\Gamma}^{3};\, \mapt{\Delta}^{3} \proves  \map{P}^{3} 
			   \hby{\mapa{\ell_1}^{3}}
			   \mapt{\Gamma}^{3};\, \mapt{\Delta'}^{3} \proves  \map{P_1}^{3} \Par \news{a}
			   (\map{P_2}^{3}\subst{a}{x} \Par R_a)$, \\
			   where 
			   either
			   $R_a = \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{3}$ 
			   or $R_a = \binp{a}{y} \binp{y}{x} \pmap{Q}{3}$.
			   			   
%			   then  $\exists \ell_2$ s.t. 
%			    $\wtytra{\mapt{\Gamma}^{3}}{\ell_2}{\mapt{\Delta}^{3}}{\map{P}^{3}}{\mapt{\Delta'}^{3}}{\map{P'}^{3}}$
%			    and $\ell_2 = \mapa{\ell_1}^{3}$.

			\item   \footnote{$\mapt{\Gamma}^{3}$ in the following three items need adjustments.}
			If  $\stytra{\mapt{\Gamma}^{3}}{\news{a}\bactout{k}{a}}{\mapt{\Delta}^{3}}{\map{P}^{3}}{\mapt{\Delta'}^{3}}{R}$
			then there are $x$, $Q$, $P'$ such that \\
			$P \hby{\bactout{k}{\abs{x}Q}} P'$
			and $R = \map{P'}^{3} \Par R_a$, where 
			   either
			   $R_a = \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{3}$ 
			   or $R_a = \binp{a}{y} \binp{y}{x} \pmap{Q}{3}$.

			\item   
			If  $\stytra{\mapt{\Gamma}^{3}}{\bactinp{k}{a}}{\mapt{\Delta}^{3}}{\map{P}^{3}}{\mapt{\Delta'}^{3}}{R}$
			then there are $x$, $Q$, $P'$ such that \\
			$P \hby{\bactout{k}{\abs{x}Q}} P'\subst{\abs{x}Q}{X}$
			and $R = \map{P'}^{3}\subst{a}{x}$.
			
			\item   
			If  $\stytra{\mapt{\Gamma}^{3}}{\tau}{\mapt{\Delta}^{3}}{\map{P}^{3}}{\mapt{\Delta'}^{3}}{R}$
			then exists a $P'$ such that 
			$P \hby{\tau} P'$
			and $\wbb{\mapt{\Gamma}^{3}}{\ell}{\mapt{\Delta'}^{3}}{\map{P'}^{3}}{\mapt{\Delta'}^{3}}{R}$.
			    \end{enumerate}
\end{proposition}

\begin{proof}
Follows directly from Defintion~\ref{d:enc:hotofo}, using the substitution lemma (Lemma~\ref{lem:subst})
and Prop.~\ref{prop:typepres3}.
	\qed
\end{proof}

\begin{comment}
\begin{proof}[Sketch]
For completeness, we 
consider the \HO process $P = {\bbout{k}{\abs{x} Q} P_1} \Par \binp{k}{X} P_2$. We have that
\[
P \red P_1 \Par P_2 \subst{\abs{x}Q}{X}
\]
In the target language, this reduction is mimicked as follows:
\begin{eqnarray*}
\pmap{P}{2} & = & \newsp{a}{\bout{k}{a} (\pmap{P_1}{3} \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{3})\,} 
                  \Par \binp{k}{x} \pmap{P_2}{3} \\
            & \red & \newsp{a}{\pmap{P_1}{3} \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{3} 
                  \Par  \pmap{P_2}{3}\subst{a}{x}}
\end{eqnarray*}
\qed
\end{proof}
\end{comment}


\begin{conjecture}[Full Abstraction: Higher-Order / First-Order]
\begin{enumerate}[a)]
\item
If
$\wbb{ \Gamma}{\ell}{\Delta_1}{ P }{ \Delta_2}{Q}$
then
$\wbb{\mapt{\Gamma}^{3}}{\ell}{\mapt{\Delta_1}^{3}}{\map{P}^{3}}{\mapt{\Delta_2}^{3}}
{\map{Q}^{3}}$.
\item  
If 
$\wbb{\mapt{\Gamma}^{3}}{\ell}{\mapt{\Delta_1}^{3}}{\map{P}^{3}}{\mapt{\Delta_2}^{3}}
{\map{Q}^{3}}$
then 
$\wbb{ \Gamma}{\ell}{\Delta_1}{ P }{ \Delta_2}{Q}$.
\end{enumerate}
While (a) is  completeness (non trivial), (b) is soundness  (easy in principle).
\end{conjecture}

At this point an open  question would be if we could find an encoding that maps
session names to session names without the creation of shared names.

\dk{put intuition??}

