% !TEX root = main.tex

\newpage
\section{Typed Encodings}\label{s:expr}

In this section we present a study of the expressiveness of $\HOp$ and its subcalculi. 
%In general, we may define:

\begin{definition}[Typed Calculus]\label{d:tcalculus}\rm
	A \emph{typed calculus} $\tyl{L}$ is a tuple
$		\calc{L}{T}{\hby{\ell}}{\wb}{\proves}$
	where $L$ and $T$ are set of processes and types, respectively.
	Also, $\hby{\ell}$, $\wb$, and $\proves$ 
	denote a transition semantics, a typed process equivalence, and a type system for $L$ processes, respectively. 
\end{definition}

We shall consider as typed calculi some
 subcalculi of $\HOp$, using the same 
  type system (as in \S\,\ref{s:types}),
 transition semantics (cf. Def.~\ref{d:tlts}) with labels $\ell$ (as in  \S\,\ref{ss:lts}), 
 and behavioral equivalence (cf. Def.~\ref{d:bisim}) for all variants. 
  Thus, in the following, when writing $\tyl{L}_i$ we tacitly assume the existence of appropriate 
  $L_i$ and $T_i$, keeping all other elements unchanged.
 We define the notion of encoding over typed calculi.

\begin{definition}[Typed Encoding]\rm
	Let  $\tyl{L}_1$ % = \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1}$
	and $\tyl{L}_2$ % =  \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$ 
	be typed calculi. % as in Definition~\ref{d:tcalculus}.
	Given mappings $\map{\cdot}: L_1 \to L_2$, 
	$\mapt{\cdot}: T_1 \to T_2$, and 
	$\mapa{\cdot}: \ell \to \ell^{\,m}$, 
	we write 
	%$\enc{\cdot}{\cdot}: \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1} \longrightarrow \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$
%	for the encoding from $\calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1}$ to $\calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$.
	$\enco{\map{\cdot}, \mapt{\cdot}, \mapa{\cdot}} : \tyl{L}_1 \to \tyl{L}_2$
	to denote the \emph{typed encoding} of $\tyl{L}_1$ into $\tyl{L}_2$.
\end{definition}

Thus, our notion of encoding considers a process mapping $\map{\cdot}$,
a mapping on types $\mapt{\cdot}$, and a mapping $\mapa{\cdot}$ from transition labels 
into \emph{sets} of transition labels. 
In the following we use number decorations on these mappings, to distinguish them.

We should assume that if 
$P \hby{\ell} P'$ and $\mapa{\ell} = \{\ell_1, \ell_2,  \cdots, \ell_m\}$ then
there exist $P_1, P_2, \ldots, P_m$ such that
$\map{P} \Hby{\ell_1} P_1 \Hby{\ell_2} P_2 \cdots \Hby{\ell_m} P_m =  \map{P'}$.


% Parameters - 1:Gamma , 2:label, 3:initial delta, 4:initial processes, 5:final delta, 6:initial process
\newcommand{\stytra}[6]{\ensuremath{#1; \emptyset; #3 \hby{#2} #5 \proves #4  \hby{#2} #6 }}
\newcommand{\wtytra}[6]{\ensuremath{#1; \emptyset; #3 \Hby{#2} #5 \proves #4  \Hby{#2} #6 }}
\newcommand{\wbb}[6]{\ensuremath{#1; \emptyset; #3 \wb #5 \proves #4  \wb #6 }}

%\subsection{Encoding Properties}
%We use the following labeled transitions:
%\begin{enumerate}
%\item Strong case: $\Gamma; \emptyset; \Delta_1 \hby{\ell} \Delta_1' \proves P_1 \hby{\ell} P_2$ \\
%(With the new command: $\stytra{\Gamma}{\ell}{\Delta_1}{P_1}{\Delta'_1}{P_2}$)
%\item Weak case: $\Gamma; \emptyset; \Delta_1 \Hby{ \ell} \Delta_1' \proves P_1 \Hby{ \ell} P_2$ \\
%(With the new command: $\wtytra{\Gamma}{\ell}{\Delta_1}{P_1}{\Delta'_1}{P_2}$)
%\item Using the command for weak bisimilarity:
%$\wbb{\Gamma}{\ell}{\Delta_1}{P_1}{\Delta'_1}{P_2}$.
%
%\end{enumerate}

We require that a {\em good} typed encoding should 
preserve not only the syntax but
also the operational, typing and behavioural
semantics. 

% ----> DK: The next notation is already defined
%\begin{notation}[Typed Equivalence]\rm
%	Let $P$ and $Q$ be two well-typed processes, i.e., 
%	there exist $\Gamma, \Sigma_1, \Sigma_2$ such that 
%	$\Gamma; \emptyset; \Sigma_1 \proves P \hastype \Proc$ 
%	and
%	$\Gamma; \emptyset; \Sigma_2 \proves Q \hastype \Proc$.
%	Then, to denote the fact that 
%	$P$ and $Q$ are related by behavioral equivalence $\wb$, we shall write
%	%Then we adopt the following notational convention:
%	\[
%		\Gamma; \Sigma_1 \wb \Sigma_2 \proves P \wb Q.
%	\]
%\end{notation}

\begin{definition}[Semantic Preserving Encoding]\rm
	\label{def:ep}
	We say that $\enco{\map{\cdot}, \mapt{\cdot}, \mapa{\cdot}}: \tyl{L}_1 \to \tyl{L}_2$ is a \emph{semantic preserving encoding}
	if it satisfies the following properties:
	
	\begin{enumerate}[1.]
		\item \emph{Type preservation}:
		if
			$\Gamma; \emptyset; \Delta \proves_1 P \hastype \Proc$ then 
			$\mapt{\Gamma}; \emptyset; \mapt{\Delta} \proves_2 \map{P} \hastype \Proc$ 
			for any   $P$ in $L_1$.

		\item \emph{Operational Correspondence}: If $\Gamma; \emptyset; \Delta \proves_1 P \hastype \Proc$ then
		\begin{enumerate}[-]
%			\item	Completeness: \\
%			    If $P \red_1 P'$ then $\exists\, \Delta'$ s.t.
%				$\map{P} \Red_2 \map{P'}$ and
%				$\mapt{\Gamma}; \emptyset; \mapt{\Delta'} \proves_2 \map{P'} \hastype \Proc$.
			\item	Completeness: 
			   If  $\stytra{\Gamma}{\ell_1}{\Delta_1}{P}{\Delta'_1}{P'}$
			   then \\ $\exists \ell_2$ s.t. 
			    $\wtytra{\mapt{\Gamma}}{\ell_2}{\mapt{\Delta_1}}{\map{P_1}}{\mapt{\Delta'_1}}{\map{P_2}}$
			    and $\ell_2 = \mapa{\ell_1}$.
			    				
%			\item Soundness : \\
%			    If $\map{P} \red_2 Q$ then
%				$\exists P'$ s.t. $P \red_1 P'$ and 
%				$\mapt{\Gamma}; \mapt{\Delta_1} \wb_2 \mapt{\Delta_2} \proves_2 \map{P'} \wb_2 Q$.
				
			\item Soundness:   
			If  $\wtytra{\mapt{\Gamma}}{\ell_2}{\mapt{\Delta_1}}{\map{P}}{\mapt{\Delta'_1}}{Q}$
			   then $\exists \ell_2, P'$ s.t.  \\
			    (i)~$\stytra{\Gamma}{\ell_1}{\Delta_1}{P}{\Delta'_1}{P'}$,
			    (ii)~$\ell_2 = \mapa{\ell_1}$, and
			    (iii)~$\wbb{\Gamma}{\ell}{\Delta'_1}{P'}{\mapt{\Delta'_1}}{Q}$.
		\end{enumerate}
		
		\item \emph{Full Abstraction:} \\
		$\Gamma; \Sigma_1 \wb_1 \Sigma_2 \proves_1 P \wb_1 Q $ if and only if $\mapt{\Gamma}; \mapt{\Sigma_1} \wb_2 \mapt{\Sigma_2} \proves_2 \map{P} \wb_2 \map{Q} $.
	\end{enumerate}
\end{definition}


We show that the composition of encodings is closed on the above properties.

\begin{proposition}[Composability of Semantic Preserving Encodings]
	Let 
	$\enco{\map{\cdot}^{1}, \mapt{\cdot}^{1}, \mapa{\cdot}^{1}}: \tyl{L}_1 \to \tyl{L}_2$
	and 
	$\enco{\map{\cdot}^{2}, \mapt{\cdot}^{2}, \mapa{\cdot}^{2}}: \tyl{L}_2 \to \tyl{L}_3$
%	$\enco{\cdot}{\cdot}{1}: \tyl{L}_1 \to \tyl{L}_2$ and $\encod{\cdot}{\cdot}{2}: \tyl{L}_2 \to \tyl{L}_3$
	be two semantic preserving encodings.
	Then their composition, denoted 
	$\enco{\map{\cdot}^{1} \circ \map{\cdot}^{2}, \mapt{\cdot}^{1} \circ \mapt{\cdot}^{2}, \mapa{\cdot}^{1}\circ \mapa{\cdot}^{2}}: \tyl{L}_1 \to \tyl{L}_3$
	is also a semantic preserving encoding.
\end{proposition}

\begin{proof}
	Straightforward application of the definition of each property.
\end{proof}

\section{Positive Expressiveness Results}
\begin{comment}
\subsection{Languages Under Consideration}
We consider the following variants of \HOp:
\begin{enumerate}[-]
	\item	\HO: the second and third lines of the syntax of processes in Fig.~\ref{fig:syntax} (pure higher-order, monadic communication).
	\item	\sesp: the first and third lines of the syntax of processes in Fig.~\ref{fig:syntax} (first-order, monadic communication).
	\item	\sespnr: the finite sub-calculus of \sesp, i.e., name passing without recursion.
	\item	$\HO^{+\mathsf{p}}$: The polyadic \HO, i.~e.\ without polyadicity (polyadic abstraction/application).
	\item	$\sesp^{+\mathsf{p}}$: The polyadic \sesp, i.~e.\ with polyadicity (name passing)
	\item	$\HOp^{-\mathsf{p}}$: The monadic \HOp.
%	\item \pHOpnr: the finite variant of \pHOp 
%	\item \psesp: the variant of \sesp with polyadic communication.
%	\item \psespnr: the finite variant of \psesp with polyadic communication.
\end{enumerate}
\noindent
In the following we write $\pmap{\cdot}{i}$
and $\tmap{\cdot}{i}$ 
for mappings of processes and types, respectively.
Since we always consider variants and fragments of \HOp, the 
reduction semantics $\red$, the typed behavioral equivalence $\wb$,
and the type system $\proves$ are the same for all languages.
\end{comment}

\subsection{Encode Polyadic Semantics (\HOp) to Monadic Semantics ($\HOp^{-\mathsf{p}}$)}\label{ss:polmon}

%In the extension of \HOp with 
%polyadic communication, denoted \pHOp, 
%one may pass in each synchronization 
%a tuple of values of length $n$, rather than a just single value.
%Thus, e.g., for $n = 2$ one would have
%%
%\begin{eqnarray*}
%	\bout{n}{m_1, m_2} P \Par \binp{\dual{n}}{x_1,x_2} Q  & \red &  P \Par Q \subst{m_1, m_2}{x_1, x_2} \\
%	\bout{n}{\abs{x_1, x_2}{P_1}} P \Par \binp{\dual{s}}{\X} Q & \red & P \Par Q \subst{\abs{x_1,x_2}{P_1}}{\X}
%\end{eqnarray*}
%%
%with $\appl{X}{k_1,k_2} \subst{\abs{x_1,x_2}{Q}}{\X}  =  Q \subst{k_1,k_2}{x_1,x_2} $.
%Thus, 
%\pHOp features tuple passing in intra-session (linear) communication,
%but also in abstractions/applications. 
%The session type system for \pHOp is an orthogonal
%extension of that in \S\,\ref{s:types}.
%The type syntax for values is extended as follows,
%where $\tilde{S}$ stands for a sequence $S_1, \ldots, S_n$ of 
%session types:
%
%\begin{eqnarray*}
%	U \bnfis  & \tilde{S} \bnfbar \lhot{\tilde{S}} \bnfbar \shot{\tilde{S}} \bnfbar \chtype{S}
%\end{eqnarray*}
%
%The syntax of session types would be kept unchanged.
%Typing rules require straightforward extensions. 
%For instance, the following rules would type 
%abstraction and application in the biadic case ($n = 2$):
%\[
%\trule{Abs2}~~\tree{
%			\Gamma; \Lambda; \Sigma \cat x_1: S_1, x_2: S_2 \proves P \hastype \Proc
%		}{
%			\Gamma; \Lambda; \Sigma \proves \abs{x_1, x_2}{P} \hastype \lhot{(S_1, S_2)}
%		}
%		\quad
%		\trule{App2}~~\tree{
%		\begin{array}{c}
%		(U = \lhot{(S_1,S_2)}) \lor (U = \shot{(S_1,S_2)}) \\
%		\Gamma; \Lambda; \Sigma \proves X \hastype U  \\
%		\Gamma; \Lambda_1; \Sigma_1 \proves k_1 \hastype S_1 \quad 		
%		\Gamma; \Lambda_2; \Sigma_2 \proves k_2 \hastype S_2
%		\end{array}
%		}{
%			\Gamma; \Lambda \cup  \Lambda_1 \cup \Lambda_2; \Sigma \cup \Sigma_1 \cup \Sigma_2 \proves \appl{X}{k_1,k_2} \hastype \Proc
%		} 
%\]

In the untyped $\pi$-calculus, polyadic communication
can be encoded into monadic name passing by first generating a fresh channel and then 
performing $n$ monadic synchronizations on that channel. 
In session-typed $\pi$-calculi this encoding is even more direct, 
thanks to the linearity and non-interference  of session endpoints~\cite{VascoFun}.
%The extension of the (monadic) session type system given in \S\,\ref{s:types}
%to handle polyadic communication is straightforward and follow expected lines.
%For this reason, we do not present a typing system for \pHOp in full detail; rather, 
%we shall define a syntactic transformation of \pHOp into \HOp, rather than as a typed encoding.
%\footnote{The definition of a polyadic semantics would only add visual clutter to our presentation,
%as all results extend easily from monadic to polyadic communication.}
Below we  define an encoding of polyadic semantics to monadic semantics.
Using this encoding, %Because of the polyadic to monadic encoding %, denoted  $\auxmap{\cdot}{\mathsf{p}}$,
we may focus on monadic session processes,
and rely on polyadic constructs simply as convenient syntactic sugar.
In fact, we shall rely on polyadicity to encode recursive behaviors.
%
\begin{definition}[Polyadic Into Monadic]\rm
Let 
$\enco{\map{\cdot}^{\mathsf{p}}, \mapt{\cdot}^{\mathsf{p}}, \mapa{\cdot}^{\mathsf{p}}}: \HOp \to \HOp^{-\mathsf{p}}$
be a typed encoding, where
	%$\auxmap{\cdot}{\mathsf{p}}:\pHOp \to \HOp$ as
\[
	\begin{array}{rcl}
		\map{\bout{k}{k_1, \cdots, k_m} P}^{\mathsf{p}}
		&\defeq&
		\bout{k}{k_1} \cdots ;  \bout{k}{k_m} \map{P}^{\mathsf{p}}
		\\

		\map{\binp{k}{x_1, \cdots, x_m} P}^{\mathsf{p}}
		&\defeq&
		\binp{k}{x_1} \cdots ; \binp{k}{x_m}  \map{P}^{\mathsf{p}}
		\\
		\map{\bbout{k}{\abs{x_1, \cdots, x_m} Q} P}^{\mathsf{p}}
		&\defeq&
		\bbout{k}{\abs{z}\binp{z}{x_1} \cdots ; \binp{z}{x_m} \map{Q}^{\mathsf{p}}} \map{P}^{\mathsf{p}}
		\\ 
		\map{\appl{X}{k_1, \cdots, k_m}}^{\mathsf{p}}
		&\defeq&
		\newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{k_1} \cdots ; \bout{\dual{s}}{k_m} \inact} 
        \\ % typed mapping starts here
		\tmap{\btout{S_1, \cdots, S_m}S}{\mathsf{p}}
		&\defeq&
		\btout{\tmap{S_1}{\mathsf{p}}} \cdots \btout{\tmap{S_m}{\mathsf{p}}}\tmap{S}{\mathsf{p}}
		\\
		\tmap{\btinp{S_1, \cdots, S_m}S}{\mathsf{p}}
		&\defeq&
		\btinp{\tmap{S_1}{\mathsf{p}}} \cdots \btinp{\tmap{S_m}{\mathsf{p}}}\tmap{S}{\mathsf{p}}
		\\
		\tmap{\lhot{(S_1, \cdots, S_m)}}{\mathsf{p}}
		&\defeq&
		\lhot{\big(\btinp{\tmap{S_1}{\mathsf{p}}} \cdots \btinp{\tmap{S_m}{\mathsf{p}}}\tinact\big)}
		\\
		\tmap{\shot{(S_1, \cdots, S_m)}}{\mathsf{p}}
		&\defeq&
		\shot{\big(\btinp{\tmap{S_1}{\mathsf{p}}} \cdots \btinp{\tmap{S_m}{\mathsf{p}}}\tinact\big)}
		\\ % action mapping starts here
		\mapa{\bactout{k}{k_1, \ldots, k_m}} &\defeq&   \big\{\bactout{k}{k_1}, \cdots, \bactout{k}{k_m}\big\} \\
		\mapa{\bactinp{k}{k_1, \ldots, k_m}} &\defeq&   \big\{\bactinp{k}{k_1}, \cdots, \bactinp{k}{k_m} \big\}\\
		\mapa{\bactout{k}{\abs{x_1, \ldots, x_m}{P}} } &\defeq&  \bactout{k}{\abs{z}\binp{z}{x_1} \cdots ; \binp{z}{x_m} \map{P}^{\mathsf{p}}} \\
		\mapa{\bactinp{k}{\abs{x_1, \ldots, x_m}{P}} } &\defeq&  \bactinp{k}{\abs{z}\binp{z}{x_1} \cdots ; \binp{z}{x_m} \map{P}^{\mathsf{p}}} 
	\end{array}
\]
and mappings $\map{\cdot}^{\mathsf{p}}$, $\mapt{\cdot}^{\mathsf{p}}$, $\mapa{\cdot}^{\mathsf{p}}$
are homomorphisms for the other processes/types/labels. 
	%\jp{I prefer to be explicit in the encoding of polyadic abstraction/applications. Previous version is commented.}
\end{definition}
%
The encoding is simple:
passing an $m$-tuple of names over a session channel $k$ is represented by 
a $m$ exchanges along channel $k$.
The output of an abstraction with $m$ bound variables $x_1, \ldots, x_m$ is represented by
outputting an abstraction with a single bound variable $z$,
which is used as the subject for receiving $x_1, \ldots, x_m$ individually. 
Accordingly, 
%When we are dealing with an abstraction over a list of bound variables,
%then we create a new abstraction name and we use it to receive in a polyadic
%way the list of names on the abstraction. Similarly 
the encoding of a polyadic application  instantiates
the abstraction subject with a freshly generated session name $s$, which will be used  
to the names 
$k_1, \ldots, k_m$
that are going to be applied on the abstraction.
Note that we do not allow polyadic mapping on shared names.
The polyadic mapping, as presented here, is sound only on session names.
%The semantics might break if we apply this mapping on shared names.

%\begin{proposition}
%	$\Gamma; \emptyset; \Sigma \proves \map{P}^{p} \hastype \Proc$
%\end{proposition}

\begin{proposition}\rm
	Encoding $\encod{\cdot}{\cdot}{\mathsf{p}}: \HOp \to \HOp^{-\mathsf{p}}$  is type-preserving (cf. Def.~\ref{def:ep}\,(1)).\rm
\end{proposition}

\begin{proof}
TBD!
	\qed
\end{proof}

\begin{proposition}\rm
	Encoding $\encod{\cdot}{\cdot}{\mathsf{p}}: \HOp \to \HOp^{-\mathsf{p}}$  enjoys operational correspondence (cf. Def.~\ref{def:ep}\,(2)).
\end{proposition}

\begin{proof}
TBD!
	\qed
\end{proof}


\subsection{Encoding $\sessp^{-\mu}$  into \HO}

The semantics of the $\HO$ are powerful enough to
express the semantics of the standard $\sessp$ calculus.

The name passing semantics of $\sessp$ have a rather straightforward
encoding from to $\HO$.
On the other hand to achieve the encoding of the recursion semantic
of $\sessp$, we need to extend
to the polyadic version of $\sessp$ as an intermediate step in order
to give a sound encoding of the recursion semantics to $\HO$.

We first encode the name passing semantics.
%Below, we use $n$ to stand for either a linear channel $k'$ or a shared name $a$.

\begin{definition}[$\sessp^{-\mu}$  into \HO]\rm
	Define $\encod{\cdot}{\cdot}{1}: \sessp^{-\mu} \to \HO$  as follows:
	\[
	\begin{array}{rcl}
		\pmap{\bout{k}{k'} P}{1}		&\defeq&	\bout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{k'}} } \pmap{P}{1} \\
		\pmap{\binp{k}{x} Q}{1}			&\defeq&	\binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x}{\pmap{Q}{1}}} \inact} \\
		\tmap{\btout{S_1} {S} }{1}		&\defeq&	\btout{\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}} \tmap{S}{1}  \\
		\tmap{\btinp{S_1} S }{1}		&\defeq&	\btinp{\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}} \tmap{S}{1} \\
		\tmap{\bbtout{\chtype{S_1}}{S}}{1}	&\defeq&	\btout{\shot{\btinp{\shot{\chtype{\tmap{S_1}{1}}}}\tinact}} \tmap{S}{1}  \\
		\tmap{\bbtinp{\chtype{S_1}}{S}}{1}	&\defeq&	\btinp{\shot{\btinp{\shot{\chtype{\tmap{S_1}{1}}}}\tinact}} \tmap{S}{1} 
	\end{array}
	\]
	where $\pmap{\cdot}{1}$ (resp. $\tmap{\cdot}{1}$) is an 
	homomorphism for the other process (resp. type) constructs.
\end{definition}

In the higher-order setting, a name $k$ is being passed as an input
guarded abstraction. The input prefix receives an abstraction and
continues with the application of $k$ over the received abstraction.
On the reception side $\binp{s}{x} P$ 
the encoding develops a mechanism that will receive
the input guarded abstraction, apply it on a fresh endpoint $s$ and use
the dual endpoint $\dual{s}$ to send the continuation $P$ as the abstraction
$\abs{x}{P}$. Name substitution is then achieved as application.

\begin{proposition}\rm
	Encoding $\encod{\cdot}{\cdot}{1}: \sessp^{-\mu} \to \HO$  is type-preserving (cf. Def.~\ref{def:ep}\,(1)).\rm
\end{proposition}

\begin{proof}
	Proof in Appendix~\ref{app:enc_sesspnr_to_ho} (Page~\pageref{app:enc_sesspnr_to_ho}).
	\qed
\end{proof}

\begin{proposition}\rm
	Encoding $\encod{\cdot}{\cdot}{1}: \sessp^{-\mu} \to \HO$  enjoys operational correspondence (cf. Def.~\ref{def:ep}\,(2)).
\end{proposition}


\begin{proof}
	Proof in Appendix~\ref{app:enc_sesspnr_to_ho} (Page~\pageref{app:enc_sesspnr_to_ho}).
	\qed
\end{proof}

\begin{comment}
\begin{proof}[Sketch]
	We must show completeness and soundness properties. 
	For completeness, it suffices to consider source process
	$P_0 = \bout{k}{k'} P \Par \binp{k}{x} Q$. We have that
%
	\[
		P_0 \red P \Par Q\subst{k'}{x}.
	\]
%
	By the definition of encoding we have:
	\begin{eqnarray*}
		\pmap{P_0}{1} & = & \bbout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{k'}} } \pmap{P}{1} \Par \binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact}  \\
		& \red & \pmap{P}{1} \Par \newsp{s}{\appl{X}{s} \subst{\abs{z}{\,\binp{z}{X} \appl{X}{k'}}}{X} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact} \\
		& = & \pmap{P}{1} \Par \newsp{s}{\,\binp{s}{X} \appl{X}{k'} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact} \\
		& \red & \pmap{P}{1} \Par \appl{X}{k'} \subst{\abs{x} \pmap{Q}{1}}{X} \Par \inact \\
		& \scong & \pmap{P}{1} \Par \pmap{Q}{1}\subst{k'}{x}  
	\end{eqnarray*}
	For soundness, it suffices to notice that the encoding does not add new visible actions:
	the additional synchronizations induced by the encoding always occur on private (fresh) names.
	We assume weak bisimilarities, which abstract from internal actions used by the encoding,
	and so  constructing a relation witnessing behavioral equivalence is easy.
	\qed
\end{proof}
\end{comment}

%\subsection{Polyadic Into Monadic}
%The encoding from $\psesp$ to $\sesp$ is easier than the
%encoding of polyadic $\pi$-calculus in the $\pi$-calculus because
%we have linear session endpoints.
%
%\begin{definition}[$\psesp$ to $\sesp$]
%	We write $\encod{\cdot}{\cdot}{2}:\psesp \to \sesp$ whenever
%
%	\begin{tabular}{c}
%			$\map{\bout{k}{k'_1, \cdots, k'_n} P}^{2} \defeq \bout{k}{k'_1} \cdots ;  \bout{k}{k'_n}
%			\pmap{P}{2}$\\
%			$\map{\binp{k}{x_1, \cdots, x_n} P}^{2} \defeq \binp{k}{x_1} \cdots ; \binp{k}{x_n}  \pmap{P}{2}$ \\
%			$\tmap{\btout{S_1, \cdots, S_n} S}{2} \defeq \bbtout{\tmap{S_1}{2}} \cdots; \bbtout{\tmap{S_n}{2}} \tmap{S}{2}$\\
%			$\tmap{\btinp{S_1, \cdots, S_n} S}{2} \defeq \bbtinp{\tmap{S_1}{2}} \cdots; \bbtinp{\tmap{S_n}{2}} \tmap{S}{2}$
%%		\end{tabular}
%%		& \quad &
%%		\begin{tabular}{l}
%%			$\tmap{\btout{S_1 \cat \tilde{S}} S}{2} \defeq \btout{S_1} \tmap{\btout{\tilde{S}} S}{2}$\\
%%			$\tmap{\btinp{S_1 \cat \tilde{S}} S}{2} \defeq \btinp{S_1} \tmap{\btinp{\tilde{S}} S}{2}$
%%		\end{tabular}
%	\end{tabular}
%\end{definition}
%
%Polyadic name sending (resp.\ receive) is encoded as sequence of
%send (resp.\ receive) operations. Linearity of session endpoints
%ensures no race conditions, thus the encoding is sound.
%
%The encoding of the polyadic $\sesp$ semantics is as simple as the
%composition of the two former encodings.
%
%\begin{definition}[Encoding from $\psespnr$ to $\HO$]
%	We define $\encod{\cdot}{\cdot}{3}: \psespnr \longrightarrow \HO$
%	as $\encod{\cdot}{\cdot}{3} = \encod{\cdot}{\cdot}{1} \cat \encod{\cdot}{\cdot}{2}$.	
%\end{definition}

%So far we have consider name abstractions and applications which are \emph{monadic}.
%We now consider the \emph{polyadic} extension of these constructs, %name abstractions and applications.
%written $\abs{x_1, \ldots, x_n} P$ and $\appl{X}{k_1, \ldots, k_n}$, respectively.
%Next we give the encoding from $\HOp$ with polyadic name abstraction to $\HOp^{p}$.
%
%\begin{definition}[Encoding from $\pHOpnr$ to $\pHOp$]
%
%	\begin{tabular}{lcl}
%		$\map{\bout{k}{\abs{\tilde{x}} P_1} P_2}^4$ &$\defeq$& $\bout{k}{\abs{z} \binp{z}{\tilde{x}} \map{P_1}^4} \map{P_2}^4$\\
%		$\map{\appl{X}{\tilde{k}}}$ &$\defeq$& $\newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\tilde{k}} \inact}$
%	\end{tabular}
%\end{definition}

%We compose the latter encoding with the generalisation $\map{\cdot}^3 : \HOp^{p-\mu} \longrightarrow \HO$
%of the encoding $\map{\cdot}^3 : \sesp^{p-\mu} \longrightarrow \HO$ to get a translation
%of $\HOp^{pa-\mu}$ to $\HO$.
%
%\begin{definition}[Encoding from $\HOp^{pa-\mu}$ to $\HO$]
%	We define $\encod{\cdot}{\cdot}{5}: \HOp^{pa-\mu} \longrightarrow \HO$
%	as $\encod{\cdot}{\cdot}{5} = \encod{\cdot}{\cdot}{4} \cat \encod{\cdot}{\cdot}{3}$.	
%\end{definition}




\subsection{Encoding Recursion into Abstraction Passing}

Encoding the constructs for recursion present in $\sessp$ as process-passing
communication requires to follow the fundamental
principle of copying the process that needs to exhibit recursive behaviour.
The primitive recursor operation creates copies of a process and uses them
as continuations.

We use an example to demostrate our basic intuitions:
%
\begin{example}
	Assume process:
%
	\begin{eqnarray}
		\label{ex:rec1}
		\recp{X}{\bout{n}{m} \rvar{X}} \scong \bout{n}{m} \recp{X}{\bout{n}{m} \rvar{X}} 
	\end{eqnarray}
%
	\noi The above process emits to its environment infinitely many send actions of channel $m$ along channel $n$.
	Name $n$ includes the recursive
	variable $\rvar{X}$, so the type for $n$ should be recursive.
%
	\[
		\recp{X}{\bout{n}{m} \rvar{X}} \by{\bactout{n}{m}} \recp{X}{\bout{n}{m} \rvar{X}}
	\]
%
	To get a better understanding of how name $n$ is handled
	on such scenarios, consider the process:
	\[
		P \scong \newsp{a}{\bout{a}{n} \inact \Par \recp{X}{\binp{a}{x} \bout{x}{m} (\bout{a}{x} \inact \Par \rvar{X})}}
		%\red \newsp{a}{\bout{n}{m} (\bout{a}{n} \inact \Par \recp{X}{\binp{a}{x} \bout{x}{m} (\bout{a}{x} \inact \Par \rvar{X}))}}
	\]
%
	\noi The above process exhibits the same behaviour as
	process~\ref{ex:rec1}.
	Endpoint $n$ is being passed sequentially on copies of the 
	same process to achieve the effect of infinite sending of value $m$.
%
	\begin{eqnarray*}
		P	&\scong&	\newsp{a}{\bout{a}{n} \inact \Par \recp{X}{\binp{a}{x} \bout{x}{m} (\bout{a}{x} \inact \Par \rvar{X})}}\\
			&\red&		\newsp{a}{\bout{n}{m} (\bout{a}{n} \inact \Par \recp{X}{\binp{a}{x} \bout{x}{m} (\bout{a}{x} \inact \Par \rvar{X}))}}\\
			&\by{\bactout{n}{m}}& \newsp{a}{\bout{a}{n} \inact \Par \recp{X}{\binp{a}{x} \bout{x}{m} (\bout{a}{x} \inact \Par \rvar{X})}}\\
			&\scong&	P
	\end{eqnarray*}
%
	\noi If we want to apply the same principles on higher order semantics we should first
	abstract the recursive process:
%
	\[
		\recp{X}{\binp{a}{x} \bout{x}{m} ( \rvar{X} \Par \bout{a}{x} \inact)}
	\]
%
	\noi as
%
	\[
		V \scong (z) \bout{n}{m} \binp{z}{X} \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\abs{z}{\appl{X}{z}}} \inact}
	\]
%
	So the entire process can be written as:
	\[
		P \scong \newsp{s_1}{\bout{s_1}{V} \inact \Par \binp{\dual{s_1}}{X} \newsp{s_2}{\appl{X}{s_2} \Par \bout{\dual{s_2}}{\abs{z}{\appl{X}{z}}} \inact}}	
	\]
%
	\noi where abstraction $V$ is copied and passed to itself
	infinitely many times:
	\[
		\begin{array}{rcl}
			P &\scong& \newsp{s_1}{\bout{s_1}{V} \inact \Par \binp{\dual{s_1}}{X} \newsp{s_2}{\appl{X}{s_2} \Par \bout{\dual{s_2}}{\abs{z}{\appl{X}{z}}} \inact}} \\
			&\red&
			\newsp{s_2}{\bout{\dual{s_2}}{V} \inact \Par \bout{n}{m} \binp{s_2}{X} \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{{z}{\appl{X}{z}} \inact}}}\\
			&\by{\bactout{n}{m}}&
			\newsp{s_2}{\bout{\dual{s_2}}{V} \inact \Par \binp{s_2}{X} \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\abs{z}{\appl{X}{z}} \inact}}}\\
			&\scong_\alpha&
			P
		\end{array}
	\]
%

	\noi In the typing setting, abstraction $V$ has a linear type:
	\[
		m: U; \es; n: \btout{U} S_1 \tinact \proves
		(z) \bout{n}{m} \binp{z}{X} \newsp{s_2}{\appl{X}{s_2} \Par \bout{\dual{s_2}}{\abs{z{\appl{X}{z}} } \inact} \hastype
		\lhot{S_2}
	\]
	because of the free occurence of session channel $n$ in $V$,
	i.e.\ we cannot apply typing rule $\trule{Prom}$ to the latter
	judgement.

	\noi But when passed, abstraction $V$ is applied in a shared manner, i.e.\ two
	copies of the abstraction are instantiated, thus the whole
	encoding is untypable: 
	\[
		\Gamma; X: \lhot{S_2}; \es \not\proves \newsp{s_2}{\appl{X}{s_2} \Par \bout{\dual{s_2}}{\abs{z} \appl{X}{z}}} \inact}
	\]
%
	\noi The untypability problem would not exist
	provided that the abstraction being passed were not linear.

	\noi A typable solution of the above example would be first to
	define a shared abstraction by replacing the free
	occurence of session name $n$ with an abstraction variable:
%
	\[
		V' = (z, x) \bout{x}{m} \binp{z}{X} \newsp{s}{\appl{X}{s, x} \Par \bout{\dual{s}}{\abs{z, x}{\appl{X}{z, x}} } \inact}
	\]
%
	Abstraction $V'$ can be typed using a shared type:
	\[
		\tree{
			m: U_1; \es; \es \proves
			(z, x) \bout{x}{m} \binp{z}{X} \newsp{s}{\appl{X}{s, x} \Par \bout{\dual{s}}{\abs{z, x}{\appl{X}{z, x}} } \inact}
			\hastype \lhot{U_2}
		}{
			m: U_1; \es; \es \proves
			(z, x) \bout{x}{m} \binp{z}{X} \newsp{s}{\appl{X}{s, x} \Par \bout{\dual{s}}{\abs{z, x}{\appl{X}{z, x}} } \inact}
			\hastype \shot{U_2}
		}~~\trule{Prom}
	\]
%
	\noi and the definition and behaviour of the recursive process, becomes:
%
	\begin{eqnarray*}
		P' &\scong&	\newsp{s_1}{\bout{s_1}{V} \inact \Par \binp{\dual{s_1}}{X} \newsp{s_2}{\appl{X}{s_2, n} \Par \bout{\dual{s_2}}{\abs{z,x}{\appl{X}{z,x}}} \inact}}\\
		&\red&		\newsp{s_2}{\bout{\dual{s_2}}{V} \inact \Par \bout{n}{m} \binp{s_2}{X} \newsp{s}{\appl{X}{s, n} \Par \bout{\dual{s}}{\abs{z, x}{\appl{X}{z, x}}} \inact}}\\
		&\by{\bactout{n}{m}}& \newsp{s_2}{\bout{\dual{s_2}}{V} \inact \Par \binp{s_2}{X} \newsp{s}{\appl{X}{s, n} \Par \bout{\dual{s}}{\abs{z, x}{\appl{X}{z, x}}} \inact}}\\
		&\scong_\alpha& P'
	\end{eqnarray*}
%
	\noi Session channel $n$ is passed and applied
	together with the recursive process.
\end{example}

A preliminary tool to encode the $\sessp$ recursion primitives would be to
provide a mapping from processes to processes with no free names.
We require some auxiliary definitions.
%
\begin{definition}\rm 
	Let $\vmap{\cdot}: 2^{\mathcal{N}} \longrightarrow \mathcal{V}^\omega$
	be a map of sequences of names to sequences of variables, defined
	inductively as follows:
%
\[
	\vmap{n} = x_n \qquad \qquad \qquad \vmap{n \cat \tilde{m}} = x_n \cat \vmap{\tilde{m}}
\]
\end{definition}

Given a process $P$, we write $\ofn{P}$ to denote the
\emph{sequence} of free names of $P$, lexicographically ordered.
Intuitively, the following mapping transforms processes
with free session names into abstractions:
%
\begin{definition}\label{d:trabs}\rm
	Let $\sigma$ be a set of session names.
	Define $\auxmapp{\cdot}{\mathsf{v}}{\sigma}: \HOp \to \HOp$  as follows
%
\[
	\begin{array}{rcl}
		\auxmapp{\news{n} P}{\sigma}{\mathsf{v}} &\bnfis& \news{n} \auxmapp{P}{\mathsf{v}}{{\sigma \cat n}}\\
		\auxmapp{\bout{n}{\abs{x}{Q}} P}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\bout{x_n}{\abs{x,\vmap{\ofn{P}}}{\auxmapp{Q}{\mathsf{v}}{\sigma}}} \auxmapp{P}{\mathsf{v}}{\sigma} & n \notin \sigma\\
			\bout{n}{\abs{x,\vmap{\ofn{P}}}{\auxmapp{Q}{\mathsf{v}}{\sigma}}} \auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma
		\end{array}
		\right.
		\\
		\auxmapp{\binp{n}{X} P}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\binp{x_n}{X} \auxmapp{P}{\mathsf{v}}{\sigma} & n \notin \sigma\\
			\binp{n}{X} \auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma
		\end{array}
		\right.
		\\
		\auxmapp{\bsel{n}{l} P}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\bsel{x_n}{l} \auxmapp{P}{\mathsf{v}}{\sigma} & n \notin \sigma\\
			\bsel{n}{l} \auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma
		\end{array}
		\right.
		\\
		\auxmapp{\bsel{n}{l} P}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\bsel{x_n}{l} \auxmapp{P}{\mathsf{v}}{\sigma} & n \notin \sigma\\
			\bsel{n}{l} \auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma
		\end{array}
		\right.
		\\
		\auxmapp{\bout{n}{m} P}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
		    \bout{n}{m}\auxmapp{P}{\mathsf{v}}{\sigma} & n, m \in \sigma \\
		    \bout{x_n}{m}\auxmapp{P}{\mathsf{v}}{\sigma} & n \not\in \sigma, m \in \sigma \\
		    \bout{n}{x_m}\auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma, m \not\in \sigma \\
		    \bout{x_n}{x_m}\auxmapp{P}{\mathsf{v}}{\sigma} & n, m \not\in \sigma 
		\end{array}
		\right.
		\\
		\auxmapp{\binp{n}{x}P}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
		    \binp{n}{x}\auxmapp{P}{\mathsf{v}}{\sigma} & n \in \sigma \\
		    \binp{x_n}{x}\auxmapp{P}{\mathsf{v}}{\sigma} & n \not\in \sigma 
		\end{array}
		\right.
		\\
		\auxmapp{\appl{\X}{n}}{\mathsf{v}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\appl{\X}{x_n} & n \notin \sigma\\
			\appl{\X}{n} & n \in \sigma\\
		\end{array}
		\right. 
%		\auxmapp{\inact}{\mathsf{v}}{\sigma} &\bnfis& \inact\\
%		\auxmapp{P \Par Q}{\mathsf{v}}{\sigma} &\bnfis& \auxmapp{P}{\mathsf{v}}{\sigma} \Par \auxmapp{Q}{\mathsf{v}}{\sigma} 
	\end{array}
\]
and homomorphically for inaction and parallel composition.
\end{definition}

Given a process $P$ with $\ofn{P} = m_1, \cdots, m_n$, we are interested in its associated (polyadic) abstraction, which is defined as
$\abs{x_1, \cdots, x_n}{\auxmapp{P}{\mathsf{v}}{\es} }$, where $\vmap{m_j} = x_j$, for all $j \in \{1, \ldots, n\}$.
This transformation from processes into abstractions can be reverted by
using abstraction and application with an appropriate sequence of session names:
%
\begin{proposition}\rm
	Let $P$ be a \HOp process with $\tilde{n} = \ofn{P}$.
	Also, suppose $\tilde{x} = \vmap{\tilde{n}}$.
%	Also, let $A_P$ be the polyadic abstraction $\abs{\tilde{x}}\auxmapp{P}{\mathsf{v}}{\emptyset}$ (cf. Def.~\ref{d:trabs}).
	Then $P \scong \appl{X}{\tilde{n}}\subst{\abs{\tilde{x}}\auxmapp{P}{\mathsf{v}}{\emptyset}}{X}$.
%	$\appl{X}{\smap{\fn{P}}} \subst{(\vmap{\fn{P}}) \map{P}^{\emptyset}}{X} \scong P$
\end{proposition}

\begin{proof}
	The proof is an easy induction on the map $\auxmapp{P}{\mathsf{v}}{\es}$.
	We give a case since other cases are similar.

	\noi - Case: $\auxmapp{\bout{n}{m} P}{\mathsf{v}}{\es} = \bout{x_n}{x_m} \auxmapp{P}{\mathsf{v}}{\es}$

	\noi We rewrite process substitution as:
	$\appl{X}{\tilde{n}} \subst{\abs{\tilde{x}}{\bout{x_n}{y_m} \auxmapp{P}{\mathsf{v}}{\es}}}{X} = (\bout{x_n}{y_m} P) \subst{\tilde{x}}{\tilde{n}}$

	\noi If consider that $x_n, y_m \in \vmap{\tilde{n}}$ then from the definition of $\vmap{\cdot}$ we
	get that $n, m \in \tilde{n}$. Furthermore by the fact that $\tilde{n}$ and $\vmap{\tilde{n}}$ are
	ordered, substitution becomes:
	$\bout{n}{m} \auxmapp{P}{\mathsf{v}}{\es} \subst{\tilde{x}}{\tilde{n}}$.

	\noi The rest of the cases are similar.
	\qed
\end{proof}

We are now ready to define the encoding of $\sessp$
(including constructs for recursion) into strict process-passing.
Thanks to the encoding in \S\,\ref{ss:polmon}, we may use polyadicity in abstraction and application only
as syntactic sugar.
For the sake of completeness, we give again the encodings for 
finite processes and types, as
formalized by $\encod{\cdot}{\cdot}{1}: \sessp^{-\mu} \to \HO$.

\begin{definition}[From $\sessp$ to $\HO$]\rm
	Let $f$ be a function from recursion variables to sequences of name variables.
	Define $\fencod{\cdot}{\cdot}{2}{f}: \sessp \to \HO$ as
%
\[
	\begin{array}{rcll}
%	\map{\rec{X}{P}}^{2} &=& \newsp{s}{\binp{s}{\X} \map{P}^{2} \Par \bout{\dual{s}}{\abs{z \cat \vmap{\fn{P}}}{\binp{z}{\X} \map{P}^{\es}}} \inact}\\
%	\map{r}^{2} &=& \newsp{s}{\appl{\X}{s \cat \smap{\fn{P}}} \Par \bout{\dual{s}}{ \abs{z \cat \vmap{\fn{P}}}{\appl{X}{z \cat \vmap{\fn{P}}}}} \inact} \\
		\pmapp{\recp{X}{P}}{2}{f} &\defeq&
		\newsp{s}{\binp{s}{\X} \pmapp{P}{2}{{f,\{\rvar{X}\to \tilde{n}\}}} \Par \bout{\dual{s}}{\abs{\vmap{\tilde{n}}, z } \,{\binp{z}{\X} \auxmapp{\pmapp{P}{2}{{f,\{\rvar{X}\to \tilde{n}\}}}}{\mathsf{v}}{\es}}} \inact} & \quad \tilde{n} = \ofn{P} \\ 
		\pmapp{\rvar{X}}{2}{f} &\defeq& \newsp{s}{\appl{\X}{\tilde{n}, s} \Par \bbout{\dual{s}}{ \abs{\vmap{\tilde{n}},z}\,\,{\appl{X}{ \vmap{\tilde{n}}, z}}} \inact} & \quad \tilde{n} = f(\rvar{X}) \\
		\pmapp{\bout{k}{n} P}{2}{f}	&\defeq&	\bout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{n}} } \pmapp{P}{2}{f} \\
		\pmapp{\binp{k}{x} Q}{2}{f}	&\defeq&	\binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\abs{x}{\pmapp{Q}{2}{f}}} \inact} \\
		\tmap{\btout{S_1} {S} }{2}	&\defeq&	\bbtout{\lhot{\btinp{\lhot{\tmap{S_1}{2}}}\tinact}} \tmap{S}{2}  \\
		\tmap{\btinp{S_1} S }{2}	&\defeq&	\bbtinp{\lhot{\btinp{\lhot{\tmap{S_1}{2}}}\tinact}} \tmap{S}{2} \\
		\tmap{\bbtout{\chtype{S_1}} {S} }{2}	&\defeq&	\bbtout{\shot{\btinp{\shot{\chtype{\tmap{S_1}{2}}}}\tinact}} \tmap{S}{2}  \\
		\tmap{\bbtinp{\chtype{S_1}} {S} }{2}	&\defeq&	\bbtinp{\shot{\btinp{\shot{\chtype{\tmap{S_1}{2}}}}\tinact}} \tmap{S}{2}
	\end{array}
\]
%
and as a homomorphism for the other process constructs. 
\end{definition}

\begin{remark}\rm
	Furthermore we define a mapping for environments $\Gamma$, as follows:
	\[
		\tmap{\Gamma \cat \rvar{X}:\Sigma}{2} = \tmap{\Gamma}{2} \cat X:\shot{(\tilde{S}_{\Sigma}, S^*)}
		%X:\trec{t}{\big(\shot{(\tilde{S}_{\Sigma}, \btinp{\vart{t}}\tinact)}\big)}
	\]
	where
	$S^* = \trec{t}{\big((\tilde{S}_{\Sigma}, \btinp{\vart{t}}\tinact)\big)}$
	and
	$\tilde{S}_{\Sigma} = S_1, \ldots, S_m$ for any $\Sigma = \{n_1:S_1, \ldots, n_m:S_m\}$.
\end{remark}

\begin{proposition}\rm
	Encoding $\fencod{\cdot}{\cdot}{2}{f}: \sessp \to \HO$  
	is type-preserving (cf. Def.~\ref{def:ep}\,(1)).
\end{proposition}

\begin{proof}
	Proof in Appendix~\ref{app:enc_sesp_to_HO}.
	\qed
\end{proof}

\begin{proposition}\rm
	Encoding $\fencod{\cdot}{\cdot}{2}{f}: \sessp \to \HO$ 
	enjoys operational correspondence (cf. Def.~\ref{def:ep}\,(2)).
\end{proposition}

\begin{proof}[Sketch]
	Proof in Appendix~\ref{app:enc_sesp_to_HO}.
	\dk{TBD.}
	\qed
\end{proof}

\subsection{From $\HO$ to $\sessp$}

We now discuss the encodability of  $\HO$ into $\sessp$, 
i.e., how to encode a higher-order calculus with abstraction passing only
into a calculus with name passing only. 
We essentially follow the representability result put forward by 
Sangiorgi~\cite{San92,SaWabook}, but casted in the setting of session-typed communications. 
As we shall see, linearity of session endpoints will play a role in adaptating Sangiorgi's 
encodability strategy into a typed setting. 
Intuitively, such a strategy represents the exchange of a process with the exchange of 
a \emph{trigger}---a freshly generated names. 
Triggers may then be used to activate copies of the process, which now becomes a persistent 
resource represented by an input-guarded replication. In session-based communication, a session name 
is a linear resource and cannot be replicated. Consider the following (naive) adaptation of 
Sangiorgi's strategy in which session names are used are triggers and exchanged processes would be have to used exactly once:
%\begin{definition}[From $\HO$ to $\sesp$. Naive approach]
\[
	\begin{array}{lcl}
		\pmap{\bout{k}{\abs{x}{P_1}} Q}{n} & \defeq &  \newsp{s}{\bout{k}{s} (\pmap{Q}{n} \Par \binp{\dual{s}}{x} \pmap{P_1}{n})} \\
		\pmap{\binp{k}{X} P}{n} & \defeq& \binp{k}{x} \pmap{P}{n}\\
		\pmap{\appl{X}{k}}{n} & \defeq & \bout{x}{k} \inact
	\end{array}
	\]
%\end{definition}
%
%\begin{proposition}
%	Let $\Gamma;\emptyset;\Sigma \proves P \hastype \Proc$ with
%	the typing derivation to use only linear session types. Then
%	$\map{P}^8$ respects the properties of definition~\ref{def:ep}.
%\end{proposition}
%
%\begin{proof}
%	\dk{TODO}
%\end{proof}
(The mapping $\pmap{\cdot}{n}$ would be defined homomorphically for the remaining $\HO$ constructs.)
Although $\pmap{\cdot}{n}$ captures the correct semantics when
dealing with systems that allow only linear process variables,
it suffers from non-typability in the presence
of shared process variables. For instance,
let $P = \bout{n}{\abs{x}{\bout{x}{m}\inact}} \inact \Par \binp{\dual{n}}{X} (\appl{X}{s_1} \Par \appl{X}{s_2})$.
We would have
\[
	\pmap{P}{n} \defeq
	\newsp{s}{\bout{n}{s} \binp{\dual{s}}{x} \bout{x}{m} \inact \Par \binp{\dual{n}}{x} (\bout{x}{s_1} \inact \Par \bout{x}{s_2} \inact)}
\]
The above process is non typable since processes $(\bout{x}{s_1} \inact$ and $\bout{x}{s_2} \inact)$
cannot be put in parallel because they do not have disjoint session environments.

The correct approach would be to use replicated shared names
as triggers instead of session names. 
Below we write $\repl{} P$ as a shorthand notation for $\recp{X}{(P \Par \rvar{X})}$.

\begin{definition}[From $\HO$ to $\sessp$]\rm
	Define $\encod{\cdot}{\cdot}{3}: \HO \to \sessp$ as follows
	\[
	\begin{array}{rcl}
		\pmap{\bout{k}{\abs{x}{Q}} P}{3} & \defeq &  \left\{
		\begin{array}{ll}
			\newsp{a}{\bout{k}{a} (\pmap{P}{3} \Par \binp{a}{y} \binp{y}{x} \pmap{Q}{3})\,} & \dk{Q \textrm{ linear}} \\
			\newsp{a}{\bout{k}{a} (\pmap{P}{3} \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{3})\,} & \textrm{otherwise}
		\end{array}
		\right.
		\\
		\pmap{\binp{k}{X} P}{3} &\defeq&  \binp{k}{x} \pmap{P}{3}\\
		\pmap{\appl{X}{k}}{3} & \defeq & \newsp{s}{\bout{x}{s} \bout{\dual{s}}{k} \inact}\\
		\tmap{\btout{\lhot{S}}S_1}{3} & \defeq & \bbtout{\chtype{\btinp{\tmap{S}{3}}\tinact}}\tmap{S_1}{3} \\
		\tmap{\btinp{\lhot{S}}S_1}{3} & \defeq & \bbtinp{\chtype{\btinp{\tmap{S}{3}}\tinact}}\tmap{S_1}{3}
	\end{array}
	\]
\end{definition}

\begin{proposition}\rm
	Encoding $\encod{\cdot}{\cdot}{3}: \HO \to \sessp$  is type-preserving (cf. Def.~\ref{def:ep}\,(1)).
\end{proposition}

\begin{proof}
	Proof in Appendix~\ref{app:enc_HO_to_sessp}.
	\qed
\end{proof}

\begin{proposition}\rm
	Encoding $\encod{\cdot}{\cdot}{3}: \HO \to \sessp$ 
	enjoys operational correspondence (cf. Def.~\ref{def:ep}\,(2)).
\end{proposition}

\begin{proof}
	Proof in Appendix~\ref{app:enc_HO_to_sessp}.
	\qed
\end{proof}

\begin{comment}
\begin{proof}[Sketch]
For completeness, we 
consider the \HO process $P = {\bbout{k}{\abs{x} Q} P_1} \Par \binp{k}{X} P_2$. We have that
\[
P \red P_1 \Par P_2 \subst{\abs{x}Q}{X}
\]
In the target language, this reduction is mimicked as follows:
\begin{eqnarray*}
\pmap{P}{2} & = & \newsp{a}{\bout{k}{a} (\pmap{P_1}{3} \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{3})\,} 
                  \Par \binp{k}{x} \pmap{P_2}{3} \\
            & \red & \newsp{a}{\pmap{P_1}{3} \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{3} 
                  \Par  \pmap{P_2}{3}\subst{a}{x}}
\end{eqnarray*}
\qed
\end{proof}
\end{comment}


At this point an open  question would be if we could find an encoding that maps
session names to session names without the creation of shared names.

\dk{put intuition??}

