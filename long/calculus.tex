% !TEX root = main.tex

\section{The Full Higher-Order Session $\pi$-Calculus (\HOp)}

We introduce the {\em Full Higher-Order Session $\pi$-calculus}
($\HOp$ in the following).
$\HOp$ features constructs for both name- and abstraction-passing;
it corresponds to a sub-calculus 
of the higher-order language studied by Mostrous and Yoshida in~\cite{tlca07}.
Although minimal, in \S\ref{s:expr}
the abstraction-passing capabilities of \HOp will prove 
expressive enough to capture key features of session communication, 
such as delegation and recursion.

{\bf Syntax:}
The syntax for $\HOp$ processes is given in Figure~\ref{fig:syntax}.
We assume a set of names $N$, defined as $N = S \cup \dual{S}$.
We use $a,b,c, \dots, m, n, \dots, s, t, \dots$ 
and $\dual{a}, \dots, \dual{m}, \dual{s}, \dots$
to range over elements of $S$ and $\dual{S}$, respectively.
Intuitively, names $n$ and $\dual{n}$ are dual \emph{endpoints}.
Note that $N$ includes both session and shared names:
we often use  $a,b, \dots$ to denote shared names.
Name variables $x, y,  \dots$, 
process variables $X, Y,  \dots$,
and recursive variables $\rvar{X}, \dots$ 
are taken from sets $\mathsf{Var}$, $\mathsf{PVar}$, and $\mathsf{RVar}$, respectively. 
An abstraction $\abs{x}{P}$ is a process $P$ with a bound parameter $x$;
$\mathsf{Abs}$ denotes the set of all abstractions.
We denote either names or name variables with $k, k', \dots$.
We write $V, V', \ldots$ to denote 
transmittable \emph{values}, i.e., 
polyadic names and name variables, process variables, or abstractions.

The name-passing construcsts of \HOp include the
standard $\pi$-calculus prefixes for sending and receiving names,
as defined in line 1 of Figure~\ref{fig:syntax}.
Process $\bout{k}{k'} P$ denotes the output of name $k'$ over channel $k$,
with continuation $P$;
process $\binp{k}{x} P$ denotes the input along  of a value
on channel $k$ over variable $x$, with continuation $P$. 
Recursion is expressed by the primitive recursor $\recp{X}{P}$,
which binds the recursive variable $r$ in process $P$.
The abstraction-passing constructs of \HOp are presented in line
2 of Figure~\ref{fig:syntax} and include 
the output prefix $\bout{k}{\abs{x}{Q}} P$, which 
sends out abstraction $\abs{x}{Q}$ over channel $k$ and then continues as $P$. 
Process $\binp{k}{X} P$ denotes the reception of an abstraction
on channel $k$ and over the process variable $\X$.
Process $\appl{X}{k}$ is the application
process which is used to bind channel $k$ on the process
substituting process variable $\X$.

In line 3 of Figure~\ref{fig:syntax} we can define the usual session
constructs for $n$-ary labeled choice.
Process $\bsel{k}{l} P$ selects label $l$ on channel $k$ and then behaves as $P$. 
Given $i \in I$, 
process $\bbra{k}{l_i:P_i}_{i \in I}$ offers a choice on labels $l_i$ with
continuation $P_i$.
The calculus also includes standard constructs for 
inaction $\inact$, 
parallel composition $P_1 \Par P_2$, and 
name restriction $\news{s} P$, which simultaneously binds endpoints $s$ and $\dual{s}$ in $P$.

In lines 4 and 5 of Figure~\ref{fig:syntax} \HOp is extended with polyadicidy;
In line 4 we define the standard polyadic name passing where we allow 
list of names to be send and received as messages. 
Line 5 extends the calculus with polyadic abstractions and applications,
where we allow for a process to be abstracted on a list of
bound variables and dualy we can apply a list of names
over a polyadic abstraction.

A well-formed process relies on assumptions for guarded recursive processes.
A \emph{program} is a process without free 
recursion variables nor free name/process variables.

\input{figures/fig-syntax}

{\bf Sub-calculi:}
Two significant sub-calculi of $\HOp$ will form the basis of our study:
%
\begin{enumerate}[-]
	\item	The sub-calculus \sesp involves only name-passing constructs; it is 
		defined by lines (1) and (3) of the syntax in Figure~\ref{fig:syntax}.

	\item	The sub-calculus \HO features abstraction passing and application but no name-passing; 
		it is defined by lines (2) and (3) of the same syntax.
\end{enumerate}
%
Thus, while \sesp is essentially a standard session $\pi$-calculus as defined in the literature~\cite{},
\HO can be related to core higher-order process calculi whole expressiveness in untyped and typed settings
has been studied in, e.g.,~\cite{}. We can also assume the extensions for \sesp and \HO with their
polyadic variance as defined in lines 4 and 5 respectively.


{\bf Operational Semantics:}
The operational semantics for \HOp is given as a fairly standard reduction relation, supported by
a \emph{structural congruence}, denoted $\scong$. This is 
the least congruence that satisfies the commutative monoid $(\Par, \inact)$:
%
\[
	\begin{array}{c}
		P \Par \inact \scong P
		\qquad
		P_1 \Par P_2 \scong P_2 \Par P_1
		\qquad
		P_1 \Par (P_2 \Par P_3) \scong (P_1 \Par P_2) \Par P_3
	\end{array}
\]
%
\noi and furthermore satisfies the rules:
%
\[
\begin{array}{c}
	\news{s} \inact \scong \inact
	\qquad
	s \notin \fn{P_1} \textrm{  implies  } P_1 \Par \news{s} P_2 \scong \news{s}(P_1 \Par P_2)
	\qquad
	\recp{X}{P} \scong P\subst{\recp{X}{P}}{\rvar{X}}
\end{array}
\]
%
\noi Figure~\ref{fig:reduction} defines
process variable substitution (Upper Part) and gives the 
reduction semantics (Lower part).
Both relations are defined in terms of polyadic semantics since
monadic semantics are included in polyadicity.
Substitution of application process $\appl{X}{\tilde{k}}$
over abstraction $\abs{\tilde{x}} Q$ substitutes free variables
$\tilde{x}$ in $Q$ with name $\tilde{k}$ and replaces
$X$ with the resulting process.
There is no effect on variable substitution for the inactive process.
In all other cases process variable substitution is defined
homorphically on the structure of the process.

\input{figures/fig-reduction}

There are three communication rules for $\HOp$. 
Rule~$\orule{NPass}$ defines name passing 
of channels $\tilde{m}$ on channel $n$ to its dual endpoint $\dual{n}$.
As a result of reduction the continuation of the 
latter process substitutes the receiving prefix variables $\tilde{x}$
with $\tilde{m}$.
Rule~$\orule{APass}$ describes
the passing of an abstraction $\abs{\tilde{x}}P_1$
along channel $n$;
the reception happens along a $\dual{n}$-prefixed process that
leads to a process variable substitution as explained above.
Rule~$\orule{Sel}$ is the standard rule for labeled choice/selection:
given an index set $I$, 
a process selects label $l_j, j \in I$ on channel $n$ over a set of
labels $\set{l_i}_{i \in I}$ that are offered by a parallel process
on the dual session endpoint $\dual{n}$.
The resulting continuation is associated process $P_j$.
Remaining rules define congruence 
with respect to parallel composition (rule $\orule{Par}$)
and name restriction (rule $\orule{Ses}$).
Rule $\orule{Cong}$ defines closure under structural congruence.



