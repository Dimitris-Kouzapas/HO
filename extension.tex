\section{Extensions}

\[
	\begin{array}{rclcl}
		P &\bnfis&	\dots\\
		&\bnfbar&	\bout{k}{k'} P & & \textrm{Name passing}\\
		&\bnfbar&	\binp{k}{x} P & & \textrm{Receive name}\\		
		&\bnfbar&	\bout{k}{\tilde{k}} P & & \textrm{Polyadic send}\\
		&\bnfbar&	\binp{k}{\tilde{x}} P & & \textrm{Polyadic receive}\\
		&\bnfbar&	\bout{k}{\abs{\X} P_1} P_2 & & \textrm{Process Abstraction}\\
		&\bnfbar&	\appl{X}{\abs{x}{P}} & & \textrm{Process Application} \\
		&\bnfbar&	\bout{k}{\abs{\tilde{x}}{P_1}} P_2 & & \textrm{Polyadic Abstraction}\\
		&\bnfbar&	\appl{X}{\tilde{k}} & & \textrm{Polyadic Application}
	\end{array}
\]

\dk{give semantics}

\subsection{Encoding}

\[
	\begin{array}{rcl}
		\map{\bout{k}{k'} P}	&\bnfis&	\bout{k}{ \abs{z}{\binp{z}{X} \appl{X}{k'}} } \map{P} \\
		\map{\binp{k}{x} P}	&\bnfis&	\binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\abs{x} \map{P}} \inact}\\

		\map{\bout{k}{k' \cat \tilde{k}} P}	&\bnfis&	\map{\bout{k}{k'} \bout{k}{\tilde{k}} P}\\
		\map{\binp{k}{x \cat \tilde{x}} P}	&\bnfis&	\map{\binp{k}{x} \binp{k}{\tilde{x}} P}\\

		\map{\bout{k}{\abs{\X} Q} P}	&\bnfis&	\bout{k}{\abs{z} \binp{z}{\X} \map{Q}} \map{P}\\
		\map{\appl{X}{\abs{x} P}}	&\bnfis&	\newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\abs{x}{\map{P}}} \inact}\\

		\map{\bout{k}{\abs{\tilde{x}}{P_1}} P_2}	&\bnfis&	\bout{k}{ \abs{z}{ \map{ \binp{z}{\tilde{x}} P_1} } } \map{P_2}\\
		\map{\appl{\X}{\tilde{k}}}			&\bnfis&	\newsp{s}{\appl{\X}{s} \Par \map{\bout{\dual{s}}{\tilde{k}} \inact}}\\

		&\dots& \textrm{\dk{the rest isomorphic}}
	\end{array}
\]

\subsection{Operational Correspondence}

\[
	\begin{array}{rcl}
		\bout{s}{k'} P_1 \Par \binp{s}{x} P_2 &\red& P_1 \Par P_2 \subst{k'}{x}\\
		\bout{s}{\abs{\Y} P} P_1 \Par \binp{s}{\X} \appl{\X}{\abs{x}{P_2}} &\red& P_1 \Par P \subst{\abs{x}{P_2}}{\Y}\\
		\bout{s}{\abs{\tilde{x}} P_1} P_2 \Par \binp{s}{\X} \appl{\X}{\tilde{k}} &\red& P_2 \Par P_1\subst{\tilde{k}}{\tilde{x}}
	\end{array}
\]

\[
	\begin{array}{rcl}
		\map{\bout{s}{k'} P_1 \Par \binp{s}{x} P_2} &\bnfis& \bout{s}{ \abs{z}{\binp{z}{X} \appl{X}{k'}} } \map{P_1} \Par \binp{s}{X} \newsp{s'}{\appl{X}{s'} \Par \bout{\dual{s'}}{\abs{x} \map{P_2}} \inact}\\
		&\red& \map{P_1} \Par \newsp{s'}{\binp{s}{X} \appl{X}{k'} \Par \bout{\dual{s'}}{\abs{x} \map{P_2}} \inact}\\
		&\red& \map{P_1} \Par \map{P_2}\subst{k'}{x}
		\\
		\\

		\map{\bout{s}{\abs{\Y} P} P_1 \Par \binp{s}{X} \appl{X}{\abs{x}{P_2}}} &\bnfis& \bout{s}{\abs{z} \binp{z}{\Y} \map{P}} \map{P_1} \Par \binp{s}{X} \newsp{s'}{\appl{X}{s'} \Par \bout{\dual{s'}}{\abs{x}{\map{P_2}}} \inact}\\
		&\red& \map{P_1} \Par \newsp{s'}{\binp{s'}{\Y} \map{P} \Par \bout{\dual{s'}}{\abs{x}{\map{P_2}}} \inact}\\
		&\red& \map{P_1} \Par \map{P} \subst{\abs{x} \map{P_2}}{\Y}
		\\
		\\

		\map{\bout{s}{\abs{\tilde{x}}{P_1}} P_2 \Par \binp{s}{\X} \appl{\X}{\tilde{k}}} &\bnfis& \bout{s}{\abs{z}{\map{\binp{z}{\tilde{x}} P_1}}} \map{P_2} \Par \binp{s}{\X} \newsp{s'}{\appl{\X}{s'} \Par \map{\bout{\dual{s}}{\tilde{k}} \inact}} \\
		&\red& \map{P_2} \Par \newsp{s'}{\map{\binp{s'}{\tilde{x}} P_1} \Par \map{\bout{\dual{s}}{\tilde{k}} \inact}}\\
		&\red^*& \map{P_2} \Par \map{P_1} \subst{\tilde{k}}{\tilde{x}}
	\end{array}
\]


\subsection{Encode Processes to non Linear Abstractions}

Processes with free sessions can only be used as linear abstractions.
As we have seen in Example~\ref{ex:linear_abstraction} a process:
\[
	\bout{s}{\abs{}{P}} P_1 \Par \binp{s}{\X} (\appl{\X}{} \Par \appl{\X}{})
\]

with $\fs{P} \not= \es$ is not typable since abstraction $\abs{}{P}$
can only be used in a linear way.


It is convenient to have an encoding from a process to an abstraction
with no free names, that can be used a shared value:

\[
	\amap{P} \bnfis \abs{\vmap{\fn{P}}}{\absmap{P}{\es}}
\]

where

Function $\smap{\cdot}: 2^{\mathcal{N}} \longrightarrow \mathcal{N}^\omega$
orders lexicographically a set of names, function 
$\vmap{\cdot}: 2^{\mathcal{N}} \longrightarrow \mathcal{V}^\omega$
maps a set of names to variables:
\[
	\begin{array}{rcl}
		\vmap{\set{s_i}_{i \in I}} &=& \svmap{\smap{\set{s_i}_{i \in I}}}\\
		\svmap{s \cat \tilde{s}} &=& x_s \cat \svmap{\tilde{s}}\\
		\svmap{s} & = & x_s
	\end{array}
\]

\[
	\begin{array}{rcll}
		\absmap{\bout{s}{\abs{x} P'} P}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\bout{x_s}{\abs{\vmap{x}{P}} \absmap{P'}{\es}} \absmap{P}{\sigma} & s \notin \sigma\\
			\bout{s}{\abs{\vmap{x}{P}} \absmap{P'}{\es}} \absmap{P}{\sigma} & s \in \sigma
		\end{array}
		\right.
		\\
		\absmap{\binp{s}{X} P}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\binp{x_s}{X} \absmap{P}{\sigma} & s \notin \sigma\\
			\binp{s}{X} \absmap{P}{\sigma} & s \in \sigma
		\end{array}
		\right.
		\\
		\absmap{\bsel{s}{l} P}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\bsel{x_s}{l} \absmap{P}{\sigma} & s \notin \sigma\\
			\bsel{s}{l} \absmap{P}{\sigma} & s \in \sigma
		\end{array}
		\right.
		\\

		\absmap{\bbra{s}{l_i: P_i}_{i \in I}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\bbra{x_s}{l_i: \absmap{P_i}{\sigma}}_{i \in I} & s \notin \sigma\\
			\bbra{s}{l_i: \absmap{P_i}{\sigma}}_{i \in I} & s \in \sigma\\
		\end{array}
		\right.
		\\

		\absmap{P_1 \Par P_2}{\sigma} &\bnfis& \absmap{P_1}{\sigma} \Par \absmap{P_2}{\sigma} & s \notin \sigma\\
		\absmap{\news{s} P}{\sigma} &\bnfis& \news{s} \absmap{P}{\sigma\cat s}\\
		\absmap{\inact}{\sigma} &\bnfis& \inact\\
		\absmap{\appl{\X}{s}}{\sigma} &\bnfis&
		\left\{
		\begin{array}{rl}
			\appl{\X}{x_s} & s \notin \sigma\\
			\appl{\X}{s} & s \in \sigma\\
		\end{array}
		\right.
	\end{array}
\]

\subsection{Encode Recursion}

\[
	\begin{array}{rcl}
		P &\bnfis& \dots \\
		&\bnfbar& \rec{r}{P}\\
		&\bnfbar& \varp{r}
	\end{array}
\]

\[
\begin{array}{rcl}
	\map{\rec{r}{P}} &=& \newsp{s}{\binp{s}{\X} \map{P} \Par \bout{\dual{s}}{\abs{z \cat \vmap{\fn{P}}}{\binp{z}{\X} \absmap{P}{\es}}} \inact}\\
	\map{\varp{r}} &=& \newsp{s}{\appl{\X}{s \cat \smap{\fn{P}}} \Par \bout{\dual{s}}{ \abs{z \cat \vmap{\fn{P}}}{\appl{X}{z \cat \vmap{\fn{P}}}}} \inact}
\end{array}
\]

\subsection{Operational Correspondence for Recursion}

\dk{todo}

\subsection{Typing}

We type the encodings:

\begin{enumerate}
	\item	$\bout{s}{k} P$

	\[
		\tree{
			\Gamma \proves \map{P} \hastype \Delta \cat s: T
			\qquad
			\tree{
				\tree{
					\Gamma \cat \X: \lhot{T'} \proves \appl{\X}{k} \hastype k:T' \cat X
				}{
					\Gamma \cat \X: \lhot{T'} \proves \appl{\X}{k} \hastype k:T' \cat X \cat z: \tinact
				}
			}{
				\Gamma \proves \binp{z}{\X} \appl{\X}{k} \hastype z: \btinp{\lhot{T'}} \tinact
			}
		}{
			\Gamma \proves \bout{s}{\abs{z}{\binp{z}{\X} \appl{\X}{k}}} \map{P} \hastype s: \Delta \cat s: \btout{\lhot{\btinp{\lhot{T'}} \tinact}} T
		}
	\]

	\item	$\binp{s}{x} P$ with $\Gamma' = \Gamma \cat X : \btinp{\lhot{T'}} \tinact$


		\[
			\tree{
				\tree{
					\tree{
						\Gamma' \proves \appl{\X}{s'} \hastype s': \btinp{\lhot{T'}} \tinact \cat X
						\quad
						\tree{
							\tree{
								\Gamma' \proves \inact \hastype \es
							}{
								\Gamma' \proves \inact \hastype \dual{s'}: \tinact
							}
							\quad
							\Gamma' \proves \map{P} \hastype \Delta \cat x:T' \cat s: T
						}{
							\Gamma' \proves \bout{\dual{s'}}{\abs{x} \map{P}} \inact \hastype \Delta \cat \dual{s'}: \btout{\lhot{T'}} \tinact \cat s: T
						}
					}{
							\Gamma' \proves \appl{\X}{s'} \Par \bout{\dual{s'}}{\abs{x} \map{P}} \inact \hastype \Delta \cat s': \btinp{\lhot{T'}} \tinact \cat \dual{s'}: \btout{\lhot{T'}} \tinact \cat s: T \cat X
					}
				}{
					\Gamma' \proves \newsp{s'}{\appl{\X}{s'} \Par \bout{\dual{s'}}{\abs{x} \map{P}} \inact} \hastype  \Delta \cat s: T \cat X
				}
			}{
				\Gamma \proves \binp{s}{X} \newsp{s'}{\appl{\X}{s'} \Par \bout{\dual{s'}}{\abs{x} \map{P}} \inact} \hastype  \Delta \cat s: \btinp{\lhot{\btinp{\lhot{T'}} \tinact}} T
			}
		\]

	\item	$\bout{s}{\abs{\Y} P_2} P_1$

	\[
		\tree{
			\Gamma \proves \map{P_1} \hastype \Delta_1 \cat s:T
			\qquad
			\tree{
				\tree{
					\Gamma \cat \Y: \hot{T'} \proves \map{P_2} \hastype \Delta_2
				}{
					\Gamma \cat \Y: \hot{T'} \proves \map{P_2} \hastype \Delta_2 \cat z : \tinact
				}
			}{
				\Gamma \proves \binp{z}{\Y} \map{P_2} \hastype \Delta_2\backslash\Y \cat z: \btinp{\hot{T'}} \tinact
			}
		}{
			\Gamma \proves \bout{s}{ \abs{z}{ \binp{z}{\Y} \map{P_2} } } \map{P_1} \hastype \Delta_1 \cat \Delta_2\backslash\Y \cat z: \btout{\hot{\btinp{\hot{T'}} \tinact }} T
		}
	\]

	\item	$\appl{\X}{\abs{x} P}$

	\[
		\tree{
			\tree{
				\Gamma \cat \X: \hot{\btinp{\hot{T'}} \inact} \proves \appl{\X}{s} \hastype \Delta_1 \cat s: \btinp{\hot{T'}} \inact
				\quad
				\tree{
					\Gamma' \proves \map{P} \hastype \Delta_2 \cat x: T'
					\quad
					\tree{
						\Gamma' \proves \inact \hastype \es
					}{
						\Gamma' \proves \inact \hastype \dual{s'}: \tinact
					}
				}{
					\Gamma' \proves \bout{\dual{s}}{\abs{x} P} \inact \hastype \Delta_2 \cat \dual{s}: \btout{\hot{T'}} \tinact
				}
			}{
				\Gamma \cat \X: \hot{\btinp{\hot{T'}} \inact} \proves \appl{X}{s} \Par \bout{\dual{s}}{\abs{x} P} \inact \hastype \Delta_1 \cat \Delta_2 \cat s: \btinp{\hot{T'}} \inact \cat \dual{s}: \btout{\hot{T'}} \tinact
			}
		}{
			\Gamma \cat \X: \hot{\btinp{\hot{T'}} \inact} \proves \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\abs{x} P} \inact} \hastype \Delta_1 \cat \Delta_2
		}
	\]

	\item	$\rec{\varp{r}}{P}$


	\[
		\tree{
			\tree{
				\begin{array}{c}
					\tree{
						\Gamma \cat \X: \shot{\btinp{\shot{T'}} \tinact} \proves \map{P} \hastype \Delta \cat s: T
					}{
						\Gamma \proves \binp{s}{\X} \map{P} \hastype \Delta \cat s: \btinp{\shot{\btinp{\shot{T'}} \tinact}} T
					}
					\\
					\\
					\tree{
						\tree{
							\Gamma \cat \X: \shot{T'} \proves \absmap{P}{\es} \hastype z: \tinact \cat \tilde{y}: \tilde{T}
						}{
							\Gamma \proves \binp{z}{\X} \absmap{P}{\es} \hastype z: \btinp{\shot{T'}} \tinact \cat \tilde{y}: \tilde{T}
						}
						\qquad
						\tree{
							\Gamma \proves \inact \hastype \es
						}{
							\Gamma \proves \inact \hastype \dual{s} : \tinact
						}
					}{
						\Gamma \proves \bout{\dual{s}}{\abs{z\tilde{y}}{ \binp{z}{\X} \absmap{P}{s}}} \inact \hastype \dual{s}: \btout{\shot{\btinp{\shot{T'}} \tinact}} \tinact
					}
				\end{array}
			}{
				\Gamma \proves \binp{s}{\X} \map{P} \Par \bout{\dual{s}}{\abs{z\tilde{y}}{ \binp{z}{\X} \absmap{P}{s}}} \inact \hastype \Delta \cat s: \btinp{\shot{\btinp{\shot{T'}} \tinact}} T \cat \dual{s}: \btout{\shot{\btinp{\shot{T'}} \tinact}} \tinact
			}
		}{
			\Gamma \proves \newsp{s}{\binp{s}{\X} \map{P} \Par \bout{\dual{s}}{\abs{z\tilde{y}}{ \binp{z}{\X} \absmap{P}{s}}} \inact} \hastype \Delta
		}
	\]

	\item	$\map{\varp{r}}$

\end{enumerate}



\begin{comment}
\[
	\begin{array}{rcl}
		\vmap{\tilde{x}}{\inact} &\bnfis& \tilde{x}\\
		\vmap{\tilde{x}}{\bout{s}{\abs{x} P'} P} &\bnfis&
		\left\{
		\begin{array}{ll}
			\vmap{\tilde{x}\cat x_s}{P} & x_s \notin \tilde{x}\\
			\vmap{\tilde{x}}{P} & x_s \in \tilde{x}
		\end{array}
		\right.
		\\
		\vmap{\tilde{x}}{\binp{s}{X} P} &\bnfis&
		\left\{
		\begin{array}{ll}
			\vmap{\tilde{x}\cat x_s}{P} & x_s \notin \tilde{x}\\
			\vmap{\tilde{x}}{P} & x_s \in \tilde{x}
		\end{array}
		\right.
		\\
		\vmap{\tilde{x}}{\bsel{s}{l} P} &\bnfis&
		\left\{
		\begin{array}{ll}
			\vmap{\tilde{x}\cat x_s}{P} & x_s \notin \tilde{x}\\
			\vmap{\tilde{x}}{P} & x_s \in \tilde{x}
		\end{array}
		\right.
		\\


	\end{array}
\]
\end{comment}

%Specifically if:
%\[
%	\absmap{P} \bnfis \abs{\tilde{x}} P'
%\]
%we require the property:
%\[
%	P = P' \subst{\fn{P}}{\tilde{x}}
%\]


