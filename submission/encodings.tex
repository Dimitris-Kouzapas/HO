% !TEX root = main.tex
\newcommand{\enc}[2]{\big\langle\map{#1}, \mapt{#2}\big\rangle}
\newcommand{\encod}[3]{\lrangle{\map{#1}^{#3}, \mapt{#2}^{#3}}}

\newcommand{\calc}[5]{\lrangle{#1, #2, #3, #4, #5}}
\newcommand{\tyl}[1]{\ensuremath{\mathcal{#1}}}

\section{Typed Encodings}

In this section we present a study of the expressiveness 
of the sub-calculi of $\HOp$.

We first define the notion of calculus. We extend notions proposed elsewhere (cf. Gorla) by explicitly
considering a type structure and a type system.

\begin{definition}[Typed Calculus]\label{d:tcalculus}
	A \emph{typed calculus} $\tyl{L}$ is defined as a tuple $$\calc{L}{T}{\red}{\wb}{\proves}$$
	where $L$ and $T$ are sets of processes and types, respectively; %$T_1$ is the set of types;
	$\red$ and $\wb$ denote a reduction semantics 
	and a typed equivalence
	 on processes, respectively. Finally, $\proves$ denotes a type system for processes in $L$.
\end{definition}

We notice that in this paper we shall always consider languages with the same type system.
In the following, when writing $\tyl{L}_i$ we tacitly assume the existence of appropriate 
$L_i$, $T_i$, $\red_i$, $\wb_i$, and $\proves_i$.
We first define the notion of encoding over typed calculi.

\begin{definition}[Typed Encoding]
	Let  $\tyl{L}_1$ % = \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1}$
	and $\tyl{L}_2$ % =  \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$ 
	be typed calculi as in Definition~\ref{d:tcalculus}.
	Given mappings $\map{\cdot}: L_1 \to L_2$ and
	$\mapt{\cdot}: T_1 \to T_2$, 
	we write 
	%$\enc{\cdot}{\cdot}: \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1} \longrightarrow \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$
%	for the encoding from $\calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1}$ to $\calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$.
	$\enc{\cdot}{\cdot} : \tyl{L}_1 \to \tyl{L}_2$ to denote the \emph{typed encoding} of $\tyl{L}_1$ into $\tyl{L}_2$.

\end{definition}

\subsection{Encoding Properties}

We require that a {\em good} encoding should 
preserve not only the syntax but
also the operational, typing and behavioural
semantics. 

\begin{notation}[Typed Equivalence]
Let $P$ and $Q$ be two well-typed processes, i.e., 
there exist $\Gamma, \Sigma_1, \Sigma_2$ such that 
$\Gamma; \emptyset; \Sigma_1 \proves P \hastype \Proc$ 
and
$\Gamma; \emptyset; \Sigma_2 \proves Q \hastype \Proc$.
Then, to denote the fact that 
$P$ and $Q$ are related by behavioral equivalence $\wb$, we shall write
%Then we adopt the following notational convention:
$
\Gamma; \Sigma_1 \circ \Sigma_2 \proves P \wb Q.
$
\end{notation}

\begin{definition}[Good Typed Encodings]
	\label{def:ep}
	We say that $\enc{\cdot}{\cdot} : \tyl{L}_1 \to \tyl{L}_2$ be is a \emph{good  typed encoding} if it satisfies the following properties:
	%Let $\Gamma; \emptyset; \Sigma \proves P \hastype \Proc$ 
	%a process from calculus $\calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1}$
	%and an encoding 
	%$\enc{\cdot}{\cdot}: \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1} \longrightarrow \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$.
	
	\begin{enumerate}[1.]
		\item \emph{Type preservation}:	%We say that $\enc{\cdot}{\cdot}$ is \emph{type preserving}
		if
			$\Gamma; \emptyset; \Sigma \proves_1 P \hastype \Proc$ then $\mapt{\Gamma}; \emptyset; \mapt{\Sigma} \proves_2 \map{P} \hastype \Proc$ for any   $P$ in $L_1$.

		\item \emph{Operational Correspondence}: If $\Gamma; \emptyset; \Sigma \proves_1 P \hastype \Proc$ then
		\begin{enumerate}[-]
			\item	If $P \red_1 P'$ then $\exists \Sigma'$ s.t.
				$\map{P} \Red_2 \map{P'}$ and
				$\mapt{\Gamma}; \emptyset; \mapt{\Sigma'} \proves_2 \map{P'} \hastype \Proc$.
			\item	If $\map{P} \red_2 \map{Q}$ then
				$\exists P'$ s.t. $P \red_1 P'$ and 
				%$\mapt{\Gamma};\emptyset; \mapt{\Sigma_1} \proves_2 \map{Q} \wb_2 \Sigma_2 \proves P' \hastype \Proc$.
				$\mapt{\Gamma}; \mapt{\Sigma_1} \circ \mapt{\Sigma_2} \proves_2 \map{P'} \wb_2 \map{Q}$.
		\end{enumerate}
		
		\item \emph{Full Abstraction:} %whenever:		\\
		%	$\Gamma; \emptyset; \Sigma_1 \proves_1 P_1 \wb_1 \Sigma_2 \proves P_2 \hastype \Proc$ if and only if
		%	$\mapt{\Gamma}; \emptyset; \mapt{\Sigma_1} \proves \map{P_1} \wb \mapt{\Sigma_2} \proves \map{P_2} \hastype \Proc$.
		$\Gamma; \Sigma_1 \circ \Sigma_2 \proves_1 P \wb_1 Q $ if and only if $\mapt{\Gamma}; \mapt{\Sigma_1} \circ \mapt{\Sigma_2} \proves_2 \map{P} \wb_2 \map{Q} $.
	\end{enumerate}
\end{definition}

Encoding composition is closed on the above properties.

\begin{proposition}[Composability of Typed Encodings]
	Let $\encod{\cdot}{\cdot}{1}: \tyl{L}_1 \to \tyl{L}_2$ and $\encod{\cdot}{\cdot}{2}: \tyl{L}_2 \to \tyl{L}_3$
	be two good typed encodings as in Definition~\ref{def:ep}.
	Then their composition, denoted 
	$\encod{\cdot}{\cdot}{1} \cdot \encod{\cdot}{\cdot}{2}: \tyl{L}_1 \to \tyl{L}_3$
	is also a good typed encoding.
%	Let $\encod{\cdot}{\cdot}{1}: \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1} \longrightarrow \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$ and 
%	$\encod{\cdot}{\cdot}{2}: \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1} \longrightarrow \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$
%	encodings that respect the properties of definition~\ref{def:ep}.
%	Then $\encod{\cdot}{\cdot}{1} \cdot \encod{\cdot}{\cdot}{2}$
%	also respect the properties of definition~\ref{def:ep}.
\end{proposition}

\begin{proof}
	Straightforward application of the definition of each property.
\end{proof}

\section{Positive Expressiveness Results}

\subsection{List of Languages Under Consideration}
We consider the following variants of \HOp:
\begin{enumerate}[-]
\item \sesp: the first and third lines of the syntax of processes in Fig.~\ref{fig:syntax} (first-order, monadic communication).
\item \HO: the second and third lines of the syntax of processes in Fig.~\ref{fig:syntax} (pure higher-order, monadic communication).
\item \sespnr: the finite sub-calculus of \sesp, i.e., without recursion.
\item \psesp: the variant of \sesp with polyadic communication.
\end{enumerate}
\noindent
In the following we write $\pmap{\cdot}{i}$
and $\tmap{\cdot}{i}$ 
for mappings of processes and types, respectively.
Since we always consider variants and fragments of \HOp, the 
 reduction semantics $\red$, the typed behavioral equivalence $\wb$, and the type system $\proves$ are the same for all languages.

\subsection{Encoding \sespnr  into \HOp}

The semantics of the $\HOp$ are powerful enough to
express the semantics of the standard $\sesp$ calculus.

The name passing semantics of $\sesp$ have a rather straightforward
encoding from to $\HOp$.
On the other hand to achieve the encoding of the recursion semantic
of $\sesp$, we need to extend
to the polyadic version of $\sesp$ as an intermediate step in order
to give a sound encoding of the recursion semantics to $\HOp$.

We first encode the name passing semantics:

\begin{definition}[\sespnr  into \HOp]
    Define $\encod{\cdot}{\cdot}{1}: \sespnr \to \HOp$  as follows:
\[
	\begin{array}{rcl}
		\pmap{\bout{k}{k'} P}{1}	&\defeq&	\bbout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{k'}} } \pmap{P}{1} \\
		\pmap{\binp{k}{x} Q}{1}	&\defeq&	\binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact} \\
		\tmap{\btout{S_1} {S} }{1}	&\defeq&	\bbtout{\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}} \tmap{S}{1}  \\
		\tmap{\btinp{S_1} S }{1}	&\defeq&	\bbtinp{\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}} \tmap{S}{1} 
	\end{array}
\]
where $\pmap{\cdot}{1}$ (resp. $\tmap{\cdot}{1}$) is an 
homomorphism for the other process (resp. type) constructs.
   	%We write \dk{$\encod{\cdot}{\cdot}{1}: \sespnr \to \HOp$} whenever
%	\begin{tabular}{ll}
%		\begin{tabular}{l}
%			$\map{\bout{k}{k'} P}^1 \defeq \bout{k}{ \abs{z}{\binp{z}{X} \appl{X}{k'}} } \map{P}^1$
%			\\
%			$\map{\binp{k}{x} P}^1 \defeq \binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\abs{x} \map{P}^1} \inact}$
%		\end{tabular}
%		&
%		\begin{tabular}{l}
%			$\tmap{\btout{S_1} S_2}{1} \defeq \btout{\dk{todo}} \tmap{S_2}{1}$
%			\\
%			$\tmap{\btinp{S_1} S_2}{1} \defeq \btinp{\dk{todo}} \tmap{S_2}{1}$
%		\end{tabular}
%	\end{tabular}
\end{definition}

In the higher-order setting, a name $k$ is being passed as an input
guarded abstraction. The input prefix receives an abstraction and
continues with the application of $k$ over the received abstraction.
On the reception side $\binp{s}{x} P$ 
the encoding develops a mechanism that will receive
the input guarded abstraction, apply it on a fresh endpoint $s$ and use
the dual endpoint $\dual{s}$ to send the continuation $P$ as the abstraction
$\abs{x}{P}$. Name substitution is then achieved as application.

\begin{proposition}
Encoding $\encod{\cdot}{\cdot}{1}: \sespnr \to \HOp$  is type-preserving (cf. Def.~\ref{def:ep}\,(1)).
\end{proposition}

\begin{proof}
By induction on the structure of \sesp process $P$. \\
We write $U_1$ to stand for $\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}$

\begin{enumerate}[1.]

	\item Case $P = \bout{k}{k'}P'$, with $\Gamma; \emptyset; \Sigma \cat k':S \cat k:\btout{S}S_1 \proves  \bout{k}{k'} P' \hastype \Proc$.

	\[
		\tree{
			\Gamma; \emptyset ; \Sigma \cat k:S_1 \proves \pmap{P'}{1} \hastype \Proc
			\qquad
			\tree{
				\tree{
					\Gamma; \emptyset; \cat \X: \lhot{T'} \proves \appl{\X}{k} \hastype k:T' \cat X
				}{
					\Gamma \cat here \X: \lhot{T'} \proves \appl{\X}{k} \hastype k:T' \cat X \cat z: \tinact
				}
			}{
				\Gamma ; \emptyset; k' : S \proves \abs{z}{\binp{z}{X} \appl{\X}{k'}} \hastype U_1
			}
		}{
		\Gamma; \emptyset; \Sigma \cat k':S \cat k:\btout{U}S_1 \proves  \bbout{k}{\abs{z}{\binp{z}{X} \appl{\X}{k'}}} \pmap{P'}{1} \hastype \Proc
		}
	\]
\end{enumerate}
\end{proof}

The encoding from polyadic $\sesp$ to $\sesp$ is easier than the
encoding of polyadic $\pi$-calculus in the $\pi$-calculus because
we have linear session endpoints.

\begin{definition}[Encoding from polyadic $\sesp$ to $\sesp$]
	We write \dk{$\encod{\cdot}{\cdot}{2}:$ polyadic $\sesp \longrightarrow \HOp$} whenever

	\begin{tabular}{lcl}
		\begin{tabular}{l}
			$\map{\bout{k}{k' \cat \tilde{k}} P}^{2} \defeq \bout{k}{k'} \map{\bout{k}{\tilde{k}} P}$\\
			$\map{\binp{k}{x \cat \tilde{x}} P}^{2} \defeq \binp{k}{x} \map{\binp{k}{\tilde{x}} P}$
		\end{tabular}
		& \quad &
		\begin{tabular}{l}
			$\tmap{\btout{S_1 \cat \tilde{S}} S}{2} \defeq \btout{S_1} \tmap{\btout{\tilde{S}} S}{2}$\\
			$\tmap{\btinp{S_1 \cat \tilde{S}} S}{2} \defeq \btinp{S_1} \tmap{\btinp{\tilde{S}} S}{2}$
		\end{tabular}
	\end{tabular}
\end{definition}

Polyadic name sending (resp.\ receive) is encoded as sequence of
send (resp.\ receive) operations. Linearity of session endpoints
ensures no race conditions, thus the encoding is sound.

The encoding of the polyadic $\sesp$ semantics is as simple as the
composition of the two former encodings.

\begin{definition}[Encoding from polyadic $\sesp$ without recursion to $\HOp$]
	We define $\encod{\cdot}{\cdot}{3}: $ polyadic $\sesp \longrightarrow \HOp$
	as $\encod{\cdot}{\cdot}{3} = \encod{\cdot}{\cdot}{1} \cat \encod{\cdot}{\cdot}{2}$.	
\end{definition}

Encoding the $\sesp$ recursive operation requires to follow the fundamental
principle of copying the process that needs to exhibit recursive behaviour.
The primitive recursor operation creates copies of a process and uses them
as continuations, e.g:
\[
	\recp{X}{\bout{s}{v} \rvar{X}} \scong \bout{s}{v} \recp{X}{\bout{s}{v} \rvar{X}}
\]
In the above example the scope of name $s$ includes the entire process so
the type system would be 
