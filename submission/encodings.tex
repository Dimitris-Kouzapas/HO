% !TEX root = main.tex
\newcommand{\enc}[2]{\big\langle\map{#1}, \mapt{#2}\big\rangle}
\newcommand{\encod}[3]{\lrangle{\map{#1}^{#3}, \mapt{#2}^{#3}}}

\newcommand{\calc}[5]{\lrangle{#1, #2, #3, #4, #5}}
\newcommand{\tyl}[1]{\ensuremath{\mathcal{#1}}}

\section{Typed Encodings}

In this section we present a study of the expressiveness 
of the sub-calculi of $\HOp$.

We first define the notion of calculus. We extend notions proposed elsewhere (cf. Gorla) by explicitly
considering a type structure and a type system.

\begin{definition}[Typed Calculus]\label{d:tcalculus}
	A \emph{typed calculus} $\tyl{L}$ is defined as a tuple $$\calc{L}{T}{\red}{\wb}{\proves}$$
	where $L$ and $T$ are sets of processes and types, respectively; %$T_1$ is the set of types;
	$\red$ and $\wb$ denote a reduction semantics 
	and a typed equivalence
	 on processes, respectively. Finally, $\proves$ denotes a type system for processes in $L$.
\end{definition}

We notice that in this paper we shall always consider languages with the same type system.
In the following, when writing $\tyl{L}_i$ we tacitly assume the existence of appropriate 
$L_i$, $T_i$, $\red_i$, $\wb_i$, and $\proves_i$.
We first define the notion of encoding over typed calculi.

\begin{definition}[Typed Encoding]
	Let  $\tyl{L}_1$ % = \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1}$
	and $\tyl{L}_2$ % =  \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$ 
	be typed calculi as in Definition~\ref{d:tcalculus}.
	Given mappings $\map{\cdot}: L_1 \to L_2$ and
	$\mapt{\cdot}: T_1 \to T_2$, 
	we write 
	%$\enc{\cdot}{\cdot}: \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1} \longrightarrow \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$
%	for the encoding from $\calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1}$ to $\calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$.
	$\enc{\cdot}{\cdot} : \tyl{L}_1 \to \tyl{L}_2$ to denote the \emph{typed encoding} of $\tyl{L}_1$ into $\tyl{L}_2$.

\end{definition}

\subsection{Encoding Properties}

We require that a {\em good} encoding should 
preserve not only the syntax but
also the operational, typing and behavioural
semantics. 

\begin{notation}[Typed Equivalence]
Let $P$ and $Q$ be two well-typed processes, i.e., 
there exist $\Gamma, \Sigma_1, \Sigma_2$ such that 
$\Gamma; \emptyset; \Sigma_1 \proves P \hastype \Proc$ 
and
$\Gamma; \emptyset; \Sigma_2 \proves Q \hastype \Proc$.
Then, to denote the fact that 
$P$ and $Q$ are related by behavioral equivalence $\wb$, we shall write
%Then we adopt the following notational convention:
$
\Gamma; \Sigma_1 \circ \Sigma_2 \proves P \wb Q.
$
\end{notation}

\begin{definition}[Good Typed Encodings]
	\label{def:ep}
	We say that $\enc{\cdot}{\cdot} : \tyl{L}_1 \to \tyl{L}_2$ be is a \emph{good  typed encoding} if it satisfies the following properties:
	%Let $\Gamma; \emptyset; \Sigma \proves P \hastype \Proc$ 
	%a process from calculus $\calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1}$
	%and an encoding 
	%$\enc{\cdot}{\cdot}: \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1} \longrightarrow \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$.
	
	\begin{enumerate}[1.]
		\item \emph{Type preservation}:	%We say that $\enc{\cdot}{\cdot}$ is \emph{type preserving}
		if
			$\Gamma; \emptyset; \Sigma \proves_1 P \hastype \Proc$ then $\mapt{\Gamma}; \emptyset; \mapt{\Sigma} \proves_2 \map{P} \hastype \Proc$ for any   $P$ in $L_1$.

		\item \emph{Operational Correspondence}: If $\Gamma; \emptyset; \Sigma \proves_1 P \hastype \Proc$ then
		\begin{enumerate}[-]
			\item	Completeness: If $P \red_1 P'$ then $\exists \Sigma'$ s.t.
				$\map{P} \Red_2 \map{P'}$ and
				$\mapt{\Gamma}; \emptyset; \mapt{\Sigma'} \proves_2 \map{P'} \hastype \Proc$.
			\item Soundness : If $\map{P} \red_2 Q$ then
				$\exists P'$ s.t. $P \red_1 P'$ and \\
				%$\mapt{\Gamma};\emptyset; \mapt{\Sigma_1} \proves_2 \map{Q} \wb_2 \Sigma_2 \proves P' \hastype \Proc$.
				$\mapt{\Gamma}; \mapt{\Sigma_1} \circ \mapt{\Sigma_2} \proves_2 \map{P'} \wb_2 Q$.
%			\item Soundness (2): If $\map{P} \red_2 Q$ then
%				$\exists P', Q'$ s.t. $P \red_1 P'$, $Q \Red_2 Q'$ and \\
%				$\mapt{\Gamma}; \mapt{\Sigma_1} \circ \mapt{\Sigma_2} \proves_2 \map{P'} \wb_2 Q'$.
		\end{enumerate}
		
		\item \emph{Full Abstraction:} %whenever:		\\
		%	$\Gamma; \emptyset; \Sigma_1 \proves_1 P_1 \wb_1 \Sigma_2 \proves P_2 \hastype \Proc$ if and only if
		%	$\mapt{\Gamma}; \emptyset; \mapt{\Sigma_1} \proves \map{P_1} \wb \mapt{\Sigma_2} \proves \map{P_2} \hastype \Proc$.
		$\Gamma; \Sigma_1 \circ \Sigma_2 \proves_1 P \wb_1 Q $ if and only if $\mapt{\Gamma}; \mapt{\Sigma_1} \circ \mapt{\Sigma_2} \proves_2 \map{P} \wb_2 \map{Q} $.
	\end{enumerate}
\end{definition}

Encoding composition is closed on the above properties.

\begin{proposition}[Composability of Typed Encodings]
	Let $\encod{\cdot}{\cdot}{1}: \tyl{L}_1 \to \tyl{L}_2$ and $\encod{\cdot}{\cdot}{2}: \tyl{L}_2 \to \tyl{L}_3$
	be two good typed encodings as in Definition~\ref{def:ep}.
	Then their composition, denoted 
	$\encod{\cdot}{\cdot}{1} \cdot \encod{\cdot}{\cdot}{2}: \tyl{L}_1 \to \tyl{L}_3$
	is also a good typed encoding.
%	Let $\encod{\cdot}{\cdot}{1}: \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1} \longrightarrow \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$ and 
%	$\encod{\cdot}{\cdot}{2}: \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1} \longrightarrow \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$
%	encodings that respect the properties of definition~\ref{def:ep}.
%	Then $\encod{\cdot}{\cdot}{1} \cdot \encod{\cdot}{\cdot}{2}$
%	also respect the properties of definition~\ref{def:ep}.
\end{proposition}

\begin{proof}
	Straightforward application of the definition of each property.
\end{proof}

\section{Positive Expressiveness Results}

\subsection{List of Languages Under Consideration}
We consider the following variants of \HOp:
\begin{enumerate}[-]
\item \sesp: the first and third lines of the syntax of processes in Fig.~\ref{fig:syntax} (first-order, monadic communication).
\item \HO: the second and third lines of the syntax of processes in Fig.~\ref{fig:syntax} (pure higher-order, monadic communication).
\item \sespnr: the finite sub-calculus of \sesp, i.e., name passing without recursion.
\item \psesp: the variant of \sesp with polyadic communication.
\end{enumerate}
\noindent
In the following we write $\pmap{\cdot}{i}$
and $\tmap{\cdot}{i}$ 
for mappings of processes and types, respectively.
Since we always consider variants and fragments of \HOp, the 
 reduction semantics $\red$, the typed behavioral equivalence $\wb$, and the type system $\proves$ are the same for all languages.

\subsection{Encoding \sespnr  into \HO}

The semantics of the $\HO$ are powerful enough to
express the semantics of the standard $\sesp$ calculus.

The name passing semantics of $\sesp$ have a rather straightforward
encoding from to $\HO$.
On the other hand to achieve the encoding of the recursion semantic
of $\sesp$, we need to extend
to the polyadic version of $\sesp$ as an intermediate step in order
to give a sound encoding of the recursion semantics to $\HO$.

We first encode the name passing semantics. Below, we use $n$ to stand for either a linear channel $k'$ or a shared name $a$.

\begin{definition}[\sespnr  into \HO]
    Define $\encod{\cdot}{\cdot}{1}: \sespnr \to \HO$  as follows:
\[
	\begin{array}{rcl}
		\pmap{\bout{k}{n} P}{1}	&\defeq&	\bbout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{n}} } \pmap{P}{1} \\
		\pmap{\binp{k}{x} Q}{1}	&\defeq&	\binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact} \\
		\tmap{\btout{S_1} {S} }{1}	&\defeq&	\bbtout{\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}} \tmap{S}{1}  \\
		\tmap{\btinp{S_1} S }{1}	&\defeq&	\bbtinp{\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}} \tmap{S}{1} \\
		\tmap{\bbtout{\chtype{S_1}} {S} }{1}	&\defeq&	\bbtout{\shot{\btinp{\shot{\chtype{\tmap{S_1}{1}}}}\tinact}} \tmap{S}{1}  \\
		\tmap{\bbtinp{\chtype{S_1}} {S} }{1}	&\defeq&	\bbtinp{\shot{\btinp{\shot{\chtype{\tmap{S_1}{1}}}}\tinact}} \tmap{S}{1} 
	\end{array}
\]
where $\pmap{\cdot}{1}$ (resp. $\tmap{\cdot}{1}$) is an 
homomorphism for the other process (resp. type) constructs.
   	%We write \dk{$\encod{\cdot}{\cdot}{1}: \sespnr \to \HOp$} whenever
%	\begin{tabular}{ll}
%		\begin{tabular}{l}
%			$\map{\bout{k}{k'} P}^1 \defeq \bout{k}{ \abs{z}{\binp{z}{X} \appl{X}{k'}} } \map{P}^1$
%			\\
%			$\map{\binp{k}{x} P}^1 \defeq \binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\abs{x} \map{P}^1} \inact}$
%		\end{tabular}
%		&
%		\begin{tabular}{l}
%			$\tmap{\btout{S_1} S_2}{1} \defeq \btout{\dk{todo}} \tmap{S_2}{1}$
%			\\
%			$\tmap{\btinp{S_1} S_2}{1} \defeq \btinp{\dk{todo}} \tmap{S_2}{1}$
%		\end{tabular}
%	\end{tabular}
\end{definition}

In the higher-order setting, a name $k$ is being passed as an input
guarded abstraction. The input prefix receives an abstraction and
continues with the application of $k$ over the received abstraction.
On the reception side $\binp{s}{x} P$ 
the encoding develops a mechanism that will receive
the input guarded abstraction, apply it on a fresh endpoint $s$ and use
the dual endpoint $\dual{s}$ to send the continuation $P$ as the abstraction
$\abs{x}{P}$. Name substitution is then achieved as application.

\begin{proposition}
Encoding $\encod{\cdot}{\cdot}{1}: \sespnr \to \HO$  is type-preserving (cf. Def.~\ref{def:ep}\,(1)).
\end{proposition}

\begin{proof}
By induction on the structure of \sesp process $P$. 
\begin{enumerate}[1.]

%%%% Output of (linear) channel
	\item Case $P = \bout{k}{n}P'$. There are two sub-cases. In the first sub-case $n = k'$ (output of a linear channel). Then  
	we have the following typing in the source language:
	{\small
	\[
		\tree{
			\Gamma; \emptyset; \Sigma \cat k:S  \proves  P' \hastype \Proc \quad \Gamma ; \emptyset ; \{k' : S_1\} \proves  k' \hastype S_1}{
			\Gamma; \emptyset; \Sigma \cat k':S_1 \cat k:\btout{S_1}S \proves  \bout{k}{k'} P' \hastype \Proc}
	\]
	}
	The corresponding typing in the target language is as follows --- we write $U_1$ to stand for $\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}$:
	{\small
	\[
		\tree{
			\tree{}{\tmap{\Gamma}{1}; \emptyset ; \tmap{\Sigma}{1} \cat k:\tmap{S}{1} \proves \pmap{P'}{1} \hastype \Proc}
			~~
			\tree{
				\tree{
					\tree{
						\tree{
							\tree{}{\tmap{\Gamma}{1} ; \{X : \lhot{\tmap{S_1}{1}}\} ; \emptyset \proves \X  \hastype \lhot{\tmap{S_1}{1}}} 
							\quad 
							\tree{}{\tmap{\Gamma}{1} ; \emptyset ; \{k' : \tmap{S_1}{1}\} \proves  k' \hastype \tmap{S_1}{1}}}{\tmap{\Gamma}{1} ; \{X : \lhot{\tmap{S_1}{1}}\} ; k' : \tmap{S_1}{1} \proves \appl{\X}{k'} \hastype \Proc}}{\tmap{\Gamma}{1} ; \{X : \lhot{\tmap{S_1}{1}}\} ; k' : 	\tmap{S_1}{1} \cat z:\tinact \proves \appl{\X}{k'} \hastype \Proc}
				}{
					\tmap{\Gamma}{1} ; \emptyset; k' : \tmap{S_1}{1} \cat z:\btinp{\lhot{\tmap{S_1}{1}}}\tinact \proves \binp{z}{X} \appl{\X}{k'} \hastype \Proc
				}
			}{
				\tmap{\Gamma}{1} ; \emptyset; k' : \tmap{S_1}{1} \proves \abs{z}{\binp{z}{X} \appl{\X}{k'}} \hastype U_1
			}
		}{
		\tmap{\Gamma}{1}; \emptyset; \tmap{\Sigma}{1} \cat k':\tmap{S_1}{1} \cat k:\btout{U_1}\tmap{S}{1} \proves  \bbout{k}{\abs{z}{\binp{z}{X} \appl{\X}{k'}}} \pmap{P'}{1} \hastype \Proc
		}
	\]
	}
	
	In the second sub-case, we have $n = a$ (output of a shared name). Then  
	we have the following typing in the source language:
	{\small
	\[
		\tree{
			\Gamma \cat a:\chtype{S_1}; \emptyset; \Sigma \cat k:S  \proves  P' \hastype \Proc \quad \Gamma \cat a:\chtype{S_1} ; \emptyset ; \emptyset \proves  a \hastype S_1}{
			\Gamma \cat a:\chtype{S_1} ; \emptyset; \Sigma  \cat k:\bbtout{\chtype{S_1}}S \proves  \bout{k}{a} P' \hastype \Proc}
	\]
	}
	The typing in the target language is derived similarly as in the first sub-case. \\
	
	%%%% Input of (linear) channel 
	\item Case $P = \binp{k}{x}Q$. We have two sub-cases, depending on the type of $x$. In the first case, $x$ stands for a linear channel.
	Then we have the following typing in the source language:
	{\small
	\[
	 \tree{
		 \Gamma; \emptyset; \Sigma  \cat k:S \cat x:S_1 \proves   Q \hastype \Proc
	 	}{
		\Gamma; \emptyset; \Sigma  \cat k:\btinp{S_1}S \proves  \binp{k}{x} Q \hastype \Proc}
	 \]
	 }
	 The corresponding typing in the target language is as follows --- we write $U_1$ to stand for $\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}$:
	{\small  
	\[
	 \tree{
		 \tree{
		 	\tree{
			\tree{
			\begin{array}{c}
			\tmap{\Gamma}{1}; \{X: U_1\};   \emptyset \proves X \hastype U_1 \\
			\tmap{\Gamma}{1}; \emptyset;   \cat s: \btinp{\lhot{\tmap{S_1}{1}}}\tinact \ \proves s \, \hastype  \btinp{\lhot{\tmap{S_1}{1}}}
			\tinact 
			\end{array}
			}{
			\tmap{\Gamma}{1}; \{X: U_1\};   \cat s: \btinp{\lhot{\tmap{S_1}{1}}}\tinact \ \proves \appl{X}{s}  \hastype \Proc
			} \quad 
			\tree{
			\tree{
			\tmap{\Gamma}{1}; \emptyset;  \emptyset \proves   \inact  \hastype \Proc}{
			\tmap{\Gamma}{1}; \emptyset;  \dual{s}: \tinact\proves   \inact  \hastype \Proc
			}
			\quad 
			\tree{
			\tmap{\Gamma}{1}; \emptyset;  \tmap{\Sigma}{1} \cat k:\tmap{S}{1}  x:\tmap{S_1}{1} \proves \pmap{Q}{1}   \hastype \Proc	 }{
			\tmap{\Gamma}{1}; \emptyset;  \tmap{\Sigma}{1} \cat k:\tmap{S}{1}   \proves \abs{x} \pmap{Q}{1}   \hastype \lhot{\tmap{S_1}{1}}			}
			}{
			\tmap{\Gamma}{1}; \emptyset;  \tmap{\Sigma}{1} \cat k:\tmap{S}{1}  \cat \dual{s}: \btout{\lhot{\tmap{S_1}{1}}}\tinact\proves  \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact  \hastype \Proc
			}
			}{
			\tmap{\Gamma}{1}; \{X: U_1\};  \tmap{\Sigma}{1} \cat k:\tmap{S}{1} \cat s: \btinp{\lhot{\tmap{S_1}{1}}}\tinact \cat \dual{s}: \btout{\lhot{\tmap{S_1}{1}}}\tinact\proves \appl{X}{s} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact  \hastype \Proc
			}
			}{
		 \tmap{\Gamma}{1}; \{X: U_1\};  \tmap{\Sigma}{1} \cat k:\tmap{S}{1} \proves \newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact}  \hastype \Proc
		 }
		 }{
		\tmap{\Gamma}{1}; \emptyset; \tmap{\Sigma}{1}  \cat k:\btinp{U_1}\tmap{S}{1} \proves  \binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact}  \hastype \Proc
		}
	 \]
	 }
	 
	 In the second sub-case, $x$ stands for a shared name. Then we have the following typing in the source language:
	{\small
	\[
	 \tree{
		 \Gamma \cat x:\chtype{S_1} ; \emptyset; \Sigma  \cat k:S \proves   Q \hastype \Proc
	 	}{
		\Gamma ; \emptyset; \Sigma  \cat k:\btinp{\chtype{S_1}}S \proves  \binp{k}{x} Q \hastype \Proc}
	 \]
	 }
	 The typing in the target language is derived similarly as in the first sub-case. 
	 
	 

	
\end{enumerate}
\qed
\end{proof}


\begin{proposition}
Encoding $\encod{\cdot}{\cdot}{1}: \sespnr \to \HO$  enjoys operational correspondence (cf. Def.~\ref{def:ep}\,(2)).
\end{proposition}

\begin{proof}[Sketch]
We must show completeness and soundness properties. 
For completeness, it suffices to consider source process $P_0 = \bout{k}{k'} P \Par \binp{k}{x} Q$. We have that
\[
P_0 \red P \Par Q\subst{k'}{x}.
\]
By the definition of encoding we have:
\begin{eqnarray*}
\pmap{P_0}{1} & = & \bbout{k}{ \abs{z}{\,\binp{z}{X} \appl{X}{k'}} } \pmap{P}{1} \Par \binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact}  \\
& \red & \pmap{P}{1} \Par \newsp{s}{\appl{X}{s} \subst{\abs{z}{\,\binp{z}{X} \appl{X}{k'}}}{X} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact} \\
& = & \pmap{P}{1} \Par \newsp{s}{\,\binp{s}{X} \appl{X}{k'} \Par \bbout{\dual{s}}{\abs{x} \pmap{Q}{1}} \inact} \\
& \red & \pmap{P}{1} \Par \appl{X}{k'} \subst{\abs{x} \pmap{Q}{1}}{X} \Par \inact \\
& \scong & \pmap{P}{1} \Par \pmap{Q}{1}\subst{k'}{x}  
\end{eqnarray*}
For soundness, it suffices to notice that the encoding does not add new visible actions: the additional synchronizations induced by the encoding always occur on private (fresh) names. We assume weak bisimilarities, which abstract from internal actions used by the encoding, and so  constructing a relation witnessing behavioral equivalence is easy.
\qed
\end{proof}

\subsection{Polyadic Into Monadic}
The encoding from $\psesp$ to $\sesp$ is easier than the
encoding of polyadic $\pi$-calculus in the $\pi$-calculus because
we have linear session endpoints.

\begin{definition}[$\psesp$ to $\sesp$]
	We write $\encod{\cdot}{\cdot}{2}:\psesp \to \sesp$ whenever

	\begin{tabular}{lcl}
		\begin{tabular}{l}
			$\map{\bout{k}{k' \cat \tilde{k}} P}^{2} \defeq \bout{k}{k'} \map{\bout{k}{\tilde{k}} P}$\\
			$\map{\binp{k}{x \cat \tilde{x}} P}^{2} \defeq \binp{k}{x} \map{\binp{k}{\tilde{x}} P}$
		\end{tabular}
		& \quad &
		\begin{tabular}{l}
			$\tmap{\btout{S_1 \cat \tilde{S}} S}{2} \defeq \btout{S_1} \tmap{\btout{\tilde{S}} S}{2}$\\
			$\tmap{\btinp{S_1 \cat \tilde{S}} S}{2} \defeq \btinp{S_1} \tmap{\btinp{\tilde{S}} S}{2}$
		\end{tabular}
	\end{tabular}
\end{definition}

Polyadic name sending (resp.\ receive) is encoded as sequence of
send (resp.\ receive) operations. Linearity of session endpoints
ensures no race conditions, thus the encoding is sound.

The encoding of the polyadic $\sesp$ semantics is as simple as the
composition of the two former encodings.

\begin{definition}[Encoding from $\sesp^{p-\mu}$ to $\HO$]
	We define $\encod{\cdot}{\cdot}{3}: \sesp^{p-\mu} \longrightarrow \HO$
	as $\encod{\cdot}{\cdot}{3} = \encod{\cdot}{\cdot}{1} \cat \encod{\cdot}{\cdot}{2}$.	
\end{definition}

Next we give the encoding from $\HOp$ with polyadic abstraction to
$\HOp^{p}$.

\begin{definition}[Encoding from $\HOp^{pa-\mu}$ to $\HO^{p}$]

	\begin{tabular}{lcl}
		$\map{\bout{k}{\abs{\tilde{x}} P_1} P_2}^4$ &$\defeq$& $\bout{k}{\abs{z} \binp{z}{\tilde{x}} \map{P_1}^4} \map{P_2}^4$\\
		$\map{\appl{X}{\tilde{k}}}$ &$\defeq$& $\newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\tilde{k}} \inact}$
	\end{tabular}
\end{definition}

We compose the latter encoding with the generalisation $\map{\cdot}^3 : \HOp^{p-\mu} \longrightarrow \HO$
of the encoding $\map{\cdot}^3 : \sesp^{p-\mu} \longrightarrow \HO$ to get a translation
of $\HOp^{pa-\mu}$ to $\HO$.

\begin{definition}[Encoding from $\HOp^{pa-\mu}$ to $\HO$]
	We define $\encod{\cdot}{\cdot}{5}: \HOp^{pa-\mu} \longrightarrow \HO$
	as $\encod{\cdot}{\cdot}{5} = \encod{\cdot}{\cdot}{4} \cat \encod{\cdot}{\cdot}{5}$.	
\end{definition}

Encoding the $\sesp$ recursive operation requires to follow the fundamental
principle of copying the process that needs to exhibit recursive behaviour.
The primitive recursor operation creates copies of a process and uses them
as continuations, e.g:
\[
	\recp{X}{\bout{s}{v} \rvar{X}} \scong \bout{s}{v} \recp{X}{\bout{s}{v} \rvar{X}}
\]
In the above example the scope of name $s$ includes the entire process so
the type for $s$ would be recursive. An alternative representation
of the above process would be:
\[
	\bout{a}{s} \inact \Par \recp{X}{\binp{a}{x} (\bout{x}{v} \bout{a}{x} \inact \Par X)} 
\]
Endpoint $s$ is being passed sequentialy on copies of the 
same process to achieve the effect of infinite sending of value $v$.
If we apply the same principles on higher order semantics we get:
\[
	\bout{s'}{() \bout{s}{v} \binp{s'}{Y} (\appl{Y}{} \Par \binp{\dual{s'}}{\appl{Y}{}} \inact)} \inact \Par \binp{\dual{s'}}{X} (\appl{X}{} \Par \bout{\dual{s'}}{\appl{X}{}} \inact )
\]

\dk{put the recursive encodings}



\subsection{From $\HO$ to $\sesp$}

We follow the other direction to encode the semantics of the
higher order calculus that allows only abstraction passing
to the semantics that allow only name passing semantics.
The techniques presented in this paper were originally developed
by Sangiorgi in \cite{}. In this work we show that
the same ideas can be applied in a session type setting.
Following the principles of session types we furthermore
study the limits on such encodings when it comes to the linearity
of session endpoints.

In \cite{} Sangiorgi used the idea of triggers to activate
copies of the a process. Trigers were input guarded replicated
processes and instead of passing processes a process is
passing around the name of the input subject of the corresponding trigger.

In the context of session types a session name cannot be replicated.
If in our encoding approach we use non replicated session input guarded
processes we end up with the following naive encoding:

\begin{definition}[From $\HO$ to $\sesp$. Naive approach]

	\begin{tabular}{lcl}
		$\map{\bout{k}{\abs{x} P_1} P_2}^{8}$ &$\defeq$& $ \newsp{s}{\bout{k}{s} (\map{P_2}^8 \Par \binp{\dual{s}}{x} \map{P_1}^8)} $\\
		$\map{\binp{k}{X} P}^{8}$ &$\defeq$& $\binp{s}{x} \map{P}^8$\\
		$\map{\appl{X}{k}}^8$ &$\defeq$& $\bout{x}{k} \inact$
	\end{tabular}
\end{definition}

\begin{proposition}
	Let $\Gamma;\emptyset;\Sigma \proves P \hastype \Proc$ with
	the typing derivation to use only linear session types. Then
	$\map{P}^8$ respects the properties of definition~\ref{def:ep}.
\end{proposition}

\begin{proof}
\dk{TODO}
\end{proof}

This approach although it captures the correct semantics when
dealing with systems that allow only linear process variables,
it suffers from non-typability in the presence
of shared process variables. For example:
\[
	\map{\bout{s}{\abs{x}{\bout{x}{v}\inact}} \inact \Par \binp{\dual{s}}{X} (\appl{X}{s_1} \Par \appl{X}{s_2})}^8 \defeq
	\newsp{s'}{\bout{s}{s'} \binp{\dual{s'}}{x} \bout{x}{v} \inact \Par \binp{\dual{s}}{x} (\bout{x}{s_1} \inact \Par \bout{x}{s_2} \inact)}
\]
The above process is non typable since processes $(\bout{x}{s_1} \inact$ and $\bout{x}{s_2} \inact)$
cannot be put in parallel because they do not have disjoint environments.

The correct approach would be to use replicated shared names
as triggers instead of session names. 

\begin{definition}[From $\HO$ to $\sesp$]

	\begin{tabular}{lcl}
		$\map{\bout{k}{\abs{x} P_1} P_2}^{9}$ &$\defeq$& $ \newsp{a}{\bout{k}{a} (\map{P_2}^9 \Par \repl{} \binp{a}{x}  \map{P_1}^9)} $\\
		$\map{\binp{k}{X} P}^{9}$ &$\defeq$& $\binp{s}{x} \map{P}^9$\\
		$\map{\appl{X}{k}}^9$ &$\defeq$& $\bout{x}{k} \inact$
	\end{tabular}
\end{definition}

At this point an open open question would be if
we could find an encoding that maps
session names to session names without the creation
of shared names.

\dk{give intuition}


