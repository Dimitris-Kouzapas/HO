\newcommand{\enc}[2]{\lrangle{\map{#1}, \mapt{#2}}}
\newcommand{\encod}[3]{\lrangle{\map{#1}^{#3}, \mapt{#2}^{#3}}}

\newcommand{\calc}[5]{\lrangle{#1, #2, #3, #4, #5}}

\section{Encodings}

In this section we present a study of the expressiveness 
of the sub-calculi of $\HOp$.

We first define the notion of calculus.

\begin{definition}
	A typed calculus is defined as a tuple $\calc{L_1}{T_1}{\red}{\wb}{\proves}$
	where: i) $L_1$ is the set of processes, ii) $T_1$ is the set of session types,
	iii) $\red$ is the reduction relation, iv) $\wb$ is the equivalence
	relation, and iv) $\proves$ is the typing system.
\end{definition}

We first define what is an encoding over typed calculus.

\begin{definition}
	Let calculi $\calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1}$
	and $\calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$
	Assuming mappings $\map{\cdot}: L_1 \longrightarrow L_2$ and
	$\mapt{\cdot}: T_1 \longrightarrow T_2$
	we write $\enc{\cdot}{\cdot}: \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1} \longrightarrow \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$
	for the encoding from
	$\calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1}$ to $\calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$.
\end{definition}

\subsection{Encoding Properties}

We require that a {\em good} encoding should 
preserve not only the syntax but
also the operational, typing and behavioural
semantics. Formally:

\begin{definition}[Encoding Properties]
	\label{def:ep}
	Let $\Gamma; \emptyset; \Sigma \proves P \hastype \Proc$ 
	a process from calculus $\calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1}$
	and an encoding 
	$\enc{\cdot}{\cdot}: \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1} \longrightarrow \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$.
	Then
	\begin{enumerate}
		\item	$\enc{\cdot}{\cdot}$ is type preservering whenever
			$\Gamma; \emptyset; \Sigma \proves P \hastype \Proc$ implies $\mapt{\Gamma}; \emptyset; \mapt{\Sigma} \proves \map{P} \hastype \Proc$

		\item	$\enc{\cdot}{\cdot}$ satisfies operational correspondence whenever
		\begin{itemize}
			\item	If $P \red P'$ then
				$\map{P} \Red \map{P'}$ and
				$\mapt{\Gamma}; \emptyset; \mapt{\Sigma'} \proves \map{P'} \hastype \Proc$.
			\item	If $\map{P} \red \map{Q}$ then
				$\exists P'$ such that $P \red P'$ and 
				$\mapt{\Gamma};\emptyset; \mapt{\Sigma_1} \proves \map{Q} \wb \Sigma_2 \proves P' \hastype \Proc$.
		\end{itemize}
		
		\item	$\enc{\cdot}{\cdot}$ is fully abstract whenever
			$\Gamma; \emptyset; \Sigma_1 \proves P_1 \wb \Sigma_2 \proves P_2 \hastype \Proc$ if and only if
			$\mapt{\Gamma}; \emptyset; \mapt{\Sigma_1} \proves \map{P_1} \wb \mapt{\Sigma_2} \proves \map{P_2} \hastype \Proc$.
	\end{enumerate}
\end{definition}

Encoding composition is closed on the above properties.

\begin{proposition}
	Let $\encod{\cdot}{\cdot}{1}: \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1} \longrightarrow \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$ and 
	$\encod{\cdot}{\cdot}{2}: \calc{L_1}{T_1}{\red_1}{\wb_1}{\proves_1} \longrightarrow \calc{L_2}{T_2}{\red_2}{\wb_2}{\proves_2}$
	encodings that respect the properties of definition~\ref{def:ep}.
	Then $\encod{\cdot}{\cdot}{1} \cdot \encod{\cdot}{\cdot}{2}$
	also respect the properties of definition~\ref{def:ep}.
\end{proposition}

\begin{proof}
	Straightforward application of the definition of each property.
\end{proof}

\subsection{Encoding from $\sesp$ to $\HOp$}

The semantics of the $\HOp$ are powerfull enough to
express the semantics of the standard $\sesp$ calculus.

The name passing semantics of $\sesp$ have a rather straightforward
encoding from to $\HOp$.
On the other hand to achieve the encoding of the recursion semantic
of $\sesp$, we need to extend
to the polyadic version of $\sesp$ as an intermediate step in order
to give a sound encoding of the recursion semantics to $\HOp$.

We first encode the name passing semantics:

\begin{definition}[Encoding from $\sesp$ without recursion to $\HOp$]
	We write \dk{$\encod{\cdot}{\cdot}{1}: \sesp \longrightarrow \HOp$} whenever

	\begin{tabular}{ll}
		\begin{tabular}{l}
			$\map{\bout{k}{k'} P}^1 \defeq \bout{k}{ \abs{z}{\binp{z}{X} \appl{X}{k'}} } \map{P}^1$
			\\
			$\map{\binp{k}{x} P}^1 \defeq \binp{k}{X} \newsp{s}{\appl{X}{s} \Par \bout{\dual{s}}{\abs{x} \map{P}^1} \inact}$
		\end{tabular}
		&
		\begin{tabular}{l}
			$\tmap{\btout{S_1} S_2}{1} \defeq \btout{\dk{todo}} \tmap{S_2}{1}$
			\\
			$\tmap{\btinp{S_1} S_2}{1} \defeq \btinp{\dk{todo}} \tmap{S_2}{1}$
		\end{tabular}
	\end{tabular}
\end{definition}

In the higher-order setting, a name $k$ is being passed as an input
guarded abstraction. The input prefix receives an abstraction and
continues with the application of $k$ over the received abstraction.
On the reception side $\binp{s}{x} P$ 
the encoding develops a mechanism that will receive
the input guarded abstraction, apply it on a fresh endpoint $s$ and use
the dual endpoint $\dual{s}$ to send the continuation $P$ as the abstraction
$\abs{x}{P}$. Name substitution is then achieved as application.

The encoding from polyadic $\sesp$ to $\sesp$ is easier than the
encoding of polyadic $\pi$-calculus in the $\pi$-calculus because
we have linear session endpoints.

\begin{definition}[Encoding from polyadic $\sesp$ to $\sesp$]
	We write \dk{$\encod{\cdot}{\cdot}{2}:$ polyadic $\sesp \longrightarrow \HOp$} whenever

	\begin{tabular}{lcl}
		\begin{tabular}{l}
			$\map{\bout{k}{k' \cat \tilde{k}} P}^{2} \defeq \bout{k}{k'} \map{\bout{k}{\tilde{k}} P}$\\
			$\map{\binp{k}{x \cat \tilde{x}} P}^{2} \defeq \binp{k}{x} \map{\binp{k}{\tilde{x}} P}$
		\end{tabular}
		& \quad &
		\begin{tabular}{l}
			$\tmap{\btout{S_1 \cat \tilde{S}} S}{2} \defeq \btout{S_1} \tmap{\btout{\tilde{S}} S}{2}$\\
			$\tmap{\btinp{S_1 \cat \tilde{S}} S}{2} \defeq \btinp{S_1} \tmap{\btinp{\tilde{S}} S}{2}$
		\end{tabular}
	\end{tabular}
\end{definition}

Polyadic name sending (resp.\ receive) is encoded as sequence of
send (resp.\ receive) operations. Linearity of session endpoints
ensures no race conditions, thus the encoding is sound.

The encoding of the polyadic $\sesp$ semantics is as simple as the
composition of the two former encodings.

\begin{definition}[Encoding from polyadic $\sesp$ without recursion to $\HOp$]
	We define $\encod{\cdot}{\cdot}{3}: $ polyadic $\sesp \longrightarrow \HOp$
	as $\encod{\cdot}{\cdot}{3} = \encod{\cdot}{\cdot}{1} \cat \encod{\cdot}{\cdot}{2}$.	
\end{definition}

Encoding the $\sesp$ recursive operation requires to follow the fundamental
principle of copying the process that needs to exhibit recursive behaviour.
The primitive recursor operation creates copies of a process and uses them
as continuations, e.g:
\[
	\recp{X}{\bout{s}{v} \rvar{X}} \scong \bout{s}{v} \recp{X}{\bout{s}{v} \rvar{X}}
\]
In the above example the scope of name $s$ includes the entire process so
the type system would be 
