% !TEX root = main.tex
\myparagraph{Expressiveness of Process Calculi.}
There is a vast literature on expressiveness studies for process calculi. 
Here we concentrate on closely related work; 
see~\cite{KouzapasPY15} for more detailed related work. 
To substantiate claims related to (relative) expressive power,
early works appealed to different definitions of encoding \cite{Palamidessi03}.
Later on, 
proposals of abstract 
frameworks which 
state associated syntactic and semantic criteria 
were put forward; 
two proposals are~\cite{DBLP:journals/iandc/Gorla10,DBLP:journals/tcs/FuL10}. 
These frameworks are applicable to different calculi, and 
have shown useful to clarify known results and to derive new ones.
Our formulation of (precise) typed encoding (Def.~\ref{def:goodenc}) 
builds upon existing proposals (including~\cite{Palamidessi03,DBLP:journals/iandc/Gorla10,DBLP:conf/icalp/LanesePSS10})
in order to account for the session type systems
associated to \HOp and its variants/extensions.

\myparagraph{Expressiveness of Higher-Order Process Calculi.}
Due to the close relationship between
higher-order process calculi and functional calculi, works devoted to
encoding (variants of) the $\lambda$-calculus into (variants of) the
$\pi$-calculus~ (e.g.,~\cite{San92,DBLP:journals/tcs/Fu99}) are broadly related.
The encoding of process passing into name passing is well-known~\cite{SangiorgiD:expmpa};
the encoding of in the reverse direction 
is studied in~\cite{SaWabook} for an asynchronous, localised $\pi$-calculus
(only the output capability of names can be sent around).  The
work~\cite{San96int} studies hierarchies for calculi with
\emph{internal} first-order mobility and with higher-order mobility
without name-passing (similarly as \HO). The
hierarchies are based on expressivity: formally defined according to
the order of types needed in typing, they describe different ``degrees
of mobility''.  Via fully abstract encodings, it is shown that that
name- and process-passing calculi with equal order of types have the
same expressiveness.  With respect to these previous results, our
approach based on session types has several important consequences and
allows us to derive new results.  Our study reinforces the intuitive
view of ``encodings as protocols'', namely session protocols which
enforce precise linear and shared disciplines for names, a distinction
not investigated in~\cite{SangiorgiD:expmpa,DBLP:journals/tcs/Sangiorgi01}. In
turn, the linear/shared distinction is central in proper definitions
of trigger processes, and are essential to encodings
(Def.~~\ref{d:enc:hopitopi}) and behavioral equivalences
(Defs.~\ref{d:hbw} and~\ref{d:fwb}).  More interestingly, we showed that
$\HO$ suffices to encode  the session
calculus with name passing ($\sessp$) but also $\HOp$ and its extension with
higher-order applications ($\HOpp$). Thus, using session types
all these calculi are shown to be equally expressive with fully
abstract encodings.  To our knowledge, these are the first
expressivity results of this kind.

The work~\cite{XuActa2012} studies the encodability of the higher-order $\pi$-calculus (extended with a relabeling operator) into the first-order $\pi$-calculus; encodings in the reverse direction are also proposed, following \cite{Tho90}.
A minimal calculus of higher-order concurrency is studied in~\cite{DBLP:journals/iandc/LanesePSS11}: it lacks restriction,  name passing, output prefix (so  communication is asynchronous), and constructs for infinite behavior. 
This calculus (a sublanguage of \HO) has 
a simple notion of (strong) bisimilarity which coincides with barbed congruence.
%be Turing complete, while 
%have a decidable notion of (strong) bisimilarity that coincides with barbed congruence. 

Our work is closely related in spirit to the expressiveness studies in~\cite{DBLP:conf/icalp/LanesePSS10,DBLP:conf/wsfm/XuYL13}.
In~\cite{DBLP:conf/icalp/LanesePSS10}
the core calculus in~\cite{DBLP:journals/iandc/LanesePSS11} is extended with restriction, output prefix (thus enabling synchronous communication), 
and polyadic communication. It is shown that 
synchronous communication can encode asynchronous communication, % (as in the first-order setting),
and that process passing polyadicity induces a hierarchy in expressive power, % (unlike the first-order setting).
A further extension with process abstractions of order one
(functions from processes to processes)
 is shown to strictly add expressive power with respect to passing of processes only.
The paper~\cite{DBLP:conf/wsfm/XuYL13} complements the study in~\cite{DBLP:conf/icalp/LanesePSS10} by deepening on the expressive power of second-order abstractions (similar to \HO). 
In that setting, name and process abstractions are distinguished and contrasted, also considering polyadicity of abstraction parameters (the same kind of polyadicity present in \pHOp). It is shown that polyadicity of process abstraction induces an expressiveness hierarchy. Moreover, it is shown that name abstraction can encode process abstraction, and therefore it may be considered as a more basic mechanism. 
The works~\cite{DBLP:conf/icalp/LanesePSS10,DBLP:conf/wsfm/XuYL13} focus on untyped processes;
therefore, our work complements their previous results by clarifying the status of typeful, resource-aware structured communications in
trigger-based representations of process passing, both in encodings and  equivalences.

\myparagraph{Session Typed Processes.}
Two works~\cite{DemangeonH11,Dardha:2012:STR:2370776.2370794} 
study encodings of binary session calculi into 
a linearly typed $\pi$-calculus. 
\cite{DemangeonH11}~gives a precise encoding of \sessp into a linear calculus 
based on~\cite{BHY},  
while~\cite{Dardha:2012:STR:2370776.2370794} 
gives the operational correspondence 
(without a full abstraction result)
for the first- and higher-order 
$\pi$-calculus (\cite{tlca07}) into \cite{LinearPi}. 
They investigate an embeddability of two different typing systems;
by the result of \cite{DemangeonH11}, \HOpp is further encodable precisely 
into the linearly typed $\pi$-calculi.     

The discipline developed for the $\HOp$ is a subset
of that in~\cite{tlca07,MostrousY15}.
\cite{tlca07} develops a full higher-order session calculus
with process abstractions and applications, hence  
treats the type 
$U=U_1 \rightarrow U_2 \dots U_n \rightarrow \Proc$ and its linear type 
$U^1$
which corresponds $\shot{\tilde{U}}$ and $\lhot{\tilde{U}}$ in 
a super-calculus of $\HOpp$ and $\PHOp$. 
%in~\cite{MostrousY15} in the asynchronous setting.
%The session type
%system considered is influenced by the type systems for $\lambda$-calculi and
%uses type syntax of the form $U_1 \rightarrow U_2 \dots U_n \rightarrow \Proc$
%for shared values and $(U_1 \rightarrow U_2 \dots U_n \rightarrow \Proc)^{1}$
%for linear values.
%Such a type is expressed in $\HOpp$
%terms using the type $\shot{U}$ (respectively, $\lhot{U}$)
%with $U$ being a nested higher-order type; and 
%the $\HOp$ uses only types of the form
%$\shot{C}$ and $\lhot{C}$ with $C$ being a first-order channel type.
Our results show
the calculus in~\cite{tlca07} is not only expressed but 
also reasoned in 
$\HO$ (with limited form of arrow types, $\shot{C}$ and $\lhot{C}$) and 
$\sessp$, via precise encodings. 

\myparagraph{Typed Behavioural Equivalences.}
The current work follows the principles for
session type behavioural semantics that were laid
by the previous works of the
authors~\cite{dkphdthesis,KYHH2015,KY2015,DBLP:journals/iandc/PerezCPT14}.
A bisimulation relation is defined on a labelled
transition system that assumes a session typed
observer.
The bisimilarity is characterised by the corresponding
reduction-closed, barb-preserving congruence using a
proof technique that is derived from~\cite{Hennessy07}.
The theory for higher-order session types developed here
differentiates from 
the work in~\cite{dkphdthesis,KYHH2015,KY2015}, which 
considers the behavioural semantics for first-order
binary and multiparty session types.
Also the work \cite{DBLP:journals/iandc/PerezCPT14} studies typed behavioral equivalencies for binary session types.
The underlying process languages does not have shared names which, as we have shown, strictly add expressive power. 
Moreover, for this deterministic language, confluence and $\tau$-inertness properties are established.

%The theory for higher-order session type quivalences is more challenging than
%their corresponding first-order bisimulation theory.
To cope with the challenges presented by the higher-order
session theory, 
our approach continues the line of research 
originally drawn by Sangiorgi~\cite{San96H,SangiorgiD:expmpa}
and later improved by Jeffrey and Rathke~\cite{JeffreyR05}.
The works %Sangiorgi as part of his Ph.D.~research
\cite{San96H,SangiorgiD:expmpa}
introduced the first fully abstract encoding from the higher-order 
$\pi$-calculus to the $\pi$-calculus. 
The replicated triggered process 
is also used in this work for the encoding of \HOp into \sessp (Definition~\ref{d:enc:hopitopi}).
Sangiorgi's encoding is based on the idea of a replicated input guarded process 
(called a trigger process). Operational correspondence for
the triggered encoding is shown using the contextual bisimulation
with first-order labels.
Although contextual bisimilarity has a satisfactory discriminative power,
its use is hindered by the universal quantification on output clauses.
Sangiorgi then proposed \emph{normal bisimilarity}, a tractable  equivalence 
on processes without universal quantification. 
To show the coincidence between contextual and normal bisimilarities, 
the use of triggered processes and bisimilarity is developed in \cite{San96H}.
%The encoding also motivates the definition of a form of
Triggered bisimulation is also defined on first-order labels
where the contextual bisimulation is restricted to arbitrary
trigger substitution rather than arbitrary process substitutions.
The triggered bisimulation was further refined by Jeffrey and
Rathke, who study calculi with recursive types, not addressed in~\cite{San96H,SangiorgiD:expmpa} and
relevant in our work.
They introduce their own version of a
bisimulation~\cite{JeffreyR05}
based on a LTS which is extended with trigger meta-notation.
%for a full higher-order $\pi$-calculus that allows
%higher-order applications.
Like Sangiorgi's approach, the labelled transition semantics
in~\cite{JeffreyR05}
observes first-order triggered values instead of
higher-order values, offering a more direct characterization of contextual equivalence
and lifting the restriction to finite types.


There are similarities and differences between of the characteristic bisimulation
and the bisimulation as defined by Jeffrey and Rathke
(below we use the meta-notation adopted in~\cite{JeffreyR05}):
%
\begin{enumerate}[i)]
	\item	The output of a higher-order value $\abs{x}{Q}$ on name
		$n$ in Jeffrey\&Rathke approach requires the output of
		a fresh trigger name $t$ (notation $\tau_t$)
		on channel $n$ 
		and then the introduction of a replicated triggered process
		(notation $(t \Leftarrow (x) Q)$)
		in the context of the acting process:
		%
		\[
			P \by{\news{t} \bactout{n}{\tau_{t}}} P' \Par (t \Leftarrow (x) Q) \by{\bactinp{t}{v}} P' \Par \appl{(x) Q}{v} \Par (t \Leftarrow (x) Q) 
		\]
		%
		In the characteristic bisimulation approach we only observe
		an output of a value that can be either first- or higher-order:
		%
		\[
			P \hby{\bactout{n}{V}} P' 
		\]
		%
		with $V = \abs{x}{Q}$ or $V = m$.
		A non-replicated triggered process appears in
		the parallel context of the acting process when
		we compare two processes for behavioural equality
		(cf.~characteristic bisimulation Definition~\ref{d:fwb}),
		$P' \Par \htrigger{t}{\abs{x}{Q}}$.
		In fact using the LTS in
		Definition~\ref{d:tlts} we can get:
		%
		\begin{eqnarray*}
			P' \Par \htrigger{t}{\abs{x}{Q}}
			&\by{\abs{z}{\binp{z}{y} \repl{} \binp{t}{x} \appl{y}{x}}}&
			P' \Par \newsp{s}{\binp{s}{y} \repl{} \binp{t}{x} \appl{y}{x} \Par \bout{s}{\abs{x}{Q}} \inact}\\
			&\by{\tau}&
			P' \Par \repl{}\binp{t}{y} \appl{\abs{x}{Q}}{y}
		\end{eqnarray*}
		%
		that simulates the Jeffrey\&Rathke approach.

		The characteristic bisimulation differentiates from
		the Jeffrey\&Rathke approach:
		\begin{enumerate}[$\bullet$]
			\item	The typed LTS predicts the case of linear
				output values and will never allow replication
				of such a value;
				if $V$ is linear the input action would have no replication
				operator, as
				$\abs{z}{\binp{z}{y} \binp{t}{x} \appl{y}{x}}$.

			\item	The characteristic bisimulation introduces a uniform approach
				not only for
				higher-order values but for first-order values
				as well. A triggered process can accept any
				process that can substitute a first-order value as well.
				This is derived from the fact that the $\HOp$
				calculus makes no use of a matching operator, in contrast
				to the calculus defined in~\cite{JeffreyR05})
				where name matching is crucial to prove completness
				of the bisimilarity relation.
				We chose not to include the matching operator
				because of the requirement of a minimal calculus.
				In the lack of matching we use types to inhabit
				a value so we can observe its simplest interaction
				with the process environment.

			\item	The \HOp calculus requires only first-order
				applications. Higher-order applications,
				as in the Jeffrey\&Rathke work,
				are presented as an extension in the \HOpp
				calculus.

			\item	The trigger process is non-replicated. In fact
				the trigger process transforms guards the output
				value with a higher-order input prefix. The
				functionality of the input is used to
				simulate the contextual bisimilarity that subsumes
				the replicated trigger approach.
				The transformation of an output action as an input
				action allows for treating an output
				using the restricted LTS~\ref{def:rlts}:
				%
				\[
					P' \Par \htrigger{t}{\abs{x}{Q}} \hby{\bactinp{t}{\abs{x}{\mapchar{U}{x}}}}
					P' \Par \news{s}{ \appl{\mapchar{U}{x}}{s} \Par \bout{\dual{s}}{\abs{x}{Q}} \inact}
				\]
		\end{enumerate}
		%
		%In essence we are transforming a replicated trigger into a process
		%that is input-prefixed on a fresh name that receives a higher-order
		%value;

	\item	The input of a higher-order value in the Jeffrey\&Rathke approach requires 
		the input of a fresh trigger name, which is substituted on the application
		variable, thus having a meta-suntax for triggered application instead
		of higher-order applications:
		%
		\[
			\binp{n}{x} P \by{\bactinp{n}{\tau_k}} \appl{\abs{x}{P}}{\tau_k} \by{\tau} P \subst{x}{\tau_k} 
		\]
		%
		with every instance of process variable $x$ in $P$ being substituted
		with trigger value $\tau_k$ to give a process of the form $\appl{\tau_k}{x}$.
		The approach in the characteristic bisimulation observes the
		triggered value
		$\abs{z}\binp{t}{x} \appl{x}{z}$ as an input instead of the
		trigger name:
		%
		\[
			P \hby{\bactinp{n}{\abs{z}\binp{t}{x} \appl{x}{z}}} P \subst{\abs{z}\binp{t}{x} \appl{x}{z}}{x}
		\]
		%
		with applications being transformed to
		$\abs{z}{\binp{t}{x} \appl{x}{z}}{v}$
		Note that in the characteristic bisimulation semantics
		we can also observe a characteristic process as an input.
		
	\item 	Triggered application in the Jeffrey\&Rahtke
		are observe using an output
		lead into an output observation of the
		application value over
		the fresh trigger name.
		%
		\[
			\appl{\tau_k}{v} \by{\bactout{k}{v}} \inact
		\]
		%
		In the characteristic bisimulation instead of observing an 
		application and its value as an action we observe:
		i) the name of the trigger through the trigger value
		application; and ii) the application
		value by inhabiting it in the characteristic value
		and observing the interaction of the corresponding
		characteristic process with its environment.
		%
		\begin{eqnarray*}
			\appl{\abs{z}{\binp{t}{x} \appl{x}{z}}}{v} &\by{\tau}& \binp{t}{x} \appl{x}{v}
			\by{\bactinp{t}{\abs{x}{\mapchar{U}{x}}}}
			\appl{\abs{x}{\mapchar{U}{x}}}{v}
			\by{\tau} \mapchar{U}{x} \subst{n}{x}
		\end{eqnarray*}
		%
\end{enumerate}

%The main differences of the triggered
%bisimulation approach comparing to our approach are:
%i) We use observe higher-order values on the LTS in contrast to first-order 
%values in~\cite{DBLP:journals/lmcs/JeffreyR05}.
%ii) In our approach we avoid the replicated triggered process,
%by transforming the output process into a higher-order guarded input.
%iii) The triggered bisimulation gives semantics for higher-order application,
%whereas in our approach we give semantics for first-order applications
%and show that higher-order applications are fully encodable.

%Boreale and Sangiorgi, 
%Deng and Hennessy, 
%Jeffrey and Rathke, Hennessy and Koutavas, Schmitt and Lenglet, Pi\E9rard and Sumii.
%Perez et al (bisimilarities for binary sessions), Kouzapas and Yoshida (bisimilarities for binary and multiparty sessions).
%Bisimilarities for HO processes: \cite{Xu07}.

Sangiorgi et al.~\cite{DBLP:conf/lics/SangiorgiKS07}, use a higher-order LTS 
to define an arguably complex bisimulation relation that stores the knowledge known to
the observer, thus the observation actions are based on the observer's knowledge
at any given time. 
The environmental bisimulation approach is simplified by Koutavas and
Hennessy in~\cite{DBLP:journals/cl/KoutavasH12,DBLP:conf/esop/KoutavasH11}
with the introduction
of a mapping from constants to higher-order values. This
technique allows for the observation of first-order values instead
of higher-order values. It differs from the approaches
in~\cite{San96H,JeffreyR05} because the
mapping between higher and first order values is no longer implicit.





