We present two encodings:
\begin{enumerate}
\item The higher-order name-passing communication (\HOp) into 
the higher-order communication without name-passing nor 
recursions (\HO) (\S\,\ref{ss:ffotoho})
\item the higher-order communication without 
name-passing and recursions (\HO)
into the first-order name-passing communication
with recursions (\sessp) (\S\,\ref{ss:hotofo})
\end{enumerate}
By (1), we can encode \sessp into \HO and by (2), 
we can encode \HOp into \sessp.  
Note that it is obvious that \HOp can encode both 
$\HO$ and $\sessp$ by the identitiy mapping. 

\subsection{From \sessp to \HO}
\label{subsec:sesspHO}

\begin{definition}\rm 
	Let $\vmap{\cdot}: 2^{\mathcal{N}} \longrightarrow \mathcal{V}^\omega$
	be a map of sequences of 
lexicographically ordered names to sequences of variables, defined
	inductively as: 
	$\vmap{\epsilon} = \epsilon$ and $\vmap{n \cat \tilde{m}} = x_n \cat \vmap{\tilde{m}}$. 
\end{definition}

\begin{definition}\label{d:trabs}\label{d:auxmap}
	Let $\sigma$ be a set of session names.
	Define $\auxmapp{\cdot}{\mathsf{v}}{\sigma}: \HOp^{-\mu} \to \HOp^{-\mu}$ as in Fig.~\ref{f:auxmap}.
%
\begin{figure}[t]
\[
\small
\begin{array}{rcl}
	\auxmapp{\bout{n}{\abs{x}{Q}} P}{{}}{\sigma} &=&
		\bout{u}{\abs{(x,\vmap{\fn{P}})}{\auxmapp{Q}{{}}{\sigma}}} \auxmapp{P}{{}}{\sigma}
\\[1mm]
\auxmapp{\bout{n}{m} P}{{}}{\sigma} =
	    \bout{u}{v}\auxmapp{P}{{}}{\sigma} 
& & 
			\auxmapp{\binp{n}{x} P}{{}}{\sigma} =
		\binp{u}{x} \auxmapp{P}{{}}{\sigma} 
\\[1mm]
	\auxmapp{\bsel{n}{l} P}{{}}{\sigma} =
		\bsel{u}{l} \auxmapp{P}{{}}{\sigma} 
& & 
	\auxmapp{\bbra{n}{l_i:P_i}_{i \in I}}{{}}{\sigma}  = 
		\bbra{u}{l_i:\auxmapp{P_i}{{}}{\sigma}}_{i \in I}
	\vspace{1mm} \\
	\auxmapp{\appl{x}{n}}{{}}{\sigma}  = 
		\appl{x}{u} 
& & 
\auxmapp{\news{n} P}{{}}{\sigma}  =  \news{n} \auxmapp{P}{{}}{{\sigma \cat n}}
	\vspace{1mm} \\
	\auxmapp{\inact}{{}}{\sigma}  =  \inact & & 
	\auxmapp{P \Par Q}{{}}{\sigma}  =  \auxmapp{P}{{}}{\sigma} \Par \auxmapp{Q}{{}}{\sigma} 
\end{array}
\]
%\[
%	\begin{array}{rcl}
%          \auxmapp{\news{n} P}{{}}{\sigma} &\bnfis& \news{n} \auxmapp{P}{{}}{{\sigma \cat n}}
%		\vspace{1mm} \\
%		\auxmapp{\bout{n}{\abs{x}{Q}} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\bout{x_n}{\abs{(x,\vmap{\fn{P}})}{\auxmapp{Q}{{}}{\sigma}}} \auxmapp{P}{{}}{\sigma} & n \notin \sigma\\
%			\bout{n}{\abs{(x,\vmap{\fn{P}})}{\auxmapp{Q}{{}}{\sigma}}} \auxmapp{P}{{}}{\sigma} & n \in \sigma
%		\end{array}
%		\right.
%			\vspace{1mm}	\\ 
%		\auxmapp{\bout{n}{m} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%		    \bout{n}{m}\auxmapp{P}{{}}{\sigma} & n, m \in \sigma \\
%		    \bout{x_n}{m}\auxmapp{P}{{}}{\sigma} & n \not\in \sigma, m \in \sigma \\
%		    \bout{n}{x_m}\auxmapp{P}{{}}{\sigma} & n \in \sigma, m \not\in \sigma \\
%		    \bout{x_n}{x_m}\auxmapp{P}{{}}{\sigma} & n, m \not\in \sigma 
%		\end{array}
%		\right.
%		\vspace{1mm} \\ 
%				\auxmapp{\binp{n}{X} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\binp{x_n}{X} \auxmapp{P}{{}}{\sigma} & n \notin \sigma\\
%			\binp{n}{X} \auxmapp{P}{{}}{\sigma} & n \in \sigma
%		\end{array}
%		\right.
%			\vspace{1mm}	\\ 
%		\auxmapp{\binp{n}{x}P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%		    \binp{n}{x}\auxmapp{P}{{}}{\sigma} & n \in \sigma \\
%		    \binp{x_n}{x}\auxmapp{P}{{}}{\sigma} & n \not\in \sigma 
%		\end{array}
%		\right.
%		\vspace{1mm} \\ 
%		\auxmapp{\bsel{n}{l} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\bsel{x_n}{l} \auxmapp{P}{{}}{\sigma} & n \notin \sigma\\
%			\bsel{n}{l} \auxmapp{P}{{}}{\sigma} & n \in \sigma
%		\end{array}
%		\right.
%		\vspace{1mm} \\
%		\auxmapp{\bbra{n}{l_i:P_i}_{i \in I}}{{}}{\sigma} &\bnfis&
%		%\auxmapp{\bsel{n}{l} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\bbra{x_n}{l_i:\auxmapp{P_i}{{}}{\sigma}}_{i \in I}  & n \notin \sigma\\
%			\bbra{n}{l_i:\auxmapp{P_i}{{}}{\sigma}}_{i \in I}  & n \in \sigma
%		\end{array}
%		\right.
%		\vspace{1mm} \\
%		\auxmapp{\appl{\X}{n}}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\appl{\X}{x_n} & n \notin \sigma\\
%			\appl{\X}{n} & n \in \sigma\\
%		\end{array}
%		\right. \\
%		\auxmapp{\inact}{{}}{\sigma} &\bnfis& \inact\\
%		\auxmapp{P \Par Q}{{}}{\sigma} &\bnfis& \auxmapp{P}{{}}{\sigma} \Par \auxmapp{Q}{{}}{\sigma} 
% \end{array}
%\]
%The auxiliary map (cf. Definition~\ref{d:auxmap}) 
%used in the encoding of the higher-order communication 
%with recursive definitions into higher-order communication 
%without recursive definitions and (Definition~\ref{d:enc:fotohorec}).
In each mapping, $u = n$ if $n\in \sigma$; otherwise $u = x_n$; and  
$v = m$ if $m\in \sigma$; otherwise $v = x_m$. 
We assume $\fn{P}$ denotes a sequence of lexicopraphically ordered 
free names in $P$. 
%The mapping is defined homomorphically for inaction and parallel composition.
\caption{\label{f:auxmap} A triger mapping}
\end{figure}
\end{definition}

Given a process $P$ with $\fn{P} = m_1, \cdots, m_n$, we are interested in its associated abstraction, which is defined as
$\abs{x_1, \cdots, x_n}{\auxmapp{P}{{}}{\epsilon} }$, where $\vmap{m_j} = x_j$, for all $j \in \{1, \ldots, n\}$.
This transformation from processes into abstractions can be reverted by
using abstraction and application with an appropriate sequence of session names:
%
\begin{proposition}\rm
	Let $P$ be a \HOp process and 
	suppose $\tilde{x} = \vmap{\tilde{n}}$ where 
$\tilde{n} = \fn{P}$.
	Then $P \scong \appl{(\abs{\tilde{x}}{\auxmapp{P}{{}}{\emptyset}})}{\tilde{n}}$.
%	$\appl{X}{\smap{\fn{P}}} \subst{(\vmap{\fn{P}}) \map{P}^{\emptyset}}{X} \scong P$
\end{proposition}



