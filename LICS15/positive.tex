% !TEX root = main.tex
\noi This section presents two encodabilty results:
(1)~The higher-order name-passing communication with recursions (\HOp) into 
the higher-order communication without name-passing nor 
recursions (\HO) (\S\,\ref{subsec:HOpi_to_HO}); and 
(2)~\HOp into the first-order name-passing communication
with recursions (\sessp) (\S\,\ref{subsec:HOp_to_sessp}). 

 


\subsection{From \HOp to \HO}
\label{subsec:HOpi_to_HO}
\noi We show that $\HO$ is expressive enough to
represent the full \HOp-calculus.
The main challenge here is to encode (1) name passing 
and (2) recursions, 
for which 
we only use name abstraction passing. For (1), we pass  
a simple abstraction which enables to use the name upon application. 
For (2), we 
copy a process upon reception; the case of linear abstraction passing
presents a limitation because 
a linear abstraction cannot be copied.
To handle linearity, we define a preliminary tool which is a mapping from
processes to processes with no free names (but with free variables) (Definition~\ref{d:auxmap}). 

We first require an auxiliary definition.

\smallskip 

\begin{definition}\rm 
\label{def:hop_to_ho}
	Let $\vmap{\cdot}: 2^{\mathcal{N}} \longrightarrow \mathcal{V}^\omega$
	be a map of sequences of 
lexicographically ordered names to sequences of variables, defined
	inductively as: 
	$\vmap{\epsilon} = \epsilon$ and $\vmap{n \cat \tilde{m}} = x_n \cat \vmap{\tilde{m}}$. 
\end{definition}

\smallskip 

\noi The following trigger mapping transforms processes
with free names into abstractions. 

\smallskip 

\begin{definition}[Trigger Mapping] \label{d:trabs}\label{d:auxmap}
	Let $\sigma$ be a set of session names.
	Fig.~\ref{f:auxmap} defines a trigger mapping
$\auxmapp{\cdot}{{}}{\sigma}: \HO \to \HO$.
\end{definition}

%
\begin{figure}[t]
\[
\small
\begin{array}{rl}
	\auxmapp{\bout{n}{\abs{x}{Q}} P}{{}}{\sigma} &\!\!\!\!\!\!\defeq
		\bout{u}{\abs{x}{\auxmapp{Q}{{}}{\sigma}}} \auxmapp{P}{{}}{\sigma}
\\[1mm]
%\auxmapp{\bout{n}{m} P}{{}}{\sigma} \defeq
%	    \bout{u}{v}\auxmapp{P}{{}}{\sigma} 
	\auxmapp{\appl{x}{n}}{{}}{\sigma}  \defeq
		\appl{x}{u} \quad 
	\auxmapp{\inact}{{}}{\sigma}  \defeq  \inact
 & 
			\auxmapp{\binp{n}{x} P}{{}}{\sigma}\defeq
		\binp{u}{x} \auxmapp{P}{{}}{\sigma} 
\\[1mm]
	\auxmapp{\bsel{n}{l} P}{{}}{\sigma} \defeq
		\bsel{u}{l} \auxmapp{P}{{}}{\sigma} 
 & 
	\auxmapp{\bbra{n}{l_i:P_i}_{i \in I}}{{}}{\sigma}  \defeq 
		\bbra{u}{l_i:\auxmapp{P_i}{{}}{\sigma}}_{i \in I}
	\vspace{1mm} \\
\auxmapp{\news{n} P}{{}}{\sigma}  \defeq  \news{n} \auxmapp{P}{{}}{{\sigma \cat n}}
 & 
	\auxmapp{P \Par Q}{{}}{\sigma}  \defeq  \auxmapp{P}{{}}{\sigma} \Par \auxmapp{Q}{{}}{\sigma} 
\end{array}
\]
%\[
%	\begin{array}{rcl}
%          \auxmapp{\news{n} P}{{}}{\sigma} &\bnfis& \news{n} \auxmapp{P}{{}}{{\sigma \cat n}}
%		\vspace{1mm} \\
%		\auxmapp{\bout{n}{\abs{x}{Q}} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\bout{x_n}{\abs{(x,\vmap{\fn{P}})}{\auxmapp{Q}{{}}{\sigma}}} \auxmapp{P}{{}}{\sigma} & n \notin \sigma\\
%			\bout{n}{\abs{(x,\vmap{\fn{P}})}{\auxmapp{Q}{{}}{\sigma}}} \auxmapp{P}{{}}{\sigma} & n \in \sigma
%		\end{array}
%		\right.
%			\vspace{1mm}	\\ 
%		\auxmapp{\bout{n}{m} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%		    \bout{n}{m}\auxmapp{P}{{}}{\sigma} & n, m \in \sigma \\
%		    \bout{x_n}{m}\auxmapp{P}{{}}{\sigma} & n \not\in \sigma, m \in \sigma \\
%		    \bout{n}{x_m}\auxmapp{P}{{}}{\sigma} & n \in \sigma, m \not\in \sigma \\
%		    \bout{x_n}{x_m}\auxmapp{P}{{}}{\sigma} & n, m \not\in \sigma 
%		\end{array}
%		\right.
%		\vspace{1mm} \\ 
%				\auxmapp{\binp{n}{X} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\binp{x_n}{X} \auxmapp{P}{{}}{\sigma} & n \notin \sigma\\
%			\binp{n}{X} \auxmapp{P}{{}}{\sigma} & n \in \sigma
%		\end{array}
%		\right.
%			\vspace{1mm}	\\ 
%		\auxmapp{\binp{n}{x}P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%		    \binp{n}{x}\auxmapp{P}{{}}{\sigma} & n \in \sigma \\
%		    \binp{x_n}{x}\auxmapp{P}{{}}{\sigma} & n \not\in \sigma 
%		\end{array}
%		\right.
%		\vspace{1mm} \\ 
%		\auxmapp{\bsel{n}{l} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\bsel{x_n}{l} \auxmapp{P}{{}}{\sigma} & n \notin \sigma\\
%			\bsel{n}{l} \auxmapp{P}{{}}{\sigma} & n \in \sigma
%		\end{array}
%		\right.
%		\vspace{1mm} \\
%		\auxmapp{\bbra{n}{l_i:P_i}_{i \in I}}{{}}{\sigma} &\bnfis&
%		%\auxmapp{\bsel{n}{l} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\bbra{x_n}{l_i:\auxmapp{P_i}{{}}{\sigma}}_{i \in I}  & n \notin \sigma\\
%			\bbra{n}{l_i:\auxmapp{P_i}{{}}{\sigma}}_{i \in I}  & n \in \sigma
%		\end{array}
%		\right.
%		\vspace{1mm} \\
%		\auxmapp{\appl{\X}{n}}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\appl{\X}{x_n} & n \notin \sigma\\
%			\appl{\X}{n} & n \in \sigma\\
%		\end{array}
%		\right. \\
%		\auxmapp{\inact}{{}}{\sigma} &\bnfis& \inact\\
%		\auxmapp{P \Par Q}{{}}{\sigma} &\bnfis& \auxmapp{P}{{}}{\sigma} \Par \auxmapp{Q}{{}}{\sigma} 
% \end{array}
%\]
%The auxiliary map (cf. Definition~\ref{d:auxmap}) 
%used in the encoding of the higher-order communication 
%with recursive definitions into higher-order communication 
%without recursive definitions and (Definition~\ref{d:enc:fotohorec}).
$u = n$ if $n\in \sigma$; otherwise $u = x_n$, and  
$\fn{P}$ denotes a sequence of lexicopraphically ordered 
free names in $P$. 
%The mapping is defined homomorphically for inaction and parallel composition.
\caption{\label{f:auxmap} A trigger mapping.}
\Hline 
\end{figure}

\smallskip 

\noi Given a process $P$ with $\fn{P} = m_1, \cdots, m_n$, we are interested in its associated abstraction, which is defined as
$\abs{x_1\cdots x_n}{\auxmapp{P}{{}}{\emptyset} }$, where $\vmap{m_j} = x_j$, for all $j \in \{1, \ldots, n\}$. 

%This transformation from processes into abstractions can be reverted by
%using abstraction and application with an appropriate sequence of session names:
%%
%\begin{proposition}\rm
%	Let $P$ be a \HOp process and 
%	suppose $\tilde{x} = \vmap{\tilde{n}}$ where 
%$\tilde{n} = \fn{P}$.
%	Then $P \scong \appl{(\abs{\tilde{x}}{\auxmapp{P}{{}}{\emptyset}})}{\tilde{n}}$.
%%	$\appl{X}{\smap{\fn{P}}} \subst{(\vmap{\fn{P}}) \map{P}^{\emptyset}}{X} \scong P$
%\end{proposition}

\begin{figure}[t]
\[
\begin{array}{rcll}
\noindent{\bf Types:}\quad\quad\quad\quad\quad\quad
	\vtmap{{S}}{1}	&\!\!\defeq\!\!&	\lhot{(\btinp{\lhot{\tmap{S}{1}}} \tinact)} \\
	\vtmap{\chtype{S}}{1}&\!\!\defeq\!\!&	\lhot{(\btinp{\shot{\chtype{\tmap{S}{1}}}} \tinact)}  \\
	\vtmap{\chtype{L}}{1}&\!\!\defeq\!\!&	\lhot{(\btinp{\shot{\chtype{\tmap{L}{1}}}} \tinact)} \\
	\vtmap{\lhot{C}}{1} \!\!\defeq\!\! \lhot{\tmap{C}{1}}&& 
	\vtmap{\shot{C}}{1} \!\!\defeq\!\! \shot{\tmap{C}{1}}\\
	\tmap{\chtype{S}}{1} \!\!\defeq\!\!	\chtype{\tmap{S}{1}}  &&
	\tmap{\chtype{L}}{1} \!\!\defeq\!\!	\chtype{\tmap{L}{1}}  \\
	%		\tmap{\btout{S_1} {S} }{1}	&\!\!\defeq\!\!&	\bbtout{\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}} \tmap{S}{1}  \\
	%		\tmap{\btinp{S_1} S }{1}	&\!\!\defeq\!\!&	\bbtinp{\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}} \tmap{S}{1} \\
	%		\tmap{\bbtout{\chtype{U}} {S} }{1}	&\!\!\defeq\!\!&	\bbtout{\shot{\btinp{\shot{\chtype{\tmap{U}{1}}}}\tinact}} \tmap{S}{1}  \\
	%		\tmap{\bbtinp{\chtype{U}} {S} }{1}	&\!\!\defeq\!\!&	\bbtinp{\shot{\btinp{\shot{\chtype{\tmap{U}{1}}}}\tinact}} \tmap{S}{1} \\

	\tmap{\btout{U} S}{1} \!\!\defeq\!\! \btout{{\vtmap{U}{1}}} \tmap{S}{1}&&
	\tmap{\btinp{U} S}{1} \!\!\defeq\!\! \btinp{{\vtmap{U}{1}}} \tmap{S}{1}\\
	\tmap{\btsel{l_i: S_i}_{i \in I}}{1} &\!\!\defeq\!\!& \btsel{l_i: \tmap{S_i}{1}}_{i \in I}\\
			\tmap{\btbra{l_i: S_i}_{i \in I}}{1} &\!\!\defeq\!\!& \btbra{l_i: \tmap{S_i}{1}}_{i \in I}\\
	\tmap{\vart{t}}{1} \defeq \vart{t} \quad 
			\tmap{\trec{t}{S}}{1}  &\!\!\defeq\!\!&
	\trec{t}{\tmap{S}{1}}\quad 
	\tmap{\tinact}{1}  \defeq  \tinact\\[1mm]
	\hline
	%\end{array}
	%\]
	%\[
	%\begin{array}{rcll}
	\noindent{\bf Labels:} \quad \quad
		\mapa{(\nu \tilde{m})\bactout{n}{m}}^{1} &\!\!\defeq\!\!&   
(\nu \tilde{m})\bactout{n}{\abs{z}{\,\binp{z}{x} (\appl{x}{m})} } \\
		\mapa{\bactinp{n}{m}}^{1} &\!\!\defeq\!\!&   \bactinp{n}{\abs{z}{\,\binp{z}{x} (\appl{x}{m})} } \\
	\mapa{(\nu \tilde{m})\bactout{n}{\abs{{x}}{P}}}^{1} &\!\!\defeq\!\!& 
(\nu \tilde{m})\bactout{n}{\abs{{x}}{\pmapp{P}{1}{\es}}}\\
			\mapa{\bactinp{n}{\abs{{x}}{P}}}^{1} &\!\!\defeq\!\!& \bactinp{n}{\abs{{x}}{\pmapp{P}{1}{\es}}}\\
			\mapa{\bactsel{n}{l} }^{1} \!\defeq\! \bactsel{n}{l} 
	\quad 
			\mapa{\bactbra{n}{l} }^{1} &\!\!\defeq\!\!& \bactbra{n}{l} 
	\quad \quad 
			\mapa{\tau}^{1} \!\defeq\! \tau
\\[1mm]
\hline
\end{array}
\]
{\bf Terms} : 
\[
\begin{array}{rcll}
  \pmapp{\bout{u}{w} P}{1}{f}	&\!\!\defeq\!\!&	\bout{u}{ \abs{z}{\,\binp{z}{x} (\appl{x}{w})} } \pmapp{P}{1}{f} \\
  \pmapp{\binp{u}{\AT{x}{C}} Q}{1}{f}	&\!\!\defeq\!\!&	\binp{u}{y} \newsp{s}{\appl{y}{s} \Par \bout{\dual{s}}{\abs{x}{\pmapp{Q}{1}{f}}} \inact} \\
		\pmapp{\bout{u}{\abs{{x}}{Q}} P}{1}{f}  
&\!\!\defeq\!\!& \bout{u}{\abs{{x}}{\pmapp{Q}{1}{f}}} \pmapp{P}{1}{f} \\
		\pmapp{\binp{u}{\AT{x}{L}} P}{1}{f} &\!\!\defeq\!\!& \binp{u}{x} \pmapp{P}{1}{f}\\
		\pmapp{\bsel{s}{l} P}{1}{f} &\!\!\defeq\!\!& \bsel{s}{l} \pmapp{P}{1}{f}\\
		\pmapp{\bbra{s}{l_i: P_i}_{i \in I}}{1}{f} &\!\!\defeq\!\!& \bbra{s}{l_i: \pmapp{P_i}{1}{f}}_{i \in I}\\
		\pmapp{\inact}{1}{f} \!\!\defeq\!\!\inact
& & 
		\pmapp{\news{n} P}{1}{f} \!\!\defeq\!\! \news{n} \pmapp{P}{1}{f}\\
\pmapp{{x}\, {u}}{1}{f}
 \!\!\defeq\!\!
{x}\, {u}
& & 		\pmapp{P \Par Q}{1}{f} \!\!\defeq\!\! \pmapp{P}{1}{f} \Par \pmapp{Q}{1}{f} \\
		\pmapp{\recp{X}{P}}{1}{f} &\!\!\defeq\!\!&\!\!\!\!\!\!
	
\\
& &\hspace{-12mm}\!\!\!\!\!\!\newsp{s}{\bout{\dual{s}}{\abs{(\vmap{\tilde{n}}, y)} 
\,{\binp{y}{z_\X} \auxmapp{\pmapp{P\subst{z_\X}{\X}}{1}{{f,\{z_\rvar{X}\to \tilde{n}\}}}}{{}}{\es}}} \inact
\\ 
& & \hspace{-3mm}\!\!\!\!\!\!
 \Par 
\binp{s}{z_\X} \pmapp{P\subst{z_X}{X}}{1}{{f,\{z_\rvar{X}\to \tilde{n}\}}}
} 
\quad (\tilde{n} = \fn{P}) \\ 
\pmapp{z_\rvar{X}}{1}{f} &\!\!\defeq\!\!& \hspace{-3mm}\newsp{s}{
\appl{z_X}{(\tilde{n}, s)}\\
& & \hspace{-3mm} \Par \bbout{\dual{s}}{ \abs{(\vmap{\tilde{n}},y)}{\appl{z_X}{(\vmap{\tilde{n}}, y)}}} \inact}  \quad (\tilde{n} = f(z_\rvar{X})) \\
\end{array}
\]
The input bound variable $x$ is annotated by a type to distinct the first-order and higher-order cases. 
\caption{\label{f:enc:hopi_to_ho}
Encoding of \HOp into \HO.
%(cf.~Defintion~\ref{d:enc:fotohorec}).
%Mappings 
%$\map{\cdot}^2$,
%$\mapt{\cdot}^2$, 
%and 
%$\mapa{\cdot}^2$
%are homomorphisms for the other processes/types/labels. 
}
\Hline
\end{figure}

\smallskip 

\begin{definition}[Typed Encoding of \HOp into \HO]
\label{d:enc:hopitoho}
Let $f$ be a function from variables to sequences of name variables.
%
%Let $\tyl{L}_{\HOp}=\calc{\HOp}{{\cal{T}}_1}{\hby{\ell}}{\wb_H}{\proves}$
%and 
%$\tyl{L}_{\HO}=\calc{\HO}{{\cal{T}}_2}{\hby{\ell}}{\wb_H}{\proves}$. 
%where 
%${\cal{T}}_1$ and ${\cal{T}}_2$ are sets of types of $\HOp$ 
%and $\HO$, respectively, 
%the typing $\proves$ is defined in 
%Fig.~\ref{fig:typerulesmy} 
%and $\hwb$ is defined in Definition~\ref{d:hbw}. 
We define the typed encoding 
$\enco{\map{\cdot}^{1}_f, \mapt{\cdot}^{1}, \mapa{\cdot}^{1}}: \tyl{L}_{\HOp} \to \tyl{L}_{\HO}$ in 
Fig.~\ref{f:enc:hopi_to_ho}. 
We assume that the mapping $\mapt{\cdot}^{1}$ on types is extended to 
session environments $\Delta$
and
shared environments $\Gamma$ homomorphically with: 
\[
	\begin{array}{l}
%	    \mapt{\Delta \cat s: S}^{1} & =  & \mapt{\Delta}^{1} \cat s:\mapt{S}^{1} & \\
%		\mapt{\Gamma \cat u: \chtype{S}}^{1} & =  & \mapt{\Gamma}^{1} \cat u:\chtype{\mapt{S}^{1}} & \\
%		\mapt{\Gamma \cat u: \chtype{L}}^{1} & = &  \mapt{\Gamma}^{1} \cat u:\chtype{\mapt{L}^{1}} & \\
		\tmap{\Gamma \cat \varp{X}:\Delta}{1}  =  \tmap{\Gamma}{1} \cat x:\shot{(S_1,..,S_m,S^*)} \ 
	\end{array}
\]
with
$S^* = \trec{t}{\btinp{\shot{(S_1,...,S_m,\vart{t})}} \tinact}$
%and $\Delta = \{n_1:S_1, \ldots, n_m:S_m\}$. 
and $\Delta = \{n_i:S_i\}_{1\leq i\leq m}$. 
\end{definition}

\smallskip 
\noi Note that $\varp{X}:\Delta$ is mapped to a recursive session type 
which carries type variable as the last argument.  
For a simplicity of the presentation, we use the polyadic name abstraction and passing. They will be formally encoded into \HO in \S~\ref{sec:extension}.

\noi We explain the mapping in Fig.~\ref{f:enc:hopi_to_ho}, focusing 
on {\em name passing} ($\pmapp{\bout{u}{w} P}{1}{f}$) and  
{\em recursions} ($\pmapp{\recp{X}{P}}{1}{f}$ and $\pmapp{z_\rvar{X}}{1}{f}$). 

{\bf\em Name passing:}
A name $m$ is being passed as an input
guarded abstraction. 
The input prefix receives an abstraction and
continues with the application of $n$ over the received abstraction.
On the receiver side $\binp{u}{x} P$ 
the encoding realises a mechanism that (i) receives
the input guarded abstraction, then (ii) applies it on a fresh session endpoint $s$, 
and (iii) uses
the dual endpoint $\dual{s}$ to send the continuation $P$ as the abstraction
$\abs{x}{P}$. 
As a result, name substitution is achieved via name application.


{\bf\em Recursions:} The idea follows 
a classical recursion encoding \cite{ThomsenB:plachoasgcfhop}.  
A mapping of process $P$ is parallel composed, 
and also being passed as an input
guarded abstraction, parameterised also by a sequence of trigger names $\tilde{n}$. 
We record a mapping from $z_X$ (which is a fresh variable of $X$) 
to $\tilde{n}$, so that 
when the abstraction is substituted to $z_\rvar{X}$ 
(which occurs in the mapping of $P\subst{z_X}{X}$), 
the correct $\tilde{n}$ is applied. In this way, we can 
send and receive an abstraction which holds $P$, repeatedly. 

\smallskip  

\noi Processes that do not use shared names, are inherently deterministic. 
The following lemma is useful for both positive and negative results. 

%\smallskip 

\begin{lemma}[$\tau$-Inertness]\rm
\label{lem:tau_inert}
\begin{enumerate}
\item (deterministic transitions) 
Transition $\horel{\Gamma}{\Delta}{P}{\hby{\tau}}{\Delta'}{P'}$ is called
{\em deterministic} if it is derived by $\ltsrule{App}$ or 
$\ltsrule{Tau}$ where $\subj{\ell_1}$ and $\subj{\ell_2}$ in the premise 
are dual session names. Suppose $\Delta$ is balanced. Then 
$\Gamma; \Delta \proves P \cong \Delta'\proves P'$ 
with $\Delta \red^\ast \Delta'$ balanced. 
\item 
Let $P$ is the $\HOp^{-\mathsf{sh}}$-calculus. 
Assume $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$. Then 
$P \red^\ast P'$ implies $\Gamma; \Delta \proves 
P \cong \Delta'\proves P'$ with $\Delta \red^\ast \Delta'$. 
\end{enumerate}
\end{lemma}



\smallskip 

\begin{theorem}[Precise Encoding of \HOp into \HO]
\label{f:enc:hopitoho}
The encoding from $\tyl{L}_{\HOp}$ into $\tyl{L}_{\HO}$ (cf. Definition~\ref{d:enc:hopitoho})
is precise. 
\end{theorem}

\subsection{From \HOp to \sessp}
\label{subsec:HOp_to_sessp}
\noi 
We now discuss the encodability of  $\HO$ into $\sessp$ where
we essentially follow the representability result put forward by 
Sangiorgi~\cite{San92,SaWabook}, but casted in the setting of session-typed communications. 
Intuitively, such a strategy represents the exchange of a process with the exchange of a freshly generated \emph{trigger name}. 
Trigger names may then be used to activate copies of the process, which now becomes a persistent resource represented by an input-guarded replication.
A session name 
is, however, a linear resource and cannot be replicated.
Consider the following (naive) adaptation of \cite{San92,SaWabook} 
in which session names are used are triggers and 
exchanged processes would be have to used exactly once:
%
\[
\begin{array}{l}
		\pmap{\bout{u}{\abs{x}{Q}} P}{n}  \defeq   \newsp{s}{\bout{u}{s} (\pmap{P}{n} \Par \binp{\dual{s}}{x} \pmap{Q}{n})} \\
		\pmap{\binp{u}{x} P}{n}  \defeq \binp{u}{x} \pmap{P}{n}
\quad 
		\pmap{\appl{x}{u}}{n}  \defeq  \bout{x}{u} \inact
	\end{array}
\]
%
with the remaining \HOp constructs being mapped homomorphically.
Although $\pmap{\cdot}{n}$ captures the correct semantics when
dealing with systems that allow only linear abstractions,
it suffers from untypability in the presence
of shared abstractions. For instance,
mapping for $P = \bout{n}{\abs{x}{\bout{x}{m}\inact}} \inact \Par \binp{\dual{n}}{x} (\appl{x}{s_1} \Par \appl{x}{s_2})$
would be:
%
\[
	\pmap{P}{n} \defeq
	\newsp{s}{\bout{n}{s} \binp{\dual{s}}{x} \bout{x}{m} \inact \Par \binp{\dual{n}}{x} (\bout{x}{s_1} \inact \Par \bout{x}{s_2} \inact)}
\]
%
The above process is untypable since processes $(\bout{x}{s_1} \inact$ and $\bout{x}{s_2} \inact)$
cannot be put in parallel because they do not have disjoint session environments.

The correct approach would be to use replicated shared names
as triggers instead of session names, when dealing with shared abstractions. 

\smallskip 

\begin{definition}[Typed Encoding of \HOp into \sessp]
\label{d:enc:hopitopi}
%Let $\tyl{L}_{\sessp}=\calc{\sessp}{{\cal{T}}_3}{\hby{\ell}}{\fwb}{\proves}$ 
%where the typing is defined in 
%Fig.~\ref{fig:typerulesmy} 
%and the equivalence $\fwb$ is defined in Definition~\ref{d:fwb}.
%${\cal{T}}_3$ is a set of types of $\sessp$.  
%%
We define the typed encoding 
$\enco{\map{\cdot}^{2}, \mapt{\cdot}^{2}, \mapa{\cdot}^{2}}: \tyl{L}_{\HOp} \to \tyl{L}_{\sessp}$  
%We define the mappings $\map{\cdot}^{2}$, $\mapt{\cdot}^{2}$, $\mapa{\cdot}^{2}$
in Fig.~\ref{f:enc:ho_to_sessp}. 
\end{definition}

\smallskip 

\begin{figure}[t]
\[
\begin{array}{l}
	\begin{array}{rcl}
\noindent{\bf Types:}\hspace{0.5cm} 
		\tmap{\btout{\lhot{S}}S_1}{2} & \defeq & \bbtout{\chtype{\btinp{\tmap{S}{2}}\tinact}}\tmap{S_1}{2} \\
		\tmap{\btinp{\lhot{S}}S_1}{2} & \defeq & \bbtinp{\chtype{\btinp{\tmap{S}{2}}\tinact}}\tmap{S_1}{2} 
\\[1mm]
\hline
%\end{array}
%\]
%\[
%\begin{array}{rcll}
\noindent{\bf Labels:}\ 
		\mapa{(\nu \tilde{m})\bactout{u}{\abs{ x}{P}} }^2  & \defeq & (\nu \tilde{m})\news{a} \bactout{u}{a} \\
		\mapa{\bactinp{u}{\abs{ x}{P}} }^2 &  \defeq & \bactinp{u}{a}
\\[1mm]
\hline
\end{array}
\end{array}
\]
\hspace{4mm}{\bf Terms} :
\[
\begin{array}{rcll}
		\pmap{\bout{u}{\abs{x}{Q}} P}{2} &\!\!\!\! \defeq \!\!\!\!\!\!\!\!&  \left\{
		\begin{array}{r}
			\newsp{a}{\bout{u}{a} (\pmap{P}{2} \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{2})\,}\\
                  (s \notin \fn{Q}) \\
			\newsp{a}{\bout{u}{a} (\pmap{P}{2} \Par \binp{a}{y} \binp{y}{x} \pmap{Q}{2})\,}\quad\\
            \textrm{(otherwise)} %\dk{Q \textrm{ linear}} \\
		\end{array}
		\right.
		\\
\pmap{\binp{u}{x} P}{2} &\!\!\!\! \defeq \!\!\!\! \!\!\!\! &  \binp{u}{x} \pmap{P}{2}\\
\pmap{\appl{x}{u}}{2} & \!\!\!\! \defeq \!\!\!\! \!\!\!\! & \newsp{s}{\bout{x}{s} \bout{\dual{s}}{u} \inact}\\

	\end{array}
	\]
$\repl{} P$ means $\recp{X}{(P \Par \rvar{X})}$.
The rest of mappings are homomorphic. %for others.  %types, labels and processes    
	\caption{
Encoding of \HOp into \sessp.
\label{f:enc:ho_to_sessp}
}
\Hline
\end{figure}

\begin{theorem}[Precise Encoding of \HOp into \sessp]
\label{f:enc:hotopi}
The encoding from $\tyl{L}_{\HOp}$ into $\tyl{L}_{\sessp}$ (cf. Definition~\ref{d:enc:hopitopi})
is precise. 
\end{theorem}




