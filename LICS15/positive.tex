We present two encodings:
\begin{enumerate}
\item The higher-order name-passing communication (\HOp) into 
the higher-order communication without name-passing nor 
recursions (\HO) (\S\,\ref{subsec:HOpi_to_HO})
\item the higher-order communication without 
name-passing and recursions (\HO)
into the first-order name-passing communication
with recursions (\sessp) (\S\,\ref{subsec:HO_to_sesspi})
\end{enumerate}
By (1), we can encode \sessp into \HO and by (2), 
we can encode \HOp into \sessp.  
Note that it is obvious that \HOp can encode both 
$\HO$ and $\sessp$ by the identitiy mapping. 

\subsection{From \HOp to \HO}
\label{subsec:HOpi_to_HO}

\begin{definition}\rm 
	Let $\vmap{\cdot}: 2^{\mathcal{N}} \longrightarrow \mathcal{V}^\omega$
	be a map of sequences of 
lexicographically ordered names to sequences of variables, defined
	inductively as: 
	$\vmap{\epsilon} = \epsilon$ and $\vmap{n \cat \tilde{m}} = x_n \cat \vmap{\tilde{m}}$. 
\end{definition}

\begin{definition}\label{d:trabs}\label{d:auxmap}
	Let $\sigma$ be a set of session names.
	Define $\auxmapp{\cdot}{\mathsf{v}}{\sigma}: \HOp^{-\mu} \to \HOp^{-\mu}$ as in Fig.~\ref{f:auxmap}.
%
\begin{figure}[t]
\[
\small
\begin{array}{rcl}
	\auxmapp{\bout{n}{\abs{x}{Q}} P}{{}}{\sigma} &\!\!\defeq\!\!&
		\bout{u}{\abs{x}{\auxmapp{Q}{{}}{\sigma}}} \auxmapp{P}{{}}{\sigma}
\\[1mm]
%\auxmapp{\bout{n}{m} P}{{}}{\sigma} \defeq
%	    \bout{u}{v}\auxmapp{P}{{}}{\sigma} 
	\auxmapp{\appl{x}{n}}{{}}{\sigma}  \defeq
		\appl{x}{u} \quad 
	\auxmapp{\inact}{{}}{\sigma}  \defeq  \inact
& & 
			\auxmapp{\binp{n}{x} P}{{}}{\sigma}\defeq
		\binp{u}{x} \auxmapp{P}{{}}{\sigma} 
\\[1mm]
	\auxmapp{\bsel{n}{l} P}{{}}{\sigma} \defeq
		\bsel{u}{l} \auxmapp{P}{{}}{\sigma} 
& & 
	\auxmapp{\bbra{n}{l_i:P_i}_{i \in I}}{{}}{\sigma}  \defeq 
		\bbra{u}{l_i:\auxmapp{P_i}{{}}{\sigma}}_{i \in I}
	\vspace{1mm} \\
\auxmapp{\news{n} P}{{}}{\sigma}  \defeq  \news{n} \auxmapp{P}{{}}{{\sigma \cat n}}
& & 
	\auxmapp{P \Par Q}{{}}{\sigma}  \defeq  \auxmapp{P}{{}}{\sigma} \Par \auxmapp{Q}{{}}{\sigma} 
\end{array}
\]
%\[
%	\begin{array}{rcl}
%          \auxmapp{\news{n} P}{{}}{\sigma} &\bnfis& \news{n} \auxmapp{P}{{}}{{\sigma \cat n}}
%		\vspace{1mm} \\
%		\auxmapp{\bout{n}{\abs{x}{Q}} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\bout{x_n}{\abs{(x,\vmap{\fn{P}})}{\auxmapp{Q}{{}}{\sigma}}} \auxmapp{P}{{}}{\sigma} & n \notin \sigma\\
%			\bout{n}{\abs{(x,\vmap{\fn{P}})}{\auxmapp{Q}{{}}{\sigma}}} \auxmapp{P}{{}}{\sigma} & n \in \sigma
%		\end{array}
%		\right.
%			\vspace{1mm}	\\ 
%		\auxmapp{\bout{n}{m} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%		    \bout{n}{m}\auxmapp{P}{{}}{\sigma} & n, m \in \sigma \\
%		    \bout{x_n}{m}\auxmapp{P}{{}}{\sigma} & n \not\in \sigma, m \in \sigma \\
%		    \bout{n}{x_m}\auxmapp{P}{{}}{\sigma} & n \in \sigma, m \not\in \sigma \\
%		    \bout{x_n}{x_m}\auxmapp{P}{{}}{\sigma} & n, m \not\in \sigma 
%		\end{array}
%		\right.
%		\vspace{1mm} \\ 
%				\auxmapp{\binp{n}{X} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\binp{x_n}{X} \auxmapp{P}{{}}{\sigma} & n \notin \sigma\\
%			\binp{n}{X} \auxmapp{P}{{}}{\sigma} & n \in \sigma
%		\end{array}
%		\right.
%			\vspace{1mm}	\\ 
%		\auxmapp{\binp{n}{x}P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%		    \binp{n}{x}\auxmapp{P}{{}}{\sigma} & n \in \sigma \\
%		    \binp{x_n}{x}\auxmapp{P}{{}}{\sigma} & n \not\in \sigma 
%		\end{array}
%		\right.
%		\vspace{1mm} \\ 
%		\auxmapp{\bsel{n}{l} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\bsel{x_n}{l} \auxmapp{P}{{}}{\sigma} & n \notin \sigma\\
%			\bsel{n}{l} \auxmapp{P}{{}}{\sigma} & n \in \sigma
%		\end{array}
%		\right.
%		\vspace{1mm} \\
%		\auxmapp{\bbra{n}{l_i:P_i}_{i \in I}}{{}}{\sigma} &\bnfis&
%		%\auxmapp{\bsel{n}{l} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\bbra{x_n}{l_i:\auxmapp{P_i}{{}}{\sigma}}_{i \in I}  & n \notin \sigma\\
%			\bbra{n}{l_i:\auxmapp{P_i}{{}}{\sigma}}_{i \in I}  & n \in \sigma
%		\end{array}
%		\right.
%		\vspace{1mm} \\
%		\auxmapp{\appl{\X}{n}}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\appl{\X}{x_n} & n \notin \sigma\\
%			\appl{\X}{n} & n \in \sigma\\
%		\end{array}
%		\right. \\
%		\auxmapp{\inact}{{}}{\sigma} &\bnfis& \inact\\
%		\auxmapp{P \Par Q}{{}}{\sigma} &\bnfis& \auxmapp{P}{{}}{\sigma} \Par \auxmapp{Q}{{}}{\sigma} 
% \end{array}
%\]
%The auxiliary map (cf. Definition~\ref{d:auxmap}) 
%used in the encoding of the higher-order communication 
%with recursive definitions into higher-order communication 
%without recursive definitions and (Definition~\ref{d:enc:fotohorec}).
$u = n$ if $n\in \sigma$; otherwise $u = x_n$, and  
$\fn{P}$ denotes a sequence of lexicopraphically ordered 
free names in $P$. 
%The mapping is defined homomorphically for inaction and parallel composition.
\caption{\label{f:auxmap} A triger mapping}
\end{figure}
\end{definition}

Given a process $P$ with $\fn{P} = m_1, \cdots, m_n$, we are interested in its associated abstraction, which is defined as
$\abs{x_1, \cdots, x_n}{\auxmapp{P}{{}}{\epsilon} }$, where $\vmap{m_j} = x_j$, for all $j \in \{1, \ldots, n\}$.
This transformation from processes into abstractions can be reverted by
using abstraction and application with an appropriate sequence of session names:
%
\begin{proposition}\rm
	Let $P$ be a \HOp process and 
	suppose $\tilde{x} = \vmap{\tilde{n}}$ where 
$\tilde{n} = \fn{P}$.
	Then $P \scong \appl{(\abs{\tilde{x}}{\auxmapp{P}{{}}{\emptyset}})}{\tilde{n}}$.
%	$\appl{X}{\smap{\fn{P}}} \subst{(\vmap{\fn{P}}) \map{P}^{\emptyset}}{X} \scong P$
\end{proposition}



\begin{figure}[t]
\[
\begin{array}{l}
\begin{array}{rcll}
\noindent{\bf Types:} \quad 
		\tmap{\btout{S_1} {S} }{1}	&\!\!\defeq\!\!&	\bbtout{\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}} \tmap{S}{1}  \\
		\tmap{\btinp{S_1} S }{1}	&\!\!\defeq\!\!&	\bbtinp{\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}} \tmap{S}{1} \\
		\tmap{\bbtout{\chtype{S_1}} {S} }{1}	&\!\!\defeq\!\!&	\bbtout{\shot{\btinp{\shot{\chtype{\tmap{S_1}{1}}}}\tinact}} \tmap{S}{1}  \\
		\tmap{\bbtinp{\chtype{S_1}} {S} }{1}	&\!\!\defeq\!\!&	\bbtinp{\shot{\btinp{\shot{\chtype{\tmap{S_1}{1}}}}\tinact}} \tmap{S}{1} \\
		\tmap{\btout{L} S}{1} &\!\!\defeq\!\!& \btout{L} \tmap{S}{1}\\
		\tmap{\btinp{L} S}{1} &\!\!\defeq\!\!& \btinp{L} \tmap{S}{1}\\
		\tmap{\btsel{l_i: S_i}_{i \in I}}{1} &\!\!\defeq\!\!& \btsel{l_i: \tmap{S_i}{1}}_{i \in I}\\
		\tmap{\btbra{l_i: S_i}_{i \in I}}{1} &\!\!\defeq\!\!& \btbra{l_i: \tmap{S_i}{1}}_{i \in I}\\
\tmap{\vart{t}}{1} \defeq \vart{t} \quad 
		\tmap{\trec{t}{S}}{1}  &\!\!\defeq\!\!&
\trec{t}{\tmap{S}{1}}\quad 
\tmap{\tinact}{1}  \defeq  \tinact\\[1mm]
\hline
%\end{array}
%\]
%\[
%\begin{array}{rcll}
\noindent{\bf Labels:} \quad \quad 
	\mapa{\bactout{n}{m}}^{1} &\!\!\defeq\!\!&   \bactout{n}{\abs{z}{\,\binp{z}{x} \appl{x}{m}} } \\
	\mapa{\bactinp{n}{m}}^{1} &\!\!\defeq\!\!&   \bactinp{n}{\abs{z}{\,\binp{z}{x} \appl{x}{m}} } \\
		\mapa{\bactout{n}{\abs{{x}}{P}}}^{1} &\!\!\defeq\!\!& \bactout{n}{\abs{{x}}{\pmapp{P}{1}{\es}}}\\
		\mapa{\bactinp{n}{\abs{{x}}{P}}}^{1} &\!\!\defeq\!\!& \bactinp{n}{\abs{{x}}{\pmapp{P}{1}{\es}}}\\
		\mapa{\tau}^{1} &\!\!\defeq\!\!& \tau
\\[1mm]
\hline
\\
\end{array}
\\
\noindent{\bf Terms:}\\
\begin{array}{rcll}
  \pmapp{\bout{u}{w} P}{1}{f}	&\!\!\defeq\!\!&	\bout{u}{ \abs{z}{\,\binp{z}{x} (\appl{x}{w})} } \pmapp{P}{1}{f} \\
  \pmapp{\binp{u}{\AT{x}{C}} Q}{1}{f}	&\!\!\defeq\!\!&	\binp{u}{y} \newsp{s}{\appl{y}{s} \Par \bout{\dual{s}}{\abs{x}{\pmapp{Q}{1}{f}}} \inact} \\
		\pmapp{\bout{u}{\abs{{x}}{Q}} P}{1}{f}  
&\!\!\defeq\!\!& \bout{u}{\abs{{x}}{\pmapp{Q}{1}{f}}} \pmapp{P}{1}{f} \\
		\pmapp{\binp{u}{\AT{x}{L}} P}{1}{f} &\!\!\defeq\!\!& \binp{u}{x} \pmapp{P}{1}{f}\\
		\pmapp{\bsel{s}{l} P}{1}{f} &\!\!\defeq\!\!& \bsel{s}{l} \pmapp{P}{1}{f}\\
		\pmapp{\bbra{s}{l_i: P_i}_{i \in I}}{1}{f} &\!\!\defeq\!\!& \bbra{s}{l_i: \pmapp{P_i}{1}{f}}_{i \in I}\\
		\pmapp{\inact}{1}{f} \!\!\defeq\!\!\inact
& & 
		\pmapp{\news{n} P}{1}{f} \!\!\defeq\!\! \news{n} \pmapp{P}{1}{f}\\
\pmapp{{x}\, {u}}{1}{f}
 \!\!\defeq\!\!
{x}\, {u}
& & 		\pmapp{P \Par Q}{1}{f} \!\!\defeq\!\! \pmapp{P}{1}{f} \Par \pmapp{Q}{1}{f} \\
		\pmapp{\recp{X}{P}}{1}{f} &\!\!\defeq\!\!&\!\!\!\!\!\!
	\newsp{s}{\\
& &\!\!\!\!\!\!\bout{\dual{s}}{\abs{(\vmap{\tilde{n}}, y)} 
\,{\binp{y}{z_\X} \auxmapp{\pmapp{P\subst{z_\X}{\X}}{1}{{f,\{z_\rvar{X}\to \tilde{n}\}}}}{{}}{\es}}} \inact
\\ 
& & \!\!\!\!\!\!
 \Par 
\binp{s}{z_\X} \pmapp{P\subst{z_X}{X}}{1}{{f,\{z_\rvar{X}\to \tilde{n}\}}}
} 
\quad \tilde{n} = \fn{P} \\ 
\pmapp{z_\rvar{X}}{1}{f} &\!\!\defeq\!\!& \newsp{s}{
\appl{z_X}{(\tilde{n}, s)}\\
& &  \Par \bbout{\dual{s}}{ \abs{(\vmap{\tilde{n}},y)}{\appl{z_X}{(\vmap{\tilde{n}}, y)}}} \inact}  \quad \tilde{n} = f(z_\rvar{X}) \\
	\end{array}
\end{array}
\]
We assume the input bound variable $x$ is annotated by a type ($C$ or $L$). 
\caption{\label{f:enc:fotohorec}
Encoding of \HOp into \HO.
%(cf.~Defintion~\ref{d:enc:fotohorec}).
%Mappings 
%$\map{\cdot}^2$,
%$\mapt{\cdot}^2$, 
%and 
%$\mapa{\cdot}^2$
%are homomorphisms for the other processes/types/labels. 
}
\end{figure}

\begin{definition}[Full Higher-Order Pi into Higher-Order]
\label{d:enc:hopitoho}
Let $f$ be a function from recursion variables to sequences of name variables.
%
Define the typed encoding $\enco{\map{\cdot}^{1}_f, \mapt{\cdot}^{1}, \mapa{\cdot}^{1}}: \HOp \to \HO$,
where mappings $\map{\cdot}^{1}$, $\mapt{\cdot}^{1}$, $\mapa{\cdot}^{1}$
are defined in Fig.~\ref{f:enc:hopitoho}.
\end{definition}

