\noi This section presents two posirive results of the encodings:
(1) The higher-order name-passing communication with recursions (\HOp) into 
the higher-order communication without name-passing nor 
recursions (\HO) (\S\,\ref{subsec:HOpi_to_HO}); and (2) 
\HOp into the first-order name-passing communication
with recursions (\sessp) (\S\,\ref{subsec:HO_to_sesspi}). 

\subsection{From \HOp to \HO}
\label{subsec:HOpi_to_HO}
\noi We show that $\HO$ is expressive enough to
represent the the full \HOp calculus.
The main challenge here is to encode (1) name passing 
and (2) recursions, 
for which 
we use abstraction passing semantics. For (1), we pass  
a simple abstraction which enables to use the name upon application. 
For (2), we 
copy a process upon reception; the case of linear abstraction passing
presents a limitation due to the fact that we can{\em not} 
copy a linear abstraction.
To overcome this problem we define a preliminary tool which is a mapping from
processes to processes with no free names (but with free variables) (Definition~\ref{d:auxmap}). 

We first require an auxiliary definition.

\smallskip 

\begin{definition}\rm 
\label{def:hop_to_ho}
	Let $\vmap{\cdot}: 2^{\mathcal{N}} \longrightarrow \mathcal{V}^\omega$
	be a map of sequences of 
lexicographically ordered names to sequences of variables, defined
	inductively as: 
	$\vmap{\epsilon} = \epsilon$ and $\vmap{n \cat \tilde{m}} = x_n \cat \vmap{\tilde{m}}$. 
\end{definition}

\smallskip 

\noi The following trigger mapping transforms processes
with free names into abstractions. 

\smallskip 

\begin{definition}[Trigger Mapping] \label{d:trabs}\label{d:auxmap}
	Let $\sigma$ be a set of session names.
	We define a trigger mapping,  
$\auxmapp{\cdot}{{}}{\sigma}: \HO \to \HO$, in Fig.~\ref{f:auxmap}.
\end{definition}

%
\begin{figure}[t]
\[
\small
\begin{array}{rl}
	\auxmapp{\bout{n}{\abs{x}{Q}} P}{{}}{\sigma} &\!\!\!\!\!\!\defeq
		\bout{u}{\abs{x}{\auxmapp{Q}{{}}{\sigma}}} \auxmapp{P}{{}}{\sigma}
\\[1mm]
%\auxmapp{\bout{n}{m} P}{{}}{\sigma} \defeq
%	    \bout{u}{v}\auxmapp{P}{{}}{\sigma} 
	\auxmapp{\appl{x}{n}}{{}}{\sigma}  \defeq
		\appl{x}{u} \quad 
	\auxmapp{\inact}{{}}{\sigma}  \defeq  \inact
 & 
			\auxmapp{\binp{n}{x} P}{{}}{\sigma}\defeq
		\binp{u}{x} \auxmapp{P}{{}}{\sigma} 
\\[1mm]
	\auxmapp{\bsel{n}{l} P}{{}}{\sigma} \defeq
		\bsel{u}{l} \auxmapp{P}{{}}{\sigma} 
 & 
	\auxmapp{\bbra{n}{l_i:P_i}_{i \in I}}{{}}{\sigma}  \defeq 
		\bbra{u}{l_i:\auxmapp{P_i}{{}}{\sigma}}_{i \in I}
	\vspace{1mm} \\
\auxmapp{\news{n} P}{{}}{\sigma}  \defeq  \news{n} \auxmapp{P}{{}}{{\sigma \cat n}}
 & 
	\auxmapp{P \Par Q}{{}}{\sigma}  \defeq  \auxmapp{P}{{}}{\sigma} \Par \auxmapp{Q}{{}}{\sigma} 
\end{array}
\]
%\[
%	\begin{array}{rcl}
%          \auxmapp{\news{n} P}{{}}{\sigma} &\bnfis& \news{n} \auxmapp{P}{{}}{{\sigma \cat n}}
%		\vspace{1mm} \\
%		\auxmapp{\bout{n}{\abs{x}{Q}} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\bout{x_n}{\abs{(x,\vmap{\fn{P}})}{\auxmapp{Q}{{}}{\sigma}}} \auxmapp{P}{{}}{\sigma} & n \notin \sigma\\
%			\bout{n}{\abs{(x,\vmap{\fn{P}})}{\auxmapp{Q}{{}}{\sigma}}} \auxmapp{P}{{}}{\sigma} & n \in \sigma
%		\end{array}
%		\right.
%			\vspace{1mm}	\\ 
%		\auxmapp{\bout{n}{m} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%		    \bout{n}{m}\auxmapp{P}{{}}{\sigma} & n, m \in \sigma \\
%		    \bout{x_n}{m}\auxmapp{P}{{}}{\sigma} & n \not\in \sigma, m \in \sigma \\
%		    \bout{n}{x_m}\auxmapp{P}{{}}{\sigma} & n \in \sigma, m \not\in \sigma \\
%		    \bout{x_n}{x_m}\auxmapp{P}{{}}{\sigma} & n, m \not\in \sigma 
%		\end{array}
%		\right.
%		\vspace{1mm} \\ 
%				\auxmapp{\binp{n}{X} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\binp{x_n}{X} \auxmapp{P}{{}}{\sigma} & n \notin \sigma\\
%			\binp{n}{X} \auxmapp{P}{{}}{\sigma} & n \in \sigma
%		\end{array}
%		\right.
%			\vspace{1mm}	\\ 
%		\auxmapp{\binp{n}{x}P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%		    \binp{n}{x}\auxmapp{P}{{}}{\sigma} & n \in \sigma \\
%		    \binp{x_n}{x}\auxmapp{P}{{}}{\sigma} & n \not\in \sigma 
%		\end{array}
%		\right.
%		\vspace{1mm} \\ 
%		\auxmapp{\bsel{n}{l} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\bsel{x_n}{l} \auxmapp{P}{{}}{\sigma} & n \notin \sigma\\
%			\bsel{n}{l} \auxmapp{P}{{}}{\sigma} & n \in \sigma
%		\end{array}
%		\right.
%		\vspace{1mm} \\
%		\auxmapp{\bbra{n}{l_i:P_i}_{i \in I}}{{}}{\sigma} &\bnfis&
%		%\auxmapp{\bsel{n}{l} P}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\bbra{x_n}{l_i:\auxmapp{P_i}{{}}{\sigma}}_{i \in I}  & n \notin \sigma\\
%			\bbra{n}{l_i:\auxmapp{P_i}{{}}{\sigma}}_{i \in I}  & n \in \sigma
%		\end{array}
%		\right.
%		\vspace{1mm} \\
%		\auxmapp{\appl{\X}{n}}{{}}{\sigma} &\bnfis&
%		\left\{
%		\begin{array}{rl}
%			\appl{\X}{x_n} & n \notin \sigma\\
%			\appl{\X}{n} & n \in \sigma\\
%		\end{array}
%		\right. \\
%		\auxmapp{\inact}{{}}{\sigma} &\bnfis& \inact\\
%		\auxmapp{P \Par Q}{{}}{\sigma} &\bnfis& \auxmapp{P}{{}}{\sigma} \Par \auxmapp{Q}{{}}{\sigma} 
% \end{array}
%\]
%The auxiliary map (cf. Definition~\ref{d:auxmap}) 
%used in the encoding of the higher-order communication 
%with recursive definitions into higher-order communication 
%without recursive definitions and (Definition~\ref{d:enc:fotohorec}).
$u = n$ if $n\in \sigma$; otherwise $u = x_n$, and  
$\fn{P}$ denotes a sequence of lexicopraphically ordered 
free names in $P$. 
%The mapping is defined homomorphically for inaction and parallel composition.
\caption{\label{f:auxmap} A triger mapping}
\end{figure}

\smallskip 

\noi Given a process $P$ with $\fn{P} = m_1, \cdots, m_n$, we are interested in its associated abstraction, which is defined as
$\abs{x_1, \cdots, x_n}{\auxmapp{P}{{}}{\epsilon} }$, where $\vmap{m_j} = x_j$, for all $j \in \{1, \ldots, n\}$. 

%This transformation from processes into abstractions can be reverted by
%using abstraction and application with an appropriate sequence of session names:
%%
%\begin{proposition}\rm
%	Let $P$ be a \HOp process and 
%	suppose $\tilde{x} = \vmap{\tilde{n}}$ where 
%$\tilde{n} = \fn{P}$.
%	Then $P \scong \appl{(\abs{\tilde{x}}{\auxmapp{P}{{}}{\emptyset}})}{\tilde{n}}$.
%%	$\appl{X}{\smap{\fn{P}}} \subst{(\vmap{\fn{P}}) \map{P}^{\emptyset}}{X} \scong P$
%\end{proposition}

\begin{figure}[t]
\[
\begin{array}{rcll}
	\noindent{\bf Types:} \quad 
	\vtmap{{S}}{1}	&\!\!\defeq\!\!&	\lhot{(\btinp{\lhot{\tmap{S}{1}}} \tinact)} \\
	\vtmap{\chtype{S}}{1}&\!\!\defeq\!\!&	\lhot{(\btinp{\shot{\chtype{\tmap{S}{1}}}} \tinact)}  \\
	\vtmap{\chtype{L}}{1}&\!\!\defeq\!\!&	\lhot{(\btinp{\shot{\chtype{\tmap{L}{1}}}} \tinact)} \\
	\vtmap{\lhot{C}}{1} &\!\!\defeq\!\!& \lhot{\tmap{C}{1}}\\
	\vtmap{\shot{C}}{1} &\!\!\defeq\!\!& \shot{\tmap{C}{1}}\\
	\tmap{\chtype{S}}{1}&\!\!\defeq\!\!&	\chtype{\tmap{S}{1}}  \\
	\tmap{\chtype{L}}{1}&\!\!\defeq\!\!&	\chtype{\tmap{L}{1}}  \\
	%		\tmap{\btout{S_1} {S} }{1}	&\!\!\defeq\!\!&	\bbtout{\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}} \tmap{S}{1}  \\
	%		\tmap{\btinp{S_1} S }{1}	&\!\!\defeq\!\!&	\bbtinp{\lhot{\btinp{\lhot{\tmap{S_1}{1}}}\tinact}} \tmap{S}{1} \\
	%		\tmap{\bbtout{\chtype{U}} {S} }{1}	&\!\!\defeq\!\!&	\bbtout{\shot{\btinp{\shot{\chtype{\tmap{U}{1}}}}\tinact}} \tmap{S}{1}  \\
	%		\tmap{\bbtinp{\chtype{U}} {S} }{1}	&\!\!\defeq\!\!&	\bbtinp{\shot{\btinp{\shot{\chtype{\tmap{U}{1}}}}\tinact}} \tmap{S}{1} \\

	\tmap{\btout{U} S}{1} &\!\!\defeq\!\!& \btout{{\vtmap{U}{1}}} \tmap{S}{1}\\
	\tmap{\btinp{U} S}{1} &\!\!\defeq\!\!& \btinp{{\vtmap{U}{1}}} \tmap{S}{1}\\
	\tmap{\btsel{l_i: S_i}_{i \in I}}{1} &\!\!\defeq\!\!& \btsel{l_i: \tmap{S_i}{1}}_{i \in I}\\
			\tmap{\btbra{l_i: S_i}_{i \in I}}{1} &\!\!\defeq\!\!& \btbra{l_i: \tmap{S_i}{1}}_{i \in I}\\
	\tmap{\vart{t}}{1} \defeq \vart{t} \quad 
			\tmap{\trec{t}{S}}{1}  &\!\!\defeq\!\!&
	\trec{t}{\tmap{S}{1}}\quad 
	\tmap{\tinact}{1}  \defeq  \tinact\\[1mm]
	\hline
	%\end{array}
	%\]
	%\[
	%\begin{array}{rcll}
	\noindent{\bf Labels:} \quad 
		\mapa{(\nu \tilde{m})\bactout{n}{m}}^{1} &\!\!\defeq\!\!&   
(\nu \tilde{m})\bactout{n}{\abs{z}{\,\binp{z}{x} (\appl{x}{m})} } \\
		\mapa{\bactinp{n}{m}}^{1} &\!\!\defeq\!\!&   \bactinp{n}{\abs{z}{\,\binp{z}{x} (\appl{x}{m})} } \\
	\mapa{(\nu \tilde{m})\bactout{n}{\abs{{x}}{P}}}^{1} &\!\!\defeq\!\!& 
(\nu \tilde{m})\bactout{n}{\abs{{x}}{\pmapp{P}{1}{\es}}}\\
			\mapa{\bactinp{n}{\abs{{x}}{P}}}^{1} &\!\!\defeq\!\!& \bactinp{n}{\abs{{x}}{\pmapp{P}{1}{\es}}}\\
			\mapa{\bactsel{n}{l} }^{1} \!\defeq\! \bactsel{n}{l} 
	\quad 
			\mapa{\bactbra{n}{l} }^{1} &\!\!\defeq\!\!& \bactbra{n}{l} 
	\quad \quad 
			\mapa{\tau}^{1} \!\defeq\! \tau
\\[1mm]
\hline
\end{array}
\]
{\bf Terms} : 
\[
\begin{array}{rcll}
  \pmapp{\bout{u}{w} P}{1}{f}	&\!\!\defeq\!\!&	\bout{u}{ \abs{z}{\,\binp{z}{x} (\appl{x}{w})} } \pmapp{P}{1}{f} \\
  \pmapp{\binp{u}{\AT{x}{C}} Q}{1}{f}	&\!\!\defeq\!\!&	\binp{u}{y} \newsp{s}{\appl{y}{s} \Par \bout{\dual{s}}{\abs{x}{\pmapp{Q}{1}{f}}} \inact} \\
		\pmapp{\bout{u}{\abs{{x}}{Q}} P}{1}{f}  
&\!\!\defeq\!\!& \bout{u}{\abs{{x}}{\pmapp{Q}{1}{f}}} \pmapp{P}{1}{f} \\
		\pmapp{\binp{u}{\AT{x}{L}} P}{1}{f} &\!\!\defeq\!\!& \binp{u}{x} \pmapp{P}{1}{f}\\
		\pmapp{\bsel{s}{l} P}{1}{f} &\!\!\defeq\!\!& \bsel{s}{l} \pmapp{P}{1}{f}\\
		\pmapp{\bbra{s}{l_i: P_i}_{i \in I}}{1}{f} &\!\!\defeq\!\!& \bbra{s}{l_i: \pmapp{P_i}{1}{f}}_{i \in I}\\
		\pmapp{\inact}{1}{f} \!\!\defeq\!\!\inact
& & 
		\pmapp{\news{n} P}{1}{f} \!\!\defeq\!\! \news{n} \pmapp{P}{1}{f}\\
\pmapp{{x}\, {u}}{1}{f}
 \!\!\defeq\!\!
{x}\, {u}
& & 		\pmapp{P \Par Q}{1}{f} \!\!\defeq\!\! \pmapp{P}{1}{f} \Par \pmapp{Q}{1}{f} \\
		\pmapp{\recp{X}{P}}{1}{f} &\!\!\defeq\!\!&\!\!\!\!\!\!
	\newsp{s}{\\
& &\!\!\!\!\!\!\bout{\dual{s}}{\abs{(\vmap{\tilde{n}}, y)} 
\,{\binp{y}{z_\X} \auxmapp{\pmapp{P\subst{z_\X}{\X}}{1}{{f,\{z_\rvar{X}\to \tilde{n}\}}}}{{}}{\es}}} \inact
\\ 
& & \!\!\!\!\!\!
 \Par 
\binp{s}{z_\X} \pmapp{P\subst{z_X}{X}}{1}{{f,\{z_\rvar{X}\to \tilde{n}\}}}
} 
\quad (\tilde{n} = \fn{P}) \\ 
\pmapp{z_\rvar{X}}{1}{f} &\!\!\defeq\!\!& \newsp{s}{
\appl{z_X}{(\tilde{n}, s)}\\
& &  \Par \bbout{\dual{s}}{ \abs{(\vmap{\tilde{n}},y)}{\appl{z_X}{(\vmap{\tilde{n}}, y)}}} \inact}  \quad (\tilde{n} = f(z_\rvar{X})) \\
\end{array}
\]
The input bound variable $x$ is annotated by a type to distinct the first-order and higher-order cases. We use the polyadic name abstraction for a simplicity of the presentation. They are formally encoded in 
\S~\ref{sec:extension}.
\caption{\label{f:enc:hopi_to_ho}
Encoding of \HOp into \HO.
%(cf.~Defintion~\ref{d:enc:fotohorec}).
%Mappings 
%$\map{\cdot}^2$,
%$\mapt{\cdot}^2$, 
%and 
%$\mapa{\cdot}^2$
%are homomorphisms for the other processes/types/labels. 
}
\end{figure}

\smallskip 

\begin{definition}[Full Higher-Order Pi into Higher-Order]
\label{d:enc:hopitoho}
Let $f$ be a function from variables to sequences of name variables.
%
Let $\tyl{L}_{\HOp}=\calc{\HOp}{{\cal{T}}_1}{\hby{\ell}}{\wb_H}{\proves}$
and 
$\tyl{L}_{\HO}=\calc{\HO}{{\cal{T}}_2}{\hby{\ell}}{\wb_H}{\proves}$. 
where 
${\cal{T}}_1$ and ${\cal{T}}_2$ are sets of types of $\HOp$ 
and $\HO$, respectively, 
the typing $\proves$ is defined in 
Fig.~\ref{fig:typerulesmy} 
and $\hwb$ is defined in Definition~\ref{d:hbw}. 
We define the typed encoding 
$\enco{\map{\cdot}^{1}, \mapt{\cdot}^{1}, \mapa{\cdot}^{1}}: \HOp \to \HO$ in 
Fig.~\ref{f:enc:hopi_to_ho}. 
We assume that the mapping $\mapt{\cdot}^{1}$ on types is extended to 
session environments $\Delta$
and
shared environments $\Gamma$ homomorphically with: 
\[
	\begin{array}{rcll}
%	    \mapt{\Delta \cat s: S}^{1} & =  & \mapt{\Delta}^{1} \cat s:\mapt{S}^{1} & \\
%		\mapt{\Gamma \cat u: \chtype{S}}^{1} & =  & \mapt{\Gamma}^{1} \cat u:\chtype{\mapt{S}^{1}} & \\
%		\mapt{\Gamma \cat u: \chtype{L}}^{1} & = &  \mapt{\Gamma}^{1} \cat u:\chtype{\mapt{L}^{1}} & \\
		\tmap{\Gamma \cat \varp{X}:\Delta}{1} & = & \tmap{\Gamma}{1} \cat x:\shot{(\tilde{S}_{\Delta}\,,\,S^*)}
	\end{array}
\]
where 
$S^* = \trec{t}{\btinp{\shot{(S_1,...,S_m,\vart{t})}} \tinact}$
with $\Delta = \{n_1:S_1, \ldots, n_m:S_m\}$. 
\end{definition}

\smallskip 
\noi Note that $\varp{X}:\Delta$ is mapped to a recursive session type 
which carries type variable as the last argument.  

\noi We explain the mapping in Fig.~\ref{f:enc:hopi_to_ho}, forcussing 
on {\em name passing} ($\pmapp{\bout{u}{w} P}{1}{f}$) and  
{\em recursions} ($\pmapp{\recp{X}{P}}{1}{f}$ and $\pmapp{z_\rvar{X}}{1}{f}$). 

{\bf\em Name passing:}
A name $m$ is being passed as an input
guarded abstraction. 
The input prefix receives an abstraction and
continues with the application of $n$ over the received abstraction.
On the receiver side $\binp{u}{x} P$ 
the encoding realises a mechanism that (i) receives
the input guarded abstraction, then (ii) applies it on a fresh session endpoint $s$, 
and (iii) uses
the dual endpoint $\dual{s}$ to send the continuation $P$ as the abstraction
$\abs{x}{P}$. 
As a result, name substitution is achieved via name application.


{\bf\em Recursions:}
A process $P$ is parallel composed, and also being passed as an input
guarded abstraction, parameterised also by a sequence of trigger names $\tilde{n}$. 
We record a mapping from $z_X$ (which is a fresh variable of $X$) 
to $\tilde{n}$, so that 
when the abstraction is passed to 
$\pmapp{z_\rvar{X}}{1}{f}$ (which appears in 
 

 






\begin{theorem}[Encoding of Full Higher-Order Pi into Higher-Order]
\label{f:enc:hopitoho}
The encoding from $\tyl{L}_{\HOp}$ into $\tyl{L}_{\HO}$ 
defined in Definition~\ref{d:enc:hopitoho}
is semantic preserving. 
\end{theorem}

\subsection{From \HO to \sessp}
\label{subsec:HO_to_sessp}

\begin{definition}[Higher-Order into First-Order Pi]
\label{d:enc:hopitopi}
$\tyl{L}_{\sessp}=\calc{\sessp}{{\cal{T}}_3}{\hby{\ell}}{\fwb}{\proves}$. 
where the typing is defined in 
Fig.~\ref{fig:typerulesmy} 
and the equivalence $\fwb$ is defined in Definition~\ref{d:fwb}.
${\cal{T}}_3$ is a set of types of $\sessp$.  
%
We define the mappings $\map{\cdot}^{2}$, $\mapt{\cdot}^{2}$, $\mapa{\cdot}^{2}$
in Fig.~\ref{f:enc:ho_to_sessp}. 
\end{definition}

\begin{figure}[t]
\[
\begin{array}{l}
	\begin{array}{rcl}
\noindent{\bf Types:}\quad 
		\tmap{\btout{\lhot{S}}S_1}{2} & \defeq & \bbtout{\chtype{\btinp{\tmap{S}{2}}\tinact}}\tmap{S_1}{2} \\
		\tmap{\btinp{\lhot{S}}S_1}{2} & \defeq & \bbtinp{\chtype{\btinp{\tmap{S}{2}}\tinact}}\tmap{S_1}{2} 
\\[1mm]
\hline
%\end{array}
%\]
%\[
%\begin{array}{rcll}
\noindent{\bf Labels:}\quad \quad 
		\mapa{(\nu \tilde{m})\bactout{u}{\abs{ x}{P}} }^2  & \defeq & (\nu \tilde{m})\news{a} \bactout{u}{a} \\
		\mapa{\bactinp{u}{\abs{ x}{P}} }^2 &  \defeq & \bactinp{u}{a}
\\[1mm]
\hline
\end{array}
\end{array}
\]
\hspace{4mm}{\bf Terms} :
\[
\begin{array}{rcll}
		\pmap{\bout{u}{\abs{x}{Q}} P}{2} &\!\!\!\! \defeq \!\!\!\!&  \left\{
		\begin{array}{r}
			\newsp{a}{\bout{u}{a} (\pmap{P}{2} \Par \repl{} \binp{a}{y} \binp{y}{x} \pmap{Q}{2})\,}\\
                  (s \notin \fn{Q}) \\
			\newsp{a}{\bout{u}{a} (\pmap{P}{2} \Par \binp{a}{y} \binp{y}{x} \pmap{Q}{2})\,}\quad\\
            \textrm{(otherwise)} %\dk{Q \textrm{ linear}} \\
		\end{array}
		\right.
		\\
\pmap{\binp{u}{x} P}{2} &\!\!\!\! \defeq \!\!\!\! &  \binp{u}{x} \pmap{P}{2}\\
\pmap{\appl{x}{u}}{2} & \!\!\!\! \defeq \!\!\!\! & \newsp{s}{\bout{x}{s} \bout{\dual{s}}{u} \inact}\\

	\end{array}
	\]
$\map{\cdot}^2$,
$\mapt{\cdot}^2$, 
and 
$\mapa{\cdot}^2$
are homomorphisms for the other types, labels and processes.   
	\caption{
Encoding of \HO into \sessp.
\label{f:enc:ho_to_sessp}
}
\end{figure}

\begin{theorem}[Encoding of Higher-Order into First-Order Pi]
\label{f:enc:hotopi}
The encoding from $\tyl{L}_{\HO}$ into $\tyl{L}_{\sessp}$ defined in 
Definition~\ref{d:enc:hopitopi} 
is semantic preserving. 
\end{theorem}

\begin{corollary}[Encoding of Higher-Order Pi into First-Order Pi]
The encoding from $\tyl{L}_{\HOp}$ into $\tyl{L}_{\sessp}$ is semantic preserving. 
\end{corollary}

Note that an encoding from $\tyl{L}_{\HOp}$ into $\tyl{L}_{\sessp}$
can be defined without using the first encoding result.  



