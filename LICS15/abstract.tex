% !TEX root = main.tex
\begin{abstract}
\noi \textbf{\abstractname} \ 
%In \emph{higher-order process calculi} exchanged values may contain processes;
%these languages integrate elements from the $\lambda$-calculus and 
%the $\pi$-calculus to specify and reason about mobile code.
%In the setting of structured communications as delineated by \emph{session types},
This work proposes %efficient 
tractable
bisimulations 
for the higher-order $\pi$-calculus with session primitives (\HOp) and 
offers a complete 
study of the expressivity of its most significant subcalculi.
%fully exploring features of  session communications. 
First we develop three typed bisimulations, which are shown to 
coincide with contextual equivalence.
These characterizations  
demonstrate that observing 
only a specific finite set of higher-order values (which inhabit session types) suffices 
to reason about \HOp. 
Next, we identify \HO, 
a minimal, second-order  subcalculus of \HOp in which 
%does {\em not} equip with 
higher-order applications, name-passing
and recursion are absent.
We show that 
%two fully abstract encodings:
\HO can encode the $n$-order \HOp, 
%fully abstractly; 
and 
that
the first-order session $\pi$-calculus can encode 
\HOp. %, fully abstractly.  
Both encodings are fully abstract.
We also 
prove that 
%then prove a  non-encodability result from 
the session $\pi$-calculus
with passing of shared names 
cannot be encoded 
into \HOp without shared names. 
Our results highlight how the expressiveness of \HO
results into more effective 
%reduces a burden of 
reasoning about typed
process equivalences for 
higher-order % name-passing 
processes. 
%separate the expressivity of higher-order session calculi
%and 
%make it more difficult to reason about process equivalences. 
%First, we identify a core higher-order,
%session-typed calculus and develop its characterisations of typed
%contextual equivalences as labeled bisimilarities.  Second, we
%formalize (non) encodability results between session calculi with
%either name-passing or process-passing mechanisms. Our results
%clarify the relationship between name- and process-passing in terms of
%high-level communication structures based on types.


%In calculi for \emph{higher-order} concurrency, values exchanged as communication objects may include processes. Based on process passing, this paradigm is in contrast with the \emph{first-order} (or name passing) concurrency of the $\pi$-calculus. %based on name passing. 
%%The higher-order paradigm is sometimes consideredBy combining mechanisms for functional and concurrent computation, these languages offer a unified account of different forms of interaction. 
%Although previous works have related calculi for higher-order and first-order concurrency, little is known about the nature of this relationship when interactions are disciplined by \emph{types for structured communications}. Here we tackle this challenge from the perspective of \emph{session types}, focusing on \emph{typed behavioral equivalences} and issues of \emph{relative expressiveness}. First, we identify a core higher-order, session-typed calculus and develop for it  characterizations of typed contextual equivalences as labeled bisimilarities. 
%Second, we formalize (non) encodability results between session calculi with either name-passing or process-passing mechanisms. 
%Our results clarify the relationship between name- and process-passing in terms of high-level communication structures based on types. 
\end{abstract}