% !TEX root = main.tex
\begin{abstract}
\noi \textbf{\abstractname} \ 
In \emph{higher-order process calculi} exchanged values may contain processes;
these languages integrate elements from the $\lambda$-calculus and 
the $\pi$-calculus to specify and reason about mobile code.
In the setting of structured communications as delineated by \emph{session types},
this work proposes %efficient 
tractable
bisimulations 
for the higher-order $\pi$-calculi (the \HOp-calculus) and 
studies the expressiveness of a family of the \HOp-calculus, 
fully exploring features of session communication. 
We first identify a core higher-order calculus with session 
primitives (the \HO-calculus), in which 
 which 
%does {\em not} equip with 
higher-order applications, name-passing
 and recursion are absent.
We then develop three characterizations of typed bisimulations; they are shown to 
coincide with a corresponding contextual equivalence. 
One of the three bisimulations demonstrates that observing 
only specific values which inhabit session types suffices to reason about the \HOp-calculus. 
Next, we show that the \HO-calculus can encode the \HOp-calculus with 
arbitrary higher-order applications, 
fully abstractly; and  
the first-order session $\pi$-calculus can encode 
the \HOp-calculus, fully abstractly.  
We then prove a 
non-encodability result from the session $\pi$-calculus
with shared name passing into the \HO-calculus without shared names. 
Our results highlight how expressiveness of the \HO-calculus 
reduces a burden of reasoning about typed, higher-order name-passing 
process equivalences. 
%separate the expressivity of higher-order session calculi
%and 
%make it more difficult to reason about process equivalences. 
%First, we identify a core higher-order,
%session-typed calculus and develop its characterisations of typed
%contextual equivalences as labeled bisimilarities.  Second, we
%formalize (non) encodability results between session calculi with
%either name-passing or process-passing mechanisms. Our results
%clarify the relationship between name- and process-passing in terms of
%high-level communication structures based on types.


%In calculi for \emph{higher-order} concurrency, values exchanged as communication objects may include processes. Based on process passing, this paradigm is in contrast with the \emph{first-order} (or name passing) concurrency of the $\pi$-calculus. %based on name passing. 
%%The higher-order paradigm is sometimes consideredBy combining mechanisms for functional and concurrent computation, these languages offer a unified account of different forms of interaction. 
%Although previous works have related calculi for higher-order and first-order concurrency, little is known about the nature of this relationship when interactions are disciplined by \emph{types for structured communications}. Here we tackle this challenge from the perspective of \emph{session types}, focusing on \emph{typed behavioral equivalences} and issues of \emph{relative expressiveness}. First, we identify a core higher-order, session-typed calculus and develop for it  characterizations of typed contextual equivalences as labeled bisimilarities. 
%Second, we formalize (non) encodability results between session calculi with either name-passing or process-passing mechanisms. 
%Our results clarify the relationship between name- and process-passing in terms of high-level communication structures based on types. 
\end{abstract}