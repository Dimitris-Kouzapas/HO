% !TEX root = main.tex
\noindent 
We introduce the 
\emph{Higher-Order Session $\pi$-Calculus} (\HOp).
\HOp includes both name- and abstraction-passing 
as well as recursions; it corresponds to a subcalculus 
of the language
studied 
in~\cite{tlca07}. 
Following the literature~\cite{JeffreyR05},
for simplicity of the presentation
we concentrate on the second-order call-by-value \HOp.  
(In \S\,\ref{sec:extension} we consider the extension of 
\HOp with general higher-order abstractions 
and polyadicity in name-passing/abstractions.)
We also introduce two subcalculi of \HOp. In particular, we define the 
core higher-order session
calculus (\HO), which 
%. The \HO calculus is  minimal: it 
includes %constructs for session establish\-ment/communication and 
(monadic) name-abstraction, but lacks name-passing and recursion.

%Although minimal, in \S\ref{s:expr}
%the abstraction-passing capabilities of \HOp will prove 
%expressive enough to capture key features of session communication, 
%such as delegation and recursion.

\subsection{Syntax of \HOp}
\label{subsec:syntax}
\noindent\myparagraph{Values} The syntax of \HOp is defined in Fig.~\ref{fig:syntax}
\begin{figure}[t]
\[ 
\begin{array}{lll}
u,w  ::=  n \ | \ x,y,z
& n ::= a,b  \ | \ s, \dual{s} 
& V,W  ::=   \nonhosyntax{u} \ | \ \abs{x}{P}
\end{array}
\]
\[
\begin{array}{rclllll}
P,Q \!\!\!\!\!\! & ::= & \!\! P\Par Q \bnfbar 
 \bsel{u}{l} P \bnfbar \bbra{u}{l_i:P_i}_{i \in I} \bnfbar \inact \\[1mm]
 & \bnfbar & \!\! \bout{u}{V}{P} \bnfbar \binp{u}{x}{P} \bnfbar \news{n} P 
\bnfbar 
%ny
%\appl{x}{u}
\appl{V}{u}
\bnfbar \nonhosyntax{\rvar{X} \bnfbar \recp{X}{P}}
%\\[1mm]
 %    & \bnfbar & \nonhosyntax{\rvar{X} \bnfbar \recp{X}{P}}
\end{array}
\]
 \caption{Syntax of \HOp. The syntax of \HO lacks the constructs in \nonhosyntax{\text{grey}}.}
\label{fig:syntax}
\Hline
\end{figure}
We use $a,b,c, \dots$ (resp.~$s, \dual{s}, \dots$) 
to range over shared (resp. session) names. 
We use $m, n, \dots$ for session or shared names. 
We define the dual operation over channels $n$ as $\dual{n}$ with
$\dual{\dual{s}} = s$ and $\dual{a} = a$.
Intuitively, names $s$ and $\dual{s}$ are dual (two) \emph{endpoints} while 
shared names repsent shared (non-deterministic) points. 
Variables are denoted with $x, y, z, \dots$, 
and recursive variables are denoted with $\varp{X}, \varp{Y} \dots$.
An abstraction $\abs{x}{P}$ is a process $P$ with name parameter $x$.
Symbols $u, v, \dots$ range over identifiers; and  
$V, W, \dots$ to denote values. 

\myparagraph{Terms} 
include the
$\pi$-calculus prefixes for sending and receiving values $V$.
Process $\bout{u}{V} P$ denotes the output of value $V$
over channel $u$, with continuation $P$;
process $\binp{u}{x} P$ denotes the input prefix on channel $u$ of a value
that 
will substitute variable $x$ in continuation $P$. 
Recursion is expressed by $\recp{X}{P}$,
which binds the recursive variable $\varp{X}$ in process $P$.
Process 
%ny
%$\appl{x}{u}$ 
$\appl{V}{u}$ 
is the application
process which substitutes channel $u$ on the abstraction $V$. 
Prefix $\bsel{u}{l} P$ selects label $l$ on channel $u$ and then behaves as $P$.
Given $i \in I$ process $\bbra{u}{l_i: P_i}_{i \in I}$ offers a choice on labels $l_i$ with
continuation $P_i$.
%Others are standard c
Constructs for 
inaction $\inact$,  parallel composition $P_1 \Par P_2$, and 
name restriction $\news{n} P$ are standard.
Session name restriction $\news{s} P$ simultaneously binds endpoints $s$ and $\dual{s}$ in $P$.
%A well-formed process relies on assumptions for
%guarded recursive processes.
We use $\fv{P}$ and $\fn{P}$ to denote a set of free variables and names; 
and assume $V$ in $\bout{u}{V}{P}$ does not include free process recursive 
variables $\rvar{X}$. 
If $\fv{P} = \emptyset$, we call $P$ {\em closed}; and closed $P$ without 
free session channels a {\em program}. 

\subsection{Subcalculi of \HOp}
\label{subsec:subcalculi}
\noi
We define two subcalculi of \HOp. 
%We now define several sub-calculi of \HOp. 
The first is the 
{\em core higher-order session calculus} (denoted \HO),
which lacks recursion and name passing; its 
formal syntax is obtained from Fig.~\ref{fig:syntax} by excluding 
constructs in \nonhosyntax{\text{grey}}.
The second subcalculus is 
the {\em session $\pi$-calculus} 
(denoted $\sessp$), which 
lacks  the
higher-order constructs
(i.e., abstraction passing and application), but includes recursion.
Let $\CAL \in \{\HOp, \HO, \sessp\}$. We write 
$\CAL^{-\mathsf{sh}}$ for $\CAL$ without shared channels
 (we delete $a,b$ from $n$). 
 We shall demonstrate that 
$\HOp$, $\HO$, and $\sessp$ have the same expressivity.

\subsection{Operational Semantics}
\label{subsec:semantics}
\begin{figure}
\[
\begin{array}{rclrcrclr}
(\abs{x}{P}) \, u  & \red & P \subst{u}{x} 
& \orule{App}
		\\[1mm]
%\bout{a}{V} P \Par \binp{a}{x} Q & \red & P \Par Q \subst{V}{x} 
%& \orule{Com}
%		\\[1mm]
\bout{n}{V} P \Par \binp{\dual{n}}{x} Q & \red & P \Par Q \subst{V}{x} 
& \orule{Pass}
		\\[1mm]
		\bsel{n}{l_j} Q \Par \bbra{\dual{n}}{l_i : P_i}_{i \in I} & \red & Q \Par P_j ~~(j \in I)~~  & \orule{Sel}\\[1mm]
		P \red P' & \Rightarrow & \news{n} P  \red  \news{n} P'  & \orule{Res}\\[1mm]
			P \red P' & \Rightarrow  &  P \Par Q  \red   P' \Par Q  & \orule{Par}\\[1mm]
			P \scong Q \red Q' \scong P' & \Rightarrow & P  \red  P' & \orule{Cong}
	\end{array}
\]
{\small
\[
	\begin{array}{c}
	P \Par \inact \scong P
	\quad
	P_1 \Par P_2 \scong P_2 \Par P_1
	\quad
	P_1 \Par (P_2 \Par P_3) \scong (P_1 \Par P_2) \Par P_3\\[1mm]
	\news{n} \inact \scong \inact
\quad 
P \Par \news{n} Q \scong \news{n}(P \Par Q)
\	(n \notin \fn{P})\quad 
\recp{X}{P} \scong P\subst{\recp{X}{P}}{\rvar{X}}
\end{array}
\]
}
\caption{Operational Semantics of $\HOp$. \label{fig:reduction}}
\Hline
\end{figure}
\noindent Fig.~\ref{fig:reduction} defines the operational semantics 
of \HOp.
$\orule{App}$ is a name application; 
$\orule{Pass}$ defines a shared interaction at $n$ 
($\dual{n}=n$) or session interaction;  
$\orule{Sel}$ is the standard rule for labelled choice/selection:
given an index set $I$, 
a process selects label $l_j$ on channel $n$ over a set of
labels $\set{l_i}_{i \in I}$ offered by a branching 
on the dual endpoint $\dual{n}$; and other rules are standard.
Rules for \emph{structural congruence} are defined in Fig.~\ref{fig:reduction} (bottom). 
We write $\red^\ast$ for a multi-step reduction. 
