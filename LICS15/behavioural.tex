\noi This section develops a theory for observational equivalence over
session typed \HOp processes. The theory follows the principles
laid by the previous work of the authors
\cite{DBLP:conf/forte/KouzapasYH11,KY13,dkphdthesis}.
We introduce three different bisimulations and prove 
all of them coinside with typed, reduction-closed,
barbed congruence. 

\subsection{Labelled Transition Semantics for Processes}\label{ss:lts}
\myparagraph{Labelles}
\noi We define a labelled transition relation (LTS) over
untyped processes. 
Later with the environment transition semantics, 
we can define a typed transition relation to formalise 
how a process interacts with a process in its enviroment. The interaction
is defined on action $\ell$:
\[
\begin{array}{l}
		\ell	\bnfis   \tau 
		\bnfbar\bactinp{n}{V} 
			\bnfbar \news{\tilde{m}} \bactout{n}{V}
			\bnfbar  \bactsel{n}{l} 
			\bnfbar \bactbra{n}{l} 
\end{array}
\]
\noi The internal action is defined on label $\tau$.
Action $\news{\tilde{m}} \bactout{n}{V}$ denotes the sending of value $V$ over channel $n$ with
names $\tilde{m}$ being restricted.
Dually the action for the reception of values is 
$\bactinp{n}{V}$.
We also defined actions for selecting a label $l$, 
$\bactsel{n}{l}$ and branching on a label
$n$, $\bactbra{s}{l}$.

The dual action relation is the symmetric relation $\asymp$, that satisfies the rules:
\[
	\bactsel{n}{l} \asymp \bactbra{\dual{n}}{l}
	\qquad
	\news{\tilde{m}} \bactout{n}{V} \asymp \bactinp{\dual{n}}{V}
\]
Dual actions happen on subjects that are dual between them and carry the same
object. Furthermore output action is dual with input action and 
select action is dual with branch action.

\smallskip

\begin{figure}[t]
\[
\ltsrule{App} \quad 
(\abs{x}{P}) \, u   \by{\tau}  P \subst{u}{x} 
\]
	\[
	\begin{array}{ll}
\ltsrule{Out}\	\bout{n}{V} P \by{\bactout{n}{V}} P 
&
\ltsrule{In}\	\binp{n}{x} P \by{\bactinp{n}{V}} P\subst{V}{x} 
\\[3mm]
 \ltsrule{Sel}\ \bsel{s}{l}{P} \by{\bactsel{s}{l}} P
&
\hspace{-1cm}
\ltsrule{Bra}\ \bbra{s}{l_i:P_i}_{i \in I} \by{\bactbra{s}{l_j}} P_j
\quad (j\in I)
\\[3mm]
\ltsrule{Alpha}
		\tree{
			P \scong_\alpha Q \quad Q\by{\ell} P'
		}{
			P \by{\ell} P'
		}
&
 \ltsrule{Res}	\tree{
			P \by{\ell} P' \quad n \notin \fn{\ell}
		}{
			\news{n} P \by{\ell} \news{n} P' 
		}
\end{array}
\]
\[
\begin{array}{ll}
\ltsrule{New}&	\tree{
		P \by{\news{\tilde{m}} \bactout{n}{V}} P' \quad 
               m \in \fn{V}
		}{
			\news{m} P \by{\news{m\cat\tilde{m}'} 
\bactout{n}{V}} P'
		}
		\\[6mm]
\ltsrule{Tau}	& \tree{
			P \by{\ell_1} P' \qquad Q \by{\ell_2} Q' \qquad \ell_1 \asymp \ell_2
		}{
			P \Par Q \by{\tau} \newsp{\bn{\ell_1} \cup \bn{\ell_2}}{P' \Par Q'}
		} 
		\\[6mm]
 \ltsrule{Par${}_L$}	& \tree{

			P \by{\ell} P' \quad \bn{\ell} \cap \fn{Q} = \es
		}{
			P \Par Q \by{\ell} P' \Par Q
		}

%\\[3mm]
%		\tree{
%			Q \by{\ell} Q' \quad \bn{\ell} \cap \fn{P} = \es
%		}{
%			P \Par Q \by{\ell} P \Par Q'
%		}\ \ltsrule{RPar}
	\end{array}
	\]
We omit $\ltsrule{Par${}_R$}$. 
	\caption{The Untyped (Early) Labelled Transition System \label{fig:untyped_LTS}}
\Hline
\end{figure}
\myparagraph{LTS over Untyped Processes}
The labelled transition system (LTS) over untyped processes, 
written by $P_1 \by{\ell} P_2$,  is defined in
Fig.~\ref{fig:untyped_LTS}. 
The rules are standard 
\cite{DBLP:conf/forte/KouzapasYH11,KY13,dkphdthesis}.
A process with a send prefix can
interact with the environment with a send action that carries a value
$V$ as in rule $\ltsrule{Out}$.  Dually in rule $\ltsrule{In}$ a
received prefixed process can observe a receive action of a value $V$.
Select and branch prefixed processes observe the select and branch
actions in rules $\ltsrule{Sel}$ and $\ltsrule{Bra}$ respectively.
Rule $\ltsrule{Alpha}$ closes the LTS
under alpha-renaiming.
Rule $\ltsrule{Res}$ closes the LTS under the name creation operator
provided that the restricted name does not occur free in the
observable action. 
If a restricted name occurs free in and an output
action then the name is added as in the bound name list of the action
and the continuation process performs scope opening as described in
rule $\ltsrule{New}$.  
Rule $\ltsrule{Tau}$ states that if two parallel processes can perform
dual actions then the two actions can synchronise to observe an
internal transition.  Rules $\ltsrule{Par${}_L$}$ 
closes the LTS under the parallel operator provided that the observable
action does not shared any bound names with the parallel processes.

\smallskip

\subsection{Characteristic Processes}\label{ss:char}
\noi We can use a session type to define the a {\em characteristic process}
which is the smallest process which inhabits a given session type. 
Later we define the bisimulation ($\fwb$) which only needs to check 
a characteristic process as an input. This reduces an amount of 
checking $V$ in $\bactout{n}{V}$  and $\bactinp{n}{V}$ in the labelled 
input and output transtions. 

\smallskip


\begin{definition}[Characteristic Process]\rm
%	Let names $\tilde{k}$ and type $\tilde{C}$; then we define a {\em characteristic process}:
%	$\map{\tilde{C}}^{\tilde{k}}$:
%	\[
%		\map{C_1, \cdots, C_n}^{k_1 \cdots k_n} = \map{C_1}^{k_1} \Par \dots \Par \map{C_n}^{k_n}		
%	\]
%	with 
We define a {\em characteristic process}
of type $C$ with name $u$ written by 
$\mapchar{C}{u}$ together with  
a mapping $\omapchar{U}$ in Fig.~\ref{fig:char}. 
\end{definition}

\smallskip

\begin{figure}[t]
	\[
	\begin{array}{c}
		\begin{array}{rclcl}
			\mapchar{\btinp{U} S}{u} &\!\!\defeq\!\!
& \binp{u}{x} (\mapchar{S}{u} \Par \mapchar{U}{x})
			\\
			\mapchar{\btout{U} S}{u} &\!\!\defeq\!\!& \bout{u}{\omapchar{U}} \mapchar{S}{u} %& & n \textrm{ fresh}
			\\
			\mapchar{\btsel{l : S}}{u} &\!\!\defeq\!\!& \bsel{u}{l} \mapchar{S}{u}
			\\
			\mapchar{\btbra{l_i: S_i}_{i \in I}}{u} &\!\!\defeq\!\!& \bbra{u}{l_i: \mapchar{S_i}{u}}_{i \in I}
			\\
		\mapchar{\tvar{t}}{u} \!\defeq\! \varp{X}_{\vart{t}}
& & 
			\mapchar{\trec{t}{S}}{u} \!\defeq\! \recp{X_{\vart{t}}}{\mapchar{S}{u}}
			\\
			\mapchar{\tinact}{u} &\!\!\defeq\!\!& \inact
			\\
\mapchar{\chtype{S}}{u} \!\defeq\! \bout{u}{\omapchar{S}} \inact & & 
\quad\mapchar{\chtype{L}}{u} \!\defeq\! \bout{u}{\omapchar{L}} \inact
			\\
\mapchar{\shot{C}}{u} & \!\!\defeq\!\! & \mapchar{\lhot{C}}{u} \!\defeq\! 
\appl{u}{\omapchar{C}}
\end{array}
\\
\Hline
\\
		\begin{array}{rcll}
\omapchar{S} &\!\!\defeq\!\!& s & (s \textrm{ fresh})
			\\
\omapchar{\chtype{S}} \defeq \omapchar{\chtype{L}} &\!\!\defeq\!\!& a & 
(a \textrm{ fresh})\quad\quad
			\\
			\omapchar{\shot{C}} \defeq \omapchar{\lhot{C}} &\!\!\defeq\!\!& \abs{x}{\mapchar{C}{x}}
		\end{array}
	\end{array}
	\]
\caption{Characteristic Processes\label{fig:char}}
\Hline
\end{figure}

%	\[
%	\begin{array}{rcllrcll}
%		\map{\btinp{C} S}^{u} &=& \binp{u}{x} (\map{S}^{u} \Par 
%\map{{C}}^{x})\\
%		\map{\btout{C} S}^{u} &=& \bout{u}{n} \map{S}^{u} & n\textrm{ fresh}
%		\\
%		\map{\btsel{l : S}}^{u} &=& \bsel{u}{l} \map{S}^{u}
%\\
%		\map{\btbra{l_i: S_i}_{i \in I}}^{u} &=& \bbra{k}{l_i: \map{S_i}^{u}}_{i \in I}
%		\\

%		\map{\tvar{t}}^{u} &=& \rvar{X}_{\tvar{t}}
%\\
%		\map{\trec{t}{S}}^{u} &=& \mu \rvar{X}_{\tvar{t}}.\map{S}^{u}
%		\\

%		\map{\btout{\lhot{C}} S}^{u} &=& \bout{u}{\abs{x}{\map{C}^{x}}} \map{S}^u
%\\
%		\map{\btinp{\lhot{C}} S}^{u} &=& \binp{u}{x} (\map{S}^u \Par \appl{x}{n}) & {n}\textrm{ fresh}
%		\\
%		\map{\btout{\shot{C}} S}^{u} &=& \bout{u}{\abs{x}{\map{C}^{x}}}
%\map{S}^u \\
%		\map{\btinp{\shot{C}} S}^{u} &=& \binp{u}{x} (\map{S}^u \Par \appl{x}{n}) & n\textrm{ fresh}
%		\\

%%		\map{\btinp{\chtype{S}} S}^{k} &=& \binp{k}{x} (\map{S}^k \Par \map{\chtype{S}}^y)
%%		&&
%%		\map{\btout{\chtype{S}} S}^{k} &=& \bout{k}{a} \map{S}^k  & a\textrm{ fresh}
%%		\\
%		\map{\tinact}^{u} &=& \inact
%\\
%		\map{\chtype{S}}^{u} &=& \bout{u}{s} \inact &s\textrm{ fresh}
%\\
%		\map{\chtype{\lhot{C}}}^{u} &=& \bout{u}{\abs{x} \map{C}^{x}} \inact
%		\\
%		\map{\chtype{\shot{C}}}^{u} &=& \bout{u}{\abs{x} \map{C}^{x}} \inact
%	\end{array}
%	\]
%\end{definition}

\begin{proposition}[Characteristic Processes]\rm
\label{pro:characteristic}
\begin{enumerate}
\item $\Gamma; \emptyset; \Delta \cat u:S \proves \mapchar{S}{u} \hastype \Proc$ 
\item $\Gamma \cat u:\chtype{S}; \emptyset; \Delta \proves \mapchar{\chtype{S}}{u} \hastype \Proc$
\item 	If $\Gamma; \emptyset; \Delta \proves \mapchar{C}{u} \hastype \Proc$
	then
	$\Gamma; \es; \Delta \proves u \hastype C$.
\end{enumerate}
\end{proposition}
\begin{IEEEproof}
	By induction on $\mapchar{S}{u}$, $\mapchar{\chtype{S}}{u}$
and $\mapchar{C}{u}$. 
\end{IEEEproof}

\subsection{Labelled Transition System for Environments}
\label{ss:elts}
\noi 
We define the labelled transition relation 
between a triple of environemnts, written by  
$(\Gamma, \Lambda_1, \Delta_1) \by{\ell} (\Gamma, \Lambda_2, \Delta_2)$, 
in Fig.~\ref{fig:envLTS}.

Rules $\eltsrule{SRecv}$ and $\eltsrule{ShRecv}$ describe
the input action $\bactinp{n}{V}$ ($n$ session or shared channel respectively)
on the type tuple $(\Gamma, \Lambda, \Delta)$.
We require the value $V$ has the same type as name $n$. Furthermore
we expect the resulting type tuple to contain the values that
consist value $V$.

Rule $\eltsrule{SOut}$ states the conditions for observing action
$\news{\tilde{m}} \bactout{s}{V}$ on a type tuple $(\Gamma, \Lambda, \Delta)$. 
The session environment $\Delta$ of the type tuple should include
a type for $s$ that is prefixed on the output type of type $U$.
Furthermore the dual channel $\dual{s}$ should not be
present in the session environment, since if it was present
the only communication that could take place is the interaction
between the two endpoints.
Under the latter conditions the type tuple may output any
value $V$ that is typed under a subset of $\Delta$ and
the session environment that types the restricted names
$\tilde{m}$. Scope extrusion of session names in $\tilde{m}$ requires
that the dual endpoints of $\tilde{m}$ appear in
the resulting session environment. Similarly for shared names
in $\tilde{m}$ that are extruted.
All free values used for typing $V$ are subtracted from the
resulting type tuple. Also the prefix of session $s$ is consumed
by the action.
Similarly, an output on a shared name is described
with rule $\eltsrule{ShOut}$ where we require a shared name
is typed with $\chtype{U}$. The requirements for
the output $V$ are indentical with the requirements for
rule $\eltsrule{SOut}$.

Rules $\eltsrule{Sel}$ and $\eltsrule{Bra}$ describe actions for
select and branch. The only requirements for both
rules is that the dual endpoint is not present in the session
environment and furthermore the action labels are present
in the type.
Hidden transitions do not change the session environment
or they follow the reduction on the session
environment (Definition~\ref{def:ses_red}) as we can see in rule
$\eltsrule{Tau}$.

%A second environment LTS, denoted $\hby{\ell}$,
%is defined in the lower part of Figure~\ref{fig:envLTS}.
%The definition substitutes rules
%$\eltsrule{SRecv}$ and $\eltsrule{ShRecv}$
%of relation $\by{\ell}$ with rule $\eltsrule{RRcv}$.
%% the corresponding input cases
%%of $\by{\ell}$ with the definitions of $\hby{\ell}$.
%All other cases remain the same as the cases for
%relation $\by{\ell}$.
%Rule $\eltsrule{RRcv}$ restricts the higher-order input
%in relation $\hby{\ell}$;
%only characteristic processes and trigger processes
%are allowed to be received on a higher-order input.
%Names can still be received as in the definition of
%the $\by{\ell}$ relation.
%The conditions for input follow the conditions
%for the $\by{\ell}$ definition.


\begin{figure}[t]
\[
\begin{array}{lc}
	\eltsrule{SRv}&\tree{
			\dual{s} \notin \dom{\Delta} \quad \Gamma; \Lambda'; \Delta' \proves V \hastype U
		}{
			(\Gamma; \Lambda; \Delta \cat s: \btinp{U} S) \by{\bactinp{s}{V}} (\Gamma; \Lambda\cat\Lambda'; \Delta\cat\Delta' \cat s: S)
		}
		\\[8mm]
		\eltsrule{ShRv}&\tree{
			\Gamma; \es; \es \proves a \hastype \chtype{U}
			\quad
			\Gamma; \Lambda'; \Delta' \proves V \hastype U
		}{
			(\Gamma; \Lambda; \Delta) \by{\bactinp{a}{{V}}} (\Gamma; \Lambda\cat\Lambda'; \Delta\cat\Delta')
		}
%		\eltsrule{RRcv}&\tree {
%\begin{array}{c}
%(\Gamma_1; \Lambda_1; \Delta_1) \by{\bactinp{n}{V}} (\Gamma_2; \Lambda_2; \Delta_2)
%\\
%			\begin{array}{lll}
%				 V  =  
%(\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}
% \vee  \abs{{x}}{\map{U}^{{x}}}  \vee m)  \textrm{ with } t \textrm{ fresh} 
%			\end{array}
%			\end{array}
%		}{
%			(\Gamma_1; \Lambda_1; \Delta_1) \hby{\bactinp{n}{V}} (\Gamma_2; \Lambda_1; \Delta_2)
%		}
	\end{array}
	\]
	\[
	\begin{array}{l}
		\eltsrule{SOut}\\
\tree{
			\begin{array}{lll}
			\Gamma \cat \Gamma'; \Lambda'; \Delta' \proves V \hastype U
&				
				\Gamma'; \es; \Delta_j \proves m_j  \hastype U_j
& 
				\dual{s} \notin \dom{\Delta}
\\
						\Delta'\backslash \cup_j \Delta_j \subseteq (\Delta \cat s: S)
& 
	\Gamma'; \es; \Delta_j' \proves \dual{m}_j  \hastype U_j'
& 
				\Lambda' \subseteq \Lambda
%				\dual{s} \notin \dom{\Delta}
%				\qquad 
%				\Gamma \cat \Gamma'; \Lambda'; \Delta_1 \cat \Delta_2 \proves V \hastype U
%				\qquad
%				\tilde{m} = m_1 \dots m_n
%				\\
%				\Gamma'; \es; \Delta_2 \proves m_1 \dots m_n \hastype U_1
%				\qquad
%				\Gamma'; \es; \Delta_3 \proves \dual{m}_1 \dots \dual{m}_n \hastype U_2
%				\qquad
%				\Lambda' \subseteq \Lambda
%				\qquad
%				\Delta_1 \subseteq (\Delta \cat s: S)
			\end{array}
		}{
			(\Gamma; \Lambda; \Delta \cat s: \btout{U} S) \by{\news{\tilde{m}} \bactout{s}{V}} (\Gamma \cat \Gamma'; \Lambda\backslash\Lambda';
			(\Delta \cat s: S \cat \cup_j \Delta_j') \backslash \Delta')
		}
\\[6mm]
\eltsrule{ShOut}\\
\tree{
		\begin{array}{lll}
			\Gamma \cat \Gamma' ; \Lambda'; \Delta' \proves V \hastype U &  
		\Gamma'; \es; \Delta_j \proves m_j \hastype U_j
& \Gamma ; \es ; \es \proves a \hastype \chtype{U}
				\\
			\Delta'\backslash \cup_j \Delta_j 
                         \subseteq \Delta
& 
		\Gamma'; \es; \Delta_j' \proves \dual{m}_j\hastype U_j'
& 
				\Lambda' \subseteq \Lambda
			\end{array}
%			\begin{array}{c}
%				\Gamma \cat \Gamma' \cat a: \chtype{U}; \Lambda'; \Delta_1 \cat \Delta_2 \proves V \hastype U
%				\qquad
%				\tilde{m} = m_1 \dots m_n
%				\\
%				\Gamma'; \es; \Delta_2 \proves m_1 \dots m_n \hastype U_1
%				\qquad
%				\Gamma'; \es; \Delta_3 \proves \dual{m}_1 \dots \dual{m}_n \hastype U_2
%				\qquad
%				\Lambda' \subseteq \Lambda
%				\qquad
%				\Delta_1 \subseteq \Delta
%			\end{array}
		}{
			(\Gamma ; \Lambda; \Delta) \by{\news{\tilde{m}} \bactout{a}{V}} (\Gamma \cat \Gamma' ; \Lambda\backslash\Lambda';
			(\Delta \cat \cup_j \Delta_j') \backslash \Delta')
		}
\end{array}
\]
\[
\begin{array}{lc}
		\eltsrule{Sel}&\tree{
			\dual{s} \notin \dom{\Delta} \quad j \in I
		}{
			(\Gamma; \Lambda; \Delta \cat s: \btsel{l_i: S_i}_{i \in I}) \by{\bactsel{s}{l_j}} (\Gamma; \Lambda; \Delta \cat s:S_j)
		}
\\[8mm]
		\eltsrule{Bra}&\tree{
			\dual{s} \notin \dom{\Delta} \quad j \in I
		}{
			(\Gamma; \Lambda; \Delta \cat s: \btbra{l_i: T_i}_{i \in I}) \by{\bactbra{s}{l_j}} (\Gamma; \Lambda; \Delta \cat s:S_j)
		}
		\\[8mm]
		\eltsrule{Tau}&\tree{
			\Delta_1 \red \Delta_2 \vee \Delta_1 = \Delta_2
		}{
			(\Gamma; \Lambda; \Delta_1) \by{\tau} (\Gamma; \Lambda; \Delta_2)
		}
%\\[6mm]
%		\eltsrule{RRcv}&\tree {
%\begin{array}{c}
%(\Gamma_1; \Lambda_1; \Delta_1) \by{\bactinp{n}{V}} (\Gamma_2; \Lambda_2; \Delta_2)
%\\
%			\begin{array}{lll}
%				 V  =  
%(\abs{{x}}{\binp{t}{y} (\appl{y}{{x}})}
% \vee  \abs{{x}}{\map{U}^{{x}}}  \vee m)  \textrm{ with } t \textrm{ fresh} 
%			\end{array}
%			\end{array}
%		}{
%			(\Gamma_1; \Lambda_1; \Delta_1) \hby{\bactinp{n}{V}} (\Gamma_2; \Lambda_1; \Delta_2)
%		}
	\end{array}
	\]
\caption{Labelled Transition Semantics for Typed Environments 
\label{fig:envLTS}}
\Hline
\end{figure}

\begin{definition}[Typed Transition Systems]\label{d:tlts}\rm
We write: 
\begin{enumerate}
\item 
$\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_2}{P_2}$
%$\Gamma; \emptyset; \Delta_1 \proves P_1 \hastype \Proc \by{\ell} \Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$
	whenever:
%
$P_1 \by{\ell} P_2$, $(\Gamma, \emptyset, \Delta_1) \by{\ell} (\Gamma, \emptyset, \Delta_2)$ and $\Gamma; \emptyset; \Delta_i \proves P_i \hastype \Proc$ 
($i=1,2$)
%
\item 
$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_2}{P_2}$
%$\Gamma; \emptyset; \Delta_1 \proves P_1 \hastype \Proc \hby{\ell} \Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$ 
whenever: 
$P_1 \by{\ell} P_2$, 
$(\Gamma, \emptyset, \Delta_1) \hby{\ell} (\Gamma, \emptyset, \Delta_2)$, 
and $\Gamma; \emptyset; \Delta_i \proves P_i \hastype \Proc$ 
($i=1,2$)
\end{enumerate}
%
We extend to $\By{}$ (resp.\ $\Hby{}$) and $\By{\hat{\ell}}$ (resp.\ $\Hby{\hat{\ell}}$) in the standard way.
\end{definition}
%For notational convenience we write: 
%$\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_2}{P_2}$
%instead of $\Gamma; \emptyset; \Delta_1 \proves P_1 \hastype \Proc \by{\ell} \Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$.
%We extend to $\By{}$ (resp.\ $\Hby{}$) and $\By{\hat{\ell}}$ (resp.\ $\Hby{\hat{\ell}}$) in the standard way.



\begin{lemma}[Invariant]\label{l:invariant}
	If $\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_2}{P_2}$
	then $\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_2}{P_2}$.
\end{lemma}

\begin{IEEEproof}
	The proof is straightforward from the definition of rule $\eltsrule{RRcv}$.
\end{IEEEproof}


\subsection{Reduction-Closed Congruence}
\label{subsec:rc}

\begin{definition}[Session Environment Confluence]\rm
	We denote $\Delta_1 \bistyp \Delta_2$ whenever $\exists \Delta$ such that
	$\Delta_1 \red^\ast \Delta$ and $\Delta_2 \red^\ast \Delta$.
\end{definition}

\begin{definition}[Typed Relation]\rm
	We say that
	$\Gamma; \emptyset; \Delta_1 \proves P_1 \hastype \Proc\ \Re \ \Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$
	is a typed relation whenever $P_1$ and $P_2$ are closed;
		$\Delta_1$ and $\Delta_2$ are well typed; and 
		$\Delta_1 \bistyp \Delta_2$.
We write
$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re \ }{\Delta_2}{P_2}$
for the typed relation $\Gamma; \emptyset; \Delta_1 \proves P_1 \hastype \Proc\ \Re \ \Gamma; \emptyset; \Delta_2 \proves P_2 \hastype \Proc$.
\end{definition}


\begin{definition}[Barbs]\rm
	Let $P$ closed.
	\begin{enumerate}
		\item	We write $P \barb{n}$ if $P \scong \newsp{\tilde{m}}{\bout{n}{V} P_2 \Par P_3}, n \notin \tilde{m}$.
			We write $P \Barb{n}$ if $P \red^* \barb{n}$.

		\item	We write $\Gamma; \emptyset; \Delta \proves P \barb{n}$ if
			$\Gamma; \emptyset; \Delta \proves P \hastype \Proc$ with $P \barb{n}$ and $\dual{n} \notin \Delta$.
			We write $\Gamma; \emptyset; \Delta \proves P \Barb{n}$ if $P \red^* P'$ and
			$\Gamma; \emptyset; \Delta' \proves P' \barb{n}$.			
	\end{enumerate}
\end{definition}

\begin{definition}[Context]\rm
	A context $\C$ is defined as:
	\begin{tabular}{rl}
	$\C$ $::=$ & $\hole \bnfbar \bout{u}{V} \C \bnfbar \binp{u}{x} \C
\bnfbar \bout{u}{\lambda x.\C} P
\bnfbar \news{n} \C$\\ 
             $\bnfbar$ & $\C \Par P \bnfbar P \Par \C 
\bnfbar \bsel{u}{l} \C \bnfbar \bbra{u}{l_1:P_1,..,l_i:\C,..l_n:P_n}$
	\end{tabular}

	Notation $\context{\C}{P}$ replaces $\hole$ in $\C$ with $P$.
\end{definition}

\begin{definition}[Barbed Reduction-Closed Congruence]\rm
	Typed relation
	$\horel{\Gamma}{\Delta_1}{P_1}{\ \Re\ }{\Delta_2}{P_2}$
	is a {\em barbed reduction-closed congruence} whenever:
	\begin{enumerate}
	\item	If $P_1 \red P_1'$ then there exists $P_2'$ such that $P_2 \red^* P_2'$ and
	$\horel{\Gamma}{\Delta_1'}{P_1'}{\ \Re\ }{\Delta_2'}{P_2'}$; 
and its symmetric case;
%		\item	If $P_2 \red P_2'$ then $\exists P_1', P_1 \red^* P_1'$ and
%		$\horel{\Gamma}{\Delta_1'}{P_1'}{\ \Re\ }{\Delta_2'}{P_2'}$
%		\end{itemize}

%		\item
%		\begin{itemize}
			\item	If $\Gamma;\emptyset;\Delta \proves P_1 \barb{n}$ then $\Gamma;\emptyset;\Delta \proves P_2 \Barb{n}$; and its symmetric case; and 

%			\item	If $\Gamma;\emptyset;\Delta \proves P_2 \barb{s}$ then $\Gamma;\emptyset;\Delta \proves P_1 \Barb{s}$.
%		\end{itemize}

		\item	for all $\C$, $\horel{\Gamma}{\Delta_1'}{\context{\C}{P_1}}{\ \Re\ }{\Delta_2'}{\context{\C}{P_2}}$
	\end{enumerate}
	The largest such congruence is denoted with $\cong$.
\end{definition}

\subsection{Three Bisimulations}
\label{subsec:bisimulation}
The second behavioural relation is contextual bisimulation:
%
\begin{definition}[Contextual Bisimulation]\rm
A typed relation $\Re$ is {\em a contextual bisimulation} if
for all $\horel{\Gamma}{\Delta_1}{P_1}{\ \Re \ }{\Delta_2}{Q_1}$, 
	\begin{enumerate} 
	\item	whenever 
$\horel{\Gamma}{\Delta_1}{P_1}
        {\by{\news{\tilde{m_1}} \bactout{n}{V}}}{\Delta_1'}{P_2}$,
there exists $\horel{\Gamma}{\Delta_2}{Q_1}{\By{\news{\tilde{m_2}} \bactout{n}{W}}}{\Delta_2'}{Q_2}$ such that, 
for all $R$ with $\fv{R}=x$:
\[\horel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}}{P_2 \Par R\subst{V}{x}}}
				{\ \Re\ }
				{\Delta_2''}{\newsp{\tilde{m_2}}{Q_2 \Par R\subst{W}{x}}};\]  
%\item	$\forall \news{\tilde{m_1}'} \bactout{n}{\tilde{m_1}}$ such that
%			\[
%				\horel{\Gamma}{\Delta_1}{P_1}{\by{\news{\tilde{m_1}'} \bactout{n}{\tilde{m_1}}}}{\Delta_1'}{P_2}
%			\]
%			implies that $\exists Q_2, \tilde{m_2}$ such that
%			\[
%				\horel{\Gamma}{\Delta_2}{Q_1}{\By{\news{\tilde{m_2}'} \bactout{n}{\tilde{m_2}}}}{\Delta_2'}{Q_2}
%			\]
%			and $\forall R$ with $\tilde{x} = \fn{R}$, 
%			then
%			\[
%				\horel{\Gamma}{\Delta_1''}{\newsp{\tilde{m_1}'}{P_2 \Par R \subst{\tilde{m_1}}{\tilde{x}}}}
%				{\ \Re \ }
%				{\Delta_2''}{\newsp{\tilde{m_2}'}{Q_2 \Par R \subst{\tilde{m_2}}{\tilde{x}}}}
%			\]
		\item	
for all $\horel{\Gamma}{\Delta_1}{P_1}{\by{\ell}}{\Delta_1'}{P_2}$ such that 
$\ell$ is not an output, 
 there exists $Q_2$ such that 
$\horel{\Gamma}{\Delta_2}{Q_1}{\By{\ell}}{\Delta_2'}{Q_2}$
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re \ }{\Delta_2'}{Q_2}$; and  

                      \item	The symmetric cases of 1 and 2.                
	\end{enumerate}
	The Knaster Tarski theorem ensures that the largest contextual bisimulation exists,
	it is called contextual bisimilarity and is denoted by $\wbc$.
\end{definition}

The contextual bisimulation in the general case is a hard relation to be computed
since it is universaly quantified over substituting processes. The next definition
of a bisimulation relation avoids the universal quantifier over processes.


\begin{definition}[Higher-Order Bisimulation]\rm
	\label{d:bisim}
A typed relation $\Re$ is {\em the HO bisimulation} if
for all $\horel{\Gamma}{\Delta_1}{P_1}{\ \Re \ }{\Delta_2}{Q_1}$, 
	\begin{enumerate}
		\item	whenever 
$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}} \bactout{n}{V_1}}}{\Delta_1'}{P_2}$, there exits 
$\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}$ such that, for fresh $t,x,s$, 
\[
\begin{array}{lrlll}
& \Gamma; \Delta''_1  \proves & 
{\newsp{\tilde{m_1}}{P_2 \Par \hotrigger{t}{V_1}}}\\ 
\Re & 
\Delta''_2 \proves & {\newsp{\tilde{m_2}}{Q_2 \Par \hotrigger{t}{V_2}}}
\end{array}
\]
		\item	
for all $\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}$ such that 
$\ell$ is not an output, 
 there exists $Q_2$ such that 
$\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\ell}}{\Delta_2'}{Q_2}$
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re \ }{\Delta_2'}{Q_2}$; and 

                      \item	The symmetric cases of 1 and 2.                
	\end{enumerate}
	The Knaster Tarski theorem ensures that the largest bisimulation exists,
	it is called bisimilarity and is denoted by $\hwb$.
\end{definition}


A different variant of the bisimulation based on a first order
output trigger.

\begin{definition}[First-Order Bisimulation]\rm
\label{d:fwb}
A typed relation $\Re$ is {\em the first-order bisimulation} if
for all $\horel{\Gamma}{\Delta_1}{P_1}{\ \Re \ }{\Delta_2}{Q_1}$, 
	\begin{enumerate}
		\item	whenever 
$\horel{\Gamma}{\Delta_1}{P_1}{\hby{\news{\tilde{m_1}} \bactout{n}{V_1}}}{\Delta_1'}{P_2}$ with $\Gamma; \es; \Delta \proves V_1 \hastype U$,  
there exits 
$\horel{\Gamma}{\Delta_2}{Q_1}{\Hby{\news{\tilde{m_2}} \bactout{n}{V_2}}}{\Delta_2'}{Q_2}$ with $\Gamma; \es; \Delta' \proves V_2 \hastype U$,  
such that, for fresh $t,x,s$, 
\[
\begin{array}{lrlll}
& \Gamma; \Delta''_1  \proves & 
{\newsp{\tilde{m_1}}
{P_2 \Par \fotrigger{t}{x}{s}{\btinp{U} \inact}{V_1}}}\\ 
\Re & 
\Delta''_2 \proves & {\newsp{\tilde{m_2}}{Q_2 \Par 
\fotrigger{t}{x}{s}{\btinp{U} \inact}{V_2}}}
\end{array}
\]
	\item	
for all $\horel{\Gamma}{\Delta_1}{P_1}{\hby{\ell}}{\Delta_1'}{P_2}$ such that 
$\ell$ is not an output, 
 there exists $Q_2$ such that 
$\horel{\Gamma}{\Delta_1}{Q_1}{\Hby{\ell}}{\Delta_1'}{Q_2}$
			and
			$\horel{\Gamma}{\Delta_1'}{P_2}{\ \Re \ }{\Delta_2'}{Q_2}$; and 

                      \item	The symmetric cases of 1 and 2.                
	\end{enumerate}
	The Knaster Tarski theorem ensures that the largest bisimulation exists,
	it is called bisimilarity and is denoted by $\fwb$.
\end{definition}

We present a result on process substitution.

\begin{lemma}[Process Substitution]\rm
	\label{lem:proc_subst}
	\begin{enumerate}
		\item	If $\horel{\Gamma}{\Delta_1'}{P \subst{\abs{x}{\binp{t}{y} (\appl{y}{x})}}{z}}{\wb}{\Delta_2'}{Q \subst{\abs{x}{\binp{t}{y} (\appl{y}{{x}})}}{z}}$ for fresh $t$, 
then for all $R$ such that $\fv{R} = {x}$, 
\[
\horel{\Gamma}{\Delta_1}{P \subst{\abs{{x}}{R}}{z}}{\wb}{\Delta_2}{Q \subst{\abs{{x}}{R}}{z}}
\]
		\item	If 
$\horel{\Gamma}{\Delta_1'}{P \subst{\abs{{x}}{\map{U}^{{x}}}}{z}}{\wb}{\Delta_2'}{Q \subst{\abs{{x}}{\map{U}^{{x}}}}{z}}$ for some $U$, 
then for all $R$ such that $\fv{R} = {x}$, 
\[
\horel{\Gamma}{\Delta_1}{P \subst{\abs{{x}}{R}}{z}}{\wb}{\Delta_2}{Q \subst{\abs{{x}}{R}}{z}}
\]
\end{enumerate}
\end{lemma}
%\begin{IEEEproof}
%	The details of the proof can be found in Appendix~\ref{app:sub_coinc}.
%\end{IEEEproof}

\begin{theorem}[Coincidence]\rm
	\label{the:coincidence}
	Relations $\hwb, \fwb, \wbc$ and $\cong$ coincide.
\end{theorem}

%\begin{IEEEproof}
%	The full details of the proof are in Appendix~\ref{app:sub_coinc}.
%	The theorem is split into a hierarchy of Lemmas. Specifically
%	Lemma~\ref{lem:wb_eq_wbf} proves 
%	$\wb$ coincides with $\fwb$; 
%	Lemma~\ref{lem:wb_is_wbc} exploits the process substitution result
%	(Lemma~\ref{lem:proc_subst}) to prove that $\hwb \subseteq \wbc$.
%	Lemma~\ref{lem:wbc_is_cong} shows that $\wbc$ is a congruence
%	which implies $\wbc \subseteq \cong$.
%	The final result comes from Lemma~\ref{lem:cong_is_wb} where
%	we use label testing to show that $\cong \subseteq \fwb$ using
%	the technique in developed in~\cite{Hennessy07}. The formulation of input
%	triggers in the bisimulation relation allows us to prove
%	the latter result without using a matching operator.
%\end{IEEEproof}

Processes that do not use shared names, (i.e.~they are typed with
$\proves_s$ type system), are inherintly $\tau$-inert.

\begin{lemma}[$\tau$-inertness]\rm
	\label{lem:tau_inert}
	Let $P$ is the $\HOp^{-\mathsf{sh}}$-calculus. 
% {\em without shared channels}, i.e.~we restrict a grammer of channel types to $C::= S$. 
Assume $\Gamma; \emptyset; \Delta \proves P \hastype \Proc$. Then 
$P \red^\ast P'$ implies $\Gamma; \Delta \proves 
P \hwb \Delta'\proves P'$ with $\Delta \red^\ast \Delta'$. 
\end{lemma}

%\begin{IEEEproof}
%	The proof is relied on the fact that processes of the
%	form $\Gamma; \es; \Delta \proves_s \bout{s}{V} P_1 \Par \binp{k}{x} P_2$
%	cannot have any typed transition observables and the fact
%	that bisimulation is a congruence.
%	See details in Appendix~\ref{app:sub_tau_inert}.
%	\qed
%\end{IEEEproof}

